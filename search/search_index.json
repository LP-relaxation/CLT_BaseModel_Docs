{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"City-level Transmission (CLT) Toolkit","text":""},{"location":"#overview","title":"Overview","text":"<p>This website provides code documentation, including tutorials and API references, for the CLT Toolkit. In addition, this website provides code and mathematical formulation documentation for MetroFluSim.</p> <p>The CLT Toolkit is a modular Python codebase for scalable compartmental models of respiratory virus transmission in a city. This effort is spearheaded by the Meyers Lab and epiENGAGE center under a CDC-funded effort to provide high quality technical tools for modeling. This toolkit takes care of fundamental simulation mechanics, allowing users to efficiently build and adapt multiple stochastic models without reimplementing common operations from scratch. This toolkit streamlines the construction of granular metapopulation models -- heterogenous regions can be easily modeled as distinct locations or subpopulations with age and risk groups, all integrated within a single metapopulation framework. </p> <p>The toolkit is used to create MetroFluSim, a high fidelity city-level influenza model that captures population-level immunity dynamics. The Meyers Lab at UT Austin is working directly with public health officials in the Texas cities of Austin, Dallas, El Paso, and Houston to create specific implementations of the <code>MetroFluSim</code> model tailored to each city.</p> <pre><code>flowchart TD\n    A[CLT Toolkit] --&gt;| create subclasses to specify compartments and structure | C{MetroFluSim}\n    C --&gt; | Austin-specific inputs, parameters, populations | D[Austin]\n    C --&gt; | ... | F[Dallas]\n    C --&gt; | ... | G[El Paso] \n    C --&gt; | Houston-specific inputs, parameters, populations | E[Houston]\n</code></pre>"},{"location":"#code-structure","title":"Code Structure","text":"Folder Description <code>clt_toolkit</code> CLT Toolkit abstract \"base\" classes. These provide reusable functionality for compartmental models, so users can run models without reimplementing simulation logic from scratch. <code>flu_core</code> Subclasses of <code>clt_base</code> that designate the compartments and structure of MetroFluSim, without specifying concrete inputs, parameters, or populations. <code>flu_instances</code> Stores data that specifies concrete inputs, parameters, and populations used to construct particular instances of <code>MetroFluSim</code> models (i.e. for particular cities). Contains scripts to simulate and calibrate these instances. <code>SIHR_core</code> Subclasses of <code>clt_base</code> that designate the compartments and structure of a simple S-I-H-R model, without specifying concrete inputs, parameters, or populations. Used as a tutorial example. <code>SIHR_instances</code> Stores data that specifies concrete inputs, parameters, and populations used to construct particular instances of the demo SIHR model in <code>SIHR_core</code>. <code>tests</code> \"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization.\" -- Gerald Weinberg"},{"location":"#toolkit-structure","title":"Toolkit Structure","text":"Folder File Description <code>clt_toolkit/</code> <code>base_components</code> Base classes for fundamental simulation objects, such as subpopulation models, metapopulation models, compartments, and transition variables that manage flow between compartments. <code>base_data_structures</code> Base dataclasses for storing compartment population values, epidemiological parameters, and simulation settings. <code>experiments</code> Tools for running many simulation replications of a model and managing the output. Can handle random sampling of parameters. <code>input_parsers</code> Helper functions for streamlining input reading and validation. <code>plotting</code> Plotting functions. <code>utils</code> Utility functions for convenience."},{"location":"#flu-core-structure","title":"Flu Core Structure","text":"<p>Subclasses for MetroFluSim.</p> Folder File Description <code>flu_core/</code> <code>flu_components</code> Subclasses of <code>clt_base</code> that define the compartments and corresponding logic of MetroFluSim. <code>flu_data_structures</code> Subclasses of dataclasses in <code>base_data_structures</code> that specify the exact fields (compartments, parameters, etc...) needed for MetroFluSim. <code>flu_torch_det_components</code> Deterministic, functional (non-object oriented) version of MetroFluSim that is autodifferentiable with PyTorch and optimized for performance. <code>flu_travel_functions</code> Computes exposure intensity due to local transmission within a subpopulation as well as travel between subpopulations."},{"location":"#flu-model-instances-structure","title":"Flu Model Instances Structure","text":"<p>Code for specific instances of the MetroFluSim model (e.g. for a specific city, with specific inputs, parameters, and populations).  </p> Folder Folder Description <code>flu_instances/</code> <code>calibration_research_input_files/</code> Input files for synthetic flu model instances used to evaluate calibration methods. <code>derived_inputs_computations/</code> Computations generating derived inputs (e.g. age-specific contact matrices). <code>examples/</code> Demo scripts showcasing CLT Toolkit and MetroFluSim functionality, including guides for calibration via optimization with automatic differentiation. <code>texas_flu_hosp_rate_20232024/</code> Publicly available Texas hospitalization data from 2023-2024 flu season. <code>texas_input_files/</code> Most up-to-date parameter values, derived from recent literature or within-host modeling."},{"location":"#installation","title":"Installation","text":"<p>The CLT Toolkit is written in Python 3.11.0.</p> <p>To download, build, and run the latest code release, run the following in Terminal: <pre><code>git clone https://github.com/LP-relaxation/CLT_BaseModel.git\n</code></pre></p> <p>In the package folder (<code>pyproject.toml</code> should be in this directory), run the following in Terminal: <pre><code>pip install -e .\n</code></pre> to install the package in editable mode. Note that some users may have to use <code>pip3 install -e .</code>, depending on their configuration.</p> <p>Packages required: <pre><code>numpy==1.24.3\npandas==1.5.3\npytest==8.3.3\npytorch==2.3.1\nsciris==3.2.0\n</code></pre></p> <p>Updated 08/14/2025. Toolkit and documentation are created by Linda Pei (\"LP\"), with feedback from R\u00e9my Pasco, Susan Ptak, Emily Javan, and other Meyers Lab members, and with supervision from Dave Morton and Lauren Meyers. Special thanks to Cary Murray for generous guidance on software engineering design. Special credit to Shuotao \"Sonny\" Diao for his ideas about updating compartments analogously to pushing flow on a graph and creating simulation logic that works for arbitrarily many compartments and transition variables. </p>"},{"location":"SIHR_components_walkthrough/","title":"A Simple Custom SIHR Model: Components Walkthrough","text":"<p>This page is getting updated, please check back soon!</p>"},{"location":"clt_base_package_reference/","title":"CLT Toolkit API Reference","text":"<p>Docstrings and references for <code>clt_toolkit</code> package.</p>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.PROJECT_ROOT","title":"<code>PROJECT_ROOT = Path(__file__).resolve().parent.parent</code>  <code>module-attribute</code>","text":""},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Compartment","title":"<code>Compartment</code>","text":"<p>               Bases: <code>StateVariable</code></p> <p>Class for epidemiological compartments (e.g. Susceptible,     Exposed, Infected, etc...).</p> <p>Attributes:</p> Name Type Description <code>current_inflow</code> <code>np.ndarray of shape (A, R</code> <p>Used to sum up all  transition variable realizations incoming to this compartment for age-risk groups.</p> <code>current_outflow</code> <code>np.ndarray of shape (A, R</code> <p>Used to sum up all transition variable realizations outgoing from this compartment for age-risk groups.</p> <p>See <code>StateVariable</code> docstring for additional attributes     and A, R definitions.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class Compartment(StateVariable):\n    \"\"\"\n    Class for epidemiological compartments (e.g. Susceptible,\n        Exposed, Infected, etc...).\n\n    Attributes:\n        current_inflow (np.ndarray of shape (A, R)):\n            Used to sum up all  transition variable realizations\n            incoming to this compartment for age-risk groups.\n        current_outflow (np.ndarray of shape (A, R)):\n            Used to sum up all transition variable realizations\n            outgoing from this compartment for age-risk groups.\n\n    See `StateVariable` docstring for additional attributes\n        and A, R definitions.\n    \"\"\"\n\n    def __init__(self,\n                 init_val):\n        super().__init__(np.asarray(init_val, dtype=float))\n\n        self.current_inflow = np.zeros(np.shape(init_val))\n        self.current_outflow = np.zeros(np.shape(init_val))\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Updates `current_val` attribute in-place by adding\n            `current_inflow` (sum of all incoming transition variables'\n            realizations) and subtracting current outflow (sum of all\n            outgoing transition variables' realizations).\n        \"\"\"\n        self.current_val = self.current_val + self.current_inflow - self.current_outflow\n\n    def reset_inflow(self) -&gt; None:\n        \"\"\"\n        Resets `current_inflow` attribute to zero array.\n        \"\"\"\n        self.current_inflow = np.zeros(np.shape(self.current_inflow))\n\n    def reset_outflow(self) -&gt; None:\n        \"\"\"\n        Resets `current_outflow` attribute to zero array.\n        \"\"\"\n        self.current_outflow = np.zeros(np.shape(self.current_outflow))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Compartment.reset_inflow","title":"<code>reset_inflow() -&gt; None</code>","text":"<p>Resets <code>current_inflow</code> attribute to zero array.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset_inflow(self) -&gt; None:\n    \"\"\"\n    Resets `current_inflow` attribute to zero array.\n    \"\"\"\n    self.current_inflow = np.zeros(np.shape(self.current_inflow))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Compartment.reset_outflow","title":"<code>reset_outflow() -&gt; None</code>","text":"<p>Resets <code>current_outflow</code> attribute to zero array.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset_outflow(self) -&gt; None:\n    \"\"\"\n    Resets `current_outflow` attribute to zero array.\n    \"\"\"\n    self.current_outflow = np.zeros(np.shape(self.current_outflow))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Compartment.update_current_val","title":"<code>update_current_val() -&gt; None</code>","text":"<p>Updates <code>current_val</code> attribute in-place by adding     <code>current_inflow</code> (sum of all incoming transition variables'     realizations) and subtracting current outflow (sum of all     outgoing transition variables' realizations).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Updates `current_val` attribute in-place by adding\n        `current_inflow` (sum of all incoming transition variables'\n        realizations) and subtracting current outflow (sum of all\n        outgoing transition variables' realizations).\n    \"\"\"\n    self.current_val = self.current_val + self.current_inflow - self.current_outflow\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.DataClassProtocol","title":"<code>DataClassProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>class DataClassProtocol(Protocol):\n    __dataclass_fields__: dict\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.DynamicVal","title":"<code>DynamicVal</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that dynamically adjust their values based the current values of other <code>StateVariable</code> instances.</p> <p>This class should model social distancing (and more broadly, staged-alert policies). For example, if we consider a case where transmission rates decrease when number infected increase above a certain level, we can create a subclass of DynamicVal that models a coefficient that modifies transmission rates, depending on the epi compartments corresponding to infected individuals.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class DynamicVal(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that dynamically adjust\n    their values based the current values of other `StateVariable`\n    instances.\n\n    This class should model social distancing (and more broadly,\n    staged-alert policies). For example, if we consider a\n    case where transmission rates decrease when number infected\n    increase above a certain level, we can create a subclass of\n    DynamicVal that models a coefficient that modifies transmission\n    rates, depending on the epi compartments corresponding to\n    infected individuals.\n\n    Inherits attributes from `StateVariable`.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 is_enabled: Optional[bool] = False):\n        \"\"\"\n\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation.\n            is_enabled (Optional[bool]):\n                if `False`, this dynamic value does not get updated\n                during the simulation and defaults to its `init_val`.\n                This is designed to allow easy toggling of\n                simulations with or without staged alert policies\n                and other interventions.\n        \"\"\"\n\n        super().__init__(init_val)\n        self.is_enabled = is_enabled\n\n    @abstractmethod\n    def update_current_val(self,\n                           state: SubpopState,\n                           params: SubpopParams) -&gt; None:\n        \"\"\"\n        Args:\n            state (SubpopState):\n                holds subpopulation simulation state (current values of\n                `StateVariable` instances).\n            params (SubpopParams):\n                holds values of epidemiological parameters.\n        \"\"\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.DynamicVal.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, is_enabled: Optional[bool] = False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation.</p> <code>None</code> <code>is_enabled</code> <code>Optional[bool]</code> <p>if <code>False</code>, this dynamic value does not get updated during the simulation and defaults to its <code>init_val</code>. This is designed to allow easy toggling of simulations with or without staged alert policies and other interventions.</p> <code>False</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             is_enabled: Optional[bool] = False):\n    \"\"\"\n\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation.\n        is_enabled (Optional[bool]):\n            if `False`, this dynamic value does not get updated\n            during the simulation and defaults to its `init_val`.\n            This is designed to allow easy toggling of\n            simulations with or without staged alert policies\n            and other interventions.\n    \"\"\"\n\n    super().__init__(init_val)\n    self.is_enabled = is_enabled\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.DynamicVal.update_current_val","title":"<code>update_current_val(state: SubpopState, params: SubpopParams) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds subpopulation simulation state (current values of <code>StateVariable</code> instances).</p> required <code>params</code> <code>SubpopParams</code> <p>holds values of epidemiological parameters.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self,\n                       state: SubpopState,\n                       params: SubpopParams) -&gt; None:\n    \"\"\"\n    Args:\n        state (SubpopState):\n            holds subpopulation simulation state (current values of\n            `StateVariable` instances).\n        params (SubpopParams):\n            holds values of epidemiological parameters.\n    \"\"\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.EpiMetric","title":"<code>EpiMetric</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for epi metrics in epidemiological model.</p> <p>This is intended for variables that are aggregate deterministic functions of the <code>SubpopState</code> (including <code>Compartment</code> <code>current_val</code>'s, other parameters, and time.)</p> <p>For example, population-level immunity variables should be modeled as a <code>EpiMetric</code> subclass, with a concrete implementation of the abstract method <code>get_change_in_current_val</code>.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>Attributes:</p> Name Type Description <code>current_val</code> <code>np.ndarray of shape (A, R</code> <p>same size as init_val, holds current value of <code>StateVariable</code> for age-risk groups.</p> <code>change_in_current_val</code> <p>(np.ndarray of shape (A, R)): initialized to None, but during simulation holds change in current value of <code>EpiMetric</code> for age-risk groups (size A x R, where A is the number of risk groups and R is number of age groups).</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class EpiMetric(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for epi metrics in epidemiological model.\n\n    This is intended for variables that are aggregate deterministic functions of\n    the `SubpopState` (including `Compartment` `current_val`'s, other parameters,\n    and time.)\n\n    For example, population-level immunity variables should be\n    modeled as a `EpiMetric` subclass, with a concrete\n    implementation of the abstract method `get_change_in_current_val`.\n\n    Inherits attributes from `StateVariable`.\n\n    Attributes:\n        current_val (np.ndarray of shape (A, R)):\n            same size as init_val, holds current value of `StateVariable`\n            for age-risk groups.\n        change_in_current_val : (np.ndarray of shape (A, R)):\n            initialized to None, but during simulation holds change in\n            current value of `EpiMetric` for age-risk groups\n            (size A x R, where A is the number of risk groups and R is number\n            of age groups).\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val):\n        \"\"\"\n        Args:\n            init_val (np.ndarray of shape (A, R)):\n                2D array that contains nonnegative floats,\n                corresponding to initial value of dynamic val,\n                where i,jth entry corresponds to age group i and\n                risk group j.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.change_in_current_val = None\n\n    @abstractmethod\n    def get_change_in_current_val(self,\n                                  state: SubpopState,\n                                  params: SubpopParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns change in current value of dynamic val,\n        based on current state of the simulation and epidemiological parameters.\n\n        NOTE:\n            OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n\n        Output should be a numpy array of size A x R, where A\n        is number of age groups and R is number of risk groups.\n\n        Args:\n            state (SubpopState):\n                holds subpopulation simulation state (current values of\n                `StateVariable` instances).\n            params (SubpopParams):\n                holds values of epidemiological parameters.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                size A x R, where A is the number of age groups and\n                R is number of risk groups.\n        \"\"\"\n        pass\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Adds `change_in_current_val` attribute to\n        `current_val` attribute in-place.\n        \"\"\"\n\n        self.current_val += self.change_in_current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.EpiMetric.__init__","title":"<code>__init__(init_val)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>np.ndarray of shape (A, R</code> <p>2D array that contains nonnegative floats, corresponding to initial value of dynamic val, where i,jth entry corresponds to age group i and risk group j.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             init_val):\n    \"\"\"\n    Args:\n        init_val (np.ndarray of shape (A, R)):\n            2D array that contains nonnegative floats,\n            corresponding to initial value of dynamic val,\n            where i,jth entry corresponds to age group i and\n            risk group j.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.change_in_current_val = None\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.EpiMetric.get_change_in_current_val","title":"<code>get_change_in_current_val(state: SubpopState, params: SubpopParams, num_timesteps: int) -&gt; np.ndarray</code>  <code>abstractmethod</code>","text":"<p>Computes and returns change in current value of dynamic val, based on current state of the simulation and epidemiological parameters.</p> NOTE <p>OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.</p> <p>Output should be a numpy array of size A x R, where A is number of age groups and R is number of risk groups.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds subpopulation simulation state (current values of <code>StateVariable</code> instances).</p> required <code>params</code> <code>SubpopParams</code> <p>holds values of epidemiological parameters.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) size A x R, where A is the number of age groups and R is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef get_change_in_current_val(self,\n                              state: SubpopState,\n                              params: SubpopParams,\n                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns change in current value of dynamic val,\n    based on current state of the simulation and epidemiological parameters.\n\n    NOTE:\n        OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n\n    Output should be a numpy array of size A x R, where A\n    is number of age groups and R is number of risk groups.\n\n    Args:\n        state (SubpopState):\n            holds subpopulation simulation state (current values of\n            `StateVariable` instances).\n        params (SubpopParams):\n            holds values of epidemiological parameters.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            size A x R, where A is the number of age groups and\n            R is number of risk groups.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.EpiMetric.update_current_val","title":"<code>update_current_val() -&gt; None</code>","text":"<p>Adds <code>change_in_current_val</code> attribute to <code>current_val</code> attribute in-place.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Adds `change_in_current_val` attribute to\n    `current_val` attribute in-place.\n    \"\"\"\n\n    self.current_val += self.change_in_current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.InteractionTerm","title":"<code>InteractionTerm</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that depend on the state of more than one <code>SubpopModel</code> (i.e., that depend on more than one <code>SubpopState</code>). These variables are functions of how subpopulations interact.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class InteractionTerm(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that depend on the state of\n    more than one `SubpopModel` (i.e., that depend on more than one\n    `SubpopState`). These variables are functions of how subpopulations\n    interact.\n\n    Inherits attributes from `StateVariable`.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    @abstractmethod\n    def update_current_val(self,\n                           subpop_state: SubpopState,\n                           subpop_params: SubpopParams) -&gt; None:\n        \"\"\"\n        Subclasses must provide a concrete implementation of\n        updating `current_val` in-place.\n\n        Args:\n            subpop_params (SubpopParams):\n                holds values of subpopulation's epidemiological parameters.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.InteractionTerm.update_current_val","title":"<code>update_current_val(subpop_state: SubpopState, subpop_params: SubpopParams) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Subclasses must provide a concrete implementation of updating <code>current_val</code> in-place.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_params</code> <code>SubpopParams</code> <p>holds values of subpopulation's epidemiological parameters.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self,\n                       subpop_state: SubpopState,\n                       subpop_params: SubpopParams) -&gt; None:\n    \"\"\"\n    Subclasses must provide a concrete implementation of\n    updating `current_val` in-place.\n\n    Args:\n        subpop_params (SubpopParams):\n            holds values of subpopulation's epidemiological parameters.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.JointTransitionTypes","title":"<code>JointTransitionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defines available options for <code>transition_type</code> in <code>TransitionVariableGroup</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>class JointTransitionTypes(str, Enum):\n    \"\"\"\n    Defines available options for `transition_type` in `TransitionVariableGroup`.\n    \"\"\"\n    MULTINOM = \"multinom\"\n    MULTINOM_DETERMINISTIC = \"multinom_deterministic\"\n    MULTINOM_TAYLOR_APPROX = \"multinom_taylor_approx\"\n    MULTINOM_TAYLOR_APPROX_DETERMINISTIC = \"multinom_taylor_approx_deterministic\"\n    POISSON = \"poisson\"\n    POISSON_DETERMINISTIC = \"poisson_deterministic\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel","title":"<code>MetapopModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class that bundles <code>SubpopModel</code>s linked using     a travel model.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class MetapopModel(ABC):\n    \"\"\"\n    Abstract base class that bundles `SubpopModel`s linked using\n        a travel model.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 subpop_models: list[dict],\n                 mixing_params: dict,\n                 name: str = \"\"):\n        \"\"\"\n        Params:\n            name (str):\n                unique identifier for `MetapopModel`.\n        \"\"\"\n\n        # We use both an `objdict` and an `odict` (ordered):\n        # - `objdict`: allows convenient dot-access for users (consistent with the rest of the model)\n        # - `odict`: preserves the order of subpopulations, which is crucial because\n        #   the index in the state and parameter tensors depends on it.\n        # The `objdict` is \"outwards-facing\" for user access, while the `odict`\n        # is used internally to ensure tensor indices are consistent.\n\n        subpop_models_dict = sc.objdict()\n        for model in subpop_models:\n            subpop_models_dict[model.name] = model\n\n        _subpop_models_ordered_dict = sc.odict()\n        for model in subpop_models:\n            _subpop_models_ordered_dict[model.name] = model\n\n        self.subpop_models = subpop_models_dict\n        self._subpop_models_ordered = _subpop_models_ordered_dict\n\n        self.name = name\n\n        # Concrete implementations of `MetapopModel` will generally\n        #   do something more with these parameters -- but this is\n        #   just default storage here\n        self.mixing_params = mixing_params\n\n        for model in self.subpop_models.values():\n            model.metapop_model = self\n\n    def simulate_until_day(self,\n                           simulation_end_day: int) -&gt; None:\n        \"\"\"\n        Advance simulation model time until `simulation_end_day` in\n        `MetapopModel`.\n\n        NOT just the same as looping through each `SubpopModel`'s\n        `simulate_until_day` method. On the `MetapopModel`,\n        because `SubpopModel` instances are linked with `InteractionTerm`s\n        and are not independent of each other, this `MetapopModel`'s\n        `simulate_until_day` method has additional functionality.\n\n        Note: the update order at the beginning of each day is very important!\n\n        - First, each `SubpopModel` updates its daily state (computing\n        `Schedule` and `DynamicVal` instances).\n\n        - Second, the `MetapopModel` computes quantities that depend\n        on more than one subpopulation (i.e. inter-subpop quantities,\n        such as the force of infection to each subpopulation in a travel\n        model, where these terms depend on the number infected in\n        other subpopulations) and then applies the update to each\n        `SubpopModel` according to the user-implemented method\n        `apply_inter_subpop_updates.`\n\n        - Third, each `SubpopModel` simulates discretized timesteps (sampling\n        `TransitionVariable`s, updating `EpiMetric`s, and updating `Compartment`s).\n\n        Note: we only update inter-subpop quantities once a day, not at every timestep\n        -- in other words, the travel model state-dependent values are only\n        updated daily -- this is to avoid severe computation inefficiency\n\n        Args:\n            simulation_end_day (positive int):\n                stop simulation at `simulation_end_day` (i.e. exclusive,\n                simulate up to but not including `simulation_end_day`).\n        \"\"\"\n\n        if self.current_simulation_day &gt; simulation_end_day:\n            raise MetapopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                    f\"exceeds last simulation day ({simulation_end_day}).\")\n\n        # Adding this in case the user manually changes the initial\n        #   value or current value of any state variable --\n        #   otherwise, the state will not get updated\n        # Analogous logic in SubpopModel's `simulate_until_day` method\n        for subpop_model in self.subpop_models.values():\n            subpop_model.state.sync_to_current_vals(subpop_model.all_state_variables)\n\n        while self.current_simulation_day &lt; simulation_end_day:\n\n            for subpop_model in self.subpop_models.values():\n                subpop_model.prepare_daily_state()\n\n            self.apply_inter_subpop_updates()\n\n            for subpop_model in self.subpop_models.values():\n\n                save_daily_history = subpop_model.simulation_settings.save_daily_history\n                timesteps_per_day = subpop_model.simulation_settings.timesteps_per_day\n\n                subpop_model._simulate_timesteps(timesteps_per_day)\n\n                if save_daily_history:\n                    subpop_model.save_daily_history()\n\n                subpop_model.increment_simulation_day()\n\n    def apply_inter_subpop_updates(self):\n        \"\"\"\n        `MetapopModel` subclasses can **optionally** override this method\n        with a customized implementation. Otherwise, by default does nothing.\n\n        Called once a day (not for each discretized timestep), after each\n        subpop model's daily state is prepared, and before\n        discretized transitions are computed.\n\n        This method computes quantities that depend on multiple subpopulations\n        (e.g. this is where a travel model should be implemented).\n\n        See `simulate_until_day` method for more details.\n        \"\"\"\n\n        pass\n\n    def reset_simulation(self):\n        \"\"\"\n        Resets `MetapopModel` by resetting and clearing\n        history on all `SubpopModel` instances in\n        `subpop_models`.\n        \"\"\"\n\n        for subpop_model in self.subpop_models.values():\n            subpop_model.reset_simulation()\n\n    @property\n    def current_simulation_day(self) -&gt; int:\n        \"\"\"\n        Returns:\n            Current simulation day. The current simulation day of the\n            `MetapopModel` should be the same as each individual `SubpopModel`\n            in the `MetapopModel`. Otherwise, an error is raised.\n        \"\"\"\n\n        current_simulation_days_list = []\n\n        for subpop_model in self.subpop_models.values():\n            current_simulation_days_list.append(subpop_model.current_simulation_day)\n\n        if len(set(current_simulation_days_list)) &gt; 1:\n            raise MetapopModelError(\"Subpopulation models are on different simulation days \"\n                                    \"and are out-of-sync. This may be caused by simulating \"\n                                    \"a subpopulation model independently from the \"\n                                    \"metapopulation model. Fix error and try again.\")\n        else:\n            return current_simulation_days_list[0]\n\n    @property\n    def current_real_date(self) -&gt; datetime.date:\n        \"\"\"\n        Returns:\n            Current real date corresponding to current simulation day.\n            The current real date of the `MetapopModel` should be the same as\n            each individual `SubpopModel` in the `MetapopModel`.\n            Otherwise, an error is raised.\n        \"\"\"\n\n        current_real_dates_list = []\n\n        for subpop_model in self.subpop_models.values():\n            current_real_dates_list.append(subpop_model.current_real_date)\n\n        if len(set(current_real_dates_list)) &gt; 1:\n            raise MetapopModelError(\"Subpopulation models are on different real dates \\n\"\n                                    \"and are out-of-sync. This may be caused by simulating \\n\"\n                                    \"a subpopulation model independently from the \\n\"\n                                    \"metapopulation model. Please reset and restart simulation, \\n\"\n                                    \"and try again.\")\n        else:\n            return current_real_dates_list[0]\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.current_real_date","title":"<code>current_real_date: datetime.date</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>date</code> <p>Current real date corresponding to current simulation day.</p> <code>date</code> <p>The current real date of the <code>MetapopModel</code> should be the same as</p> <code>date</code> <p>each individual <code>SubpopModel</code> in the <code>MetapopModel</code>.</p> <code>date</code> <p>Otherwise, an error is raised.</p>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.current_simulation_day","title":"<code>current_simulation_day: int</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>Current simulation day. The current simulation day of the</p> <code>int</code> <p><code>MetapopModel</code> should be the same as each individual <code>SubpopModel</code></p> <code>int</code> <p>in the <code>MetapopModel</code>. Otherwise, an error is raised.</p>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.__init__","title":"<code>__init__(subpop_models: list[dict], mixing_params: dict, name: str = '')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>unique identifier for <code>MetapopModel</code>.</p> <code>''</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             subpop_models: list[dict],\n             mixing_params: dict,\n             name: str = \"\"):\n    \"\"\"\n    Params:\n        name (str):\n            unique identifier for `MetapopModel`.\n    \"\"\"\n\n    # We use both an `objdict` and an `odict` (ordered):\n    # - `objdict`: allows convenient dot-access for users (consistent with the rest of the model)\n    # - `odict`: preserves the order of subpopulations, which is crucial because\n    #   the index in the state and parameter tensors depends on it.\n    # The `objdict` is \"outwards-facing\" for user access, while the `odict`\n    # is used internally to ensure tensor indices are consistent.\n\n    subpop_models_dict = sc.objdict()\n    for model in subpop_models:\n        subpop_models_dict[model.name] = model\n\n    _subpop_models_ordered_dict = sc.odict()\n    for model in subpop_models:\n        _subpop_models_ordered_dict[model.name] = model\n\n    self.subpop_models = subpop_models_dict\n    self._subpop_models_ordered = _subpop_models_ordered_dict\n\n    self.name = name\n\n    # Concrete implementations of `MetapopModel` will generally\n    #   do something more with these parameters -- but this is\n    #   just default storage here\n    self.mixing_params = mixing_params\n\n    for model in self.subpop_models.values():\n        model.metapop_model = self\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.apply_inter_subpop_updates","title":"<code>apply_inter_subpop_updates()</code>","text":"<p><code>MetapopModel</code> subclasses can optionally override this method with a customized implementation. Otherwise, by default does nothing.</p> <p>Called once a day (not for each discretized timestep), after each subpop model's daily state is prepared, and before discretized transitions are computed.</p> <p>This method computes quantities that depend on multiple subpopulations (e.g. this is where a travel model should be implemented).</p> <p>See <code>simulate_until_day</code> method for more details.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def apply_inter_subpop_updates(self):\n    \"\"\"\n    `MetapopModel` subclasses can **optionally** override this method\n    with a customized implementation. Otherwise, by default does nothing.\n\n    Called once a day (not for each discretized timestep), after each\n    subpop model's daily state is prepared, and before\n    discretized transitions are computed.\n\n    This method computes quantities that depend on multiple subpopulations\n    (e.g. this is where a travel model should be implemented).\n\n    See `simulate_until_day` method for more details.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.reset_simulation","title":"<code>reset_simulation()</code>","text":"<p>Resets <code>MetapopModel</code> by resetting and clearing history on all <code>SubpopModel</code> instances in <code>subpop_models</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset_simulation(self):\n    \"\"\"\n    Resets `MetapopModel` by resetting and clearing\n    history on all `SubpopModel` instances in\n    `subpop_models`.\n    \"\"\"\n\n    for subpop_model in self.subpop_models.values():\n        subpop_model.reset_simulation()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModel.simulate_until_day","title":"<code>simulate_until_day(simulation_end_day: int) -&gt; None</code>","text":"<p>Advance simulation model time until <code>simulation_end_day</code> in <code>MetapopModel</code>.</p> <p>NOT just the same as looping through each <code>SubpopModel</code>'s <code>simulate_until_day</code> method. On the <code>MetapopModel</code>, because <code>SubpopModel</code> instances are linked with <code>InteractionTerm</code>s and are not independent of each other, this <code>MetapopModel</code>'s <code>simulate_until_day</code> method has additional functionality.</p> <p>Note: the update order at the beginning of each day is very important!</p> <ul> <li> <p>First, each <code>SubpopModel</code> updates its daily state (computing <code>Schedule</code> and <code>DynamicVal</code> instances).</p> </li> <li> <p>Second, the <code>MetapopModel</code> computes quantities that depend on more than one subpopulation (i.e. inter-subpop quantities, such as the force of infection to each subpopulation in a travel model, where these terms depend on the number infected in other subpopulations) and then applies the update to each <code>SubpopModel</code> according to the user-implemented method <code>apply_inter_subpop_updates.</code></p> </li> <li> <p>Third, each <code>SubpopModel</code> simulates discretized timesteps (sampling <code>TransitionVariable</code>s, updating <code>EpiMetric</code>s, and updating <code>Compartment</code>s).</p> </li> </ul> <p>Note: we only update inter-subpop quantities once a day, not at every timestep -- in other words, the travel model state-dependent values are only updated daily -- this is to avoid severe computation inefficiency</p> <p>Parameters:</p> Name Type Description Default <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at <code>simulation_end_day</code> (i.e. exclusive, simulate up to but not including <code>simulation_end_day</code>).</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def simulate_until_day(self,\n                       simulation_end_day: int) -&gt; None:\n    \"\"\"\n    Advance simulation model time until `simulation_end_day` in\n    `MetapopModel`.\n\n    NOT just the same as looping through each `SubpopModel`'s\n    `simulate_until_day` method. On the `MetapopModel`,\n    because `SubpopModel` instances are linked with `InteractionTerm`s\n    and are not independent of each other, this `MetapopModel`'s\n    `simulate_until_day` method has additional functionality.\n\n    Note: the update order at the beginning of each day is very important!\n\n    - First, each `SubpopModel` updates its daily state (computing\n    `Schedule` and `DynamicVal` instances).\n\n    - Second, the `MetapopModel` computes quantities that depend\n    on more than one subpopulation (i.e. inter-subpop quantities,\n    such as the force of infection to each subpopulation in a travel\n    model, where these terms depend on the number infected in\n    other subpopulations) and then applies the update to each\n    `SubpopModel` according to the user-implemented method\n    `apply_inter_subpop_updates.`\n\n    - Third, each `SubpopModel` simulates discretized timesteps (sampling\n    `TransitionVariable`s, updating `EpiMetric`s, and updating `Compartment`s).\n\n    Note: we only update inter-subpop quantities once a day, not at every timestep\n    -- in other words, the travel model state-dependent values are only\n    updated daily -- this is to avoid severe computation inefficiency\n\n    Args:\n        simulation_end_day (positive int):\n            stop simulation at `simulation_end_day` (i.e. exclusive,\n            simulate up to but not including `simulation_end_day`).\n    \"\"\"\n\n    if self.current_simulation_day &gt; simulation_end_day:\n        raise MetapopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                f\"exceeds last simulation day ({simulation_end_day}).\")\n\n    # Adding this in case the user manually changes the initial\n    #   value or current value of any state variable --\n    #   otherwise, the state will not get updated\n    # Analogous logic in SubpopModel's `simulate_until_day` method\n    for subpop_model in self.subpop_models.values():\n        subpop_model.state.sync_to_current_vals(subpop_model.all_state_variables)\n\n    while self.current_simulation_day &lt; simulation_end_day:\n\n        for subpop_model in self.subpop_models.values():\n            subpop_model.prepare_daily_state()\n\n        self.apply_inter_subpop_updates()\n\n        for subpop_model in self.subpop_models.values():\n\n            save_daily_history = subpop_model.simulation_settings.save_daily_history\n            timesteps_per_day = subpop_model.simulation_settings.timesteps_per_day\n\n            subpop_model._simulate_timesteps(timesteps_per_day)\n\n            if save_daily_history:\n                subpop_model.save_daily_history()\n\n            subpop_model.increment_simulation_day()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.MetapopModelError","title":"<code>MetapopModelError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for metapopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class MetapopModelError(Exception):\n    \"\"\"Custom exceptions for metapopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Schedule","title":"<code>Schedule</code>  <code>dataclass</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that are functions of real-world dates -- for example, contact matrices (which depend on the day of the week and whether the current day is a holiday), historical vaccination data, and seasonality.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@dataclass\nclass Schedule(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that are functions of real-world\n    dates -- for example, contact matrices (which depend on the day of\n    the week and whether the current day is a holiday), historical\n    vaccination data, and seasonality.\n\n    Inherits attributes from `StateVariable`.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: Optional[dict] = None):\n        \"\"\"\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                has a \"date\" column with strings in format `\"YYYY-MM-DD\"`\n                of consecutive calendar days, and other columns\n                corresponding to values on those days\n        \"\"\"\n\n        super().__init__(init_val)\n        self.timeseries_df = timeseries_df\n\n    @abstractmethod\n    def update_current_val(self,\n                           params: SubpopParams,\n                           current_date: datetime.date) -&gt; None:\n        \"\"\"\n        Subpop classes must provide a concrete implementation of\n        updating `current_val` in-place.\n\n        Args:\n            params (SubpopParams):\n                fixed parameters of subpopulation model.\n            current_date (date):\n                real-world date corresponding to\n                model's current simulation day.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Schedule.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, timeseries_df: Optional[dict] = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>has a \"date\" column with strings in format <code>\"YYYY-MM-DD\"</code> of consecutive calendar days, and other columns corresponding to values on those days</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             timeseries_df: Optional[dict] = None):\n    \"\"\"\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            has a \"date\" column with strings in format `\"YYYY-MM-DD\"`\n            of consecutive calendar days, and other columns\n            corresponding to values on those days\n    \"\"\"\n\n    super().__init__(init_val)\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.Schedule.update_current_val","title":"<code>update_current_val(params: SubpopParams, current_date: datetime.date) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Subpop classes must provide a concrete implementation of updating <code>current_val</code> in-place.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>SubpopParams</code> <p>fixed parameters of subpopulation model.</p> required <code>current_date</code> <code>date</code> <p>real-world date corresponding to model's current simulation day.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self,\n                       params: SubpopParams,\n                       current_date: datetime.date) -&gt; None:\n    \"\"\"\n    Subpop classes must provide a concrete implementation of\n    updating `current_val` in-place.\n\n    Args:\n        params (SubpopParams):\n            fixed parameters of subpopulation model.\n        current_date (date):\n            real-world date corresponding to\n            model's current simulation day.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SimulationSettings","title":"<code>SimulationSettings</code>  <code>dataclass</code>","text":"<p>Stores simulation settings.</p> <p>Attributes:</p> Name Type Description <code>timesteps_per_day</code> <code>int</code> <p>number of discretized timesteps within a simulation day -- more <code>timesteps_per_day</code> mean smaller discretization time intervals, which may cause the model to run slower.</p> <code>transition_type</code> <code>str</code> <p>valid value must be from <code>TransitionTypes</code>, specifying the probability distribution of transitions between compartments.</p> <code>start_real_date</code> <code>date</code> <p>actual date that aligns with the beginning of the simulation</p> <code>save_daily_history</code> <code>bool</code> <p>set to <code>True</code> to save <code>current_val</code> of <code>StateVariable</code> to history after each simulation day -- set to <code>False</code> if want speedier performance.</p> <code>save_transition_variables_history</code> <code>bool</code> <p>set to <code>True</code> to save <code>current_val</code> of <code>TransitionVariable</code> to history after each TIMESTEP -- note that this makes the simulation execution time extremely slow -- set to <code>False</code> if want speedier performance.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass SimulationSettings:\n    \"\"\"\n    Stores simulation settings.\n\n    Attributes:\n        timesteps_per_day (int):\n            number of discretized timesteps within a simulation\n            day -- more `timesteps_per_day` mean smaller discretization\n            time intervals, which may cause the model to run slower.\n        transition_type (str):\n            valid value must be from `TransitionTypes`, specifying\n            the probability distribution of transitions between\n            compartments.\n        start_real_date (datetime.date):\n            actual date that aligns with the beginning of the simulation\n        save_daily_history (bool):\n            set to `True` to save `current_val` of `StateVariable` to history after each\n            simulation day -- set to `False` if want speedier performance.\n        save_transition_variables_history (bool):\n            set to `True` to save `current_val` of `TransitionVariable` to history\n            after each TIMESTEP -- note that this makes the simulation execution time\n            extremely slow -- set to `False` if want speedier performance.\n    \"\"\"\n\n    timesteps_per_day: int = 7\n    transition_type: str = TransitionTypes.BINOM\n    start_real_date: datetime.time = datetime.datetime.strptime(\"2024-10-31\",\n                                                                \"%Y-%m-%d\").date()\n    save_daily_history: bool = True\n    save_transition_variables_history: bool = False\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.StateVariable","title":"<code>StateVariable</code>","text":"<p>Parent class of <code>InteractionTerm</code>, <code>Compartment</code>, <code>EpiMetric</code>, <code>DynamicVal</code>, and <code>Schedule</code> classes. All subclasses have the attributes <code>init_val</code> and <code>current_val</code>.</p> Dimensions <p>A (int):     Number of age groups. R (int):     Number of risk groups.</p> <p>Attributes:</p> Name Type Description <code>init_val</code> <code>np.ndarray of shape (A, R</code> <p>Holds initial value of <code>StateVariable</code> for age-risk groups.</p> <code>current_val</code> <code>np.ndarray of shape (A, R</code> <p>Same size as <code>init_val</code>, holds current value of <code>StateVariable</code> for age-risk groups.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>Each element is an A x R array that holds history of compartment states for age-risk groups -- element t corresponds to previous <code>current_val</code> value at end of simulation day t.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class StateVariable:\n    \"\"\"\n    Parent class of `InteractionTerm`, `Compartment`, `EpiMetric`,\n    `DynamicVal`, and `Schedule` classes. All subclasses have the\n    attributes `init_val` and `current_val`.\n\n    Dimensions:\n        A (int):\n            Number of age groups.\n        R (int):\n            Number of risk groups.\n\n    Attributes:\n        init_val (np.ndarray of shape (A, R)):\n            Holds initial value of `StateVariable` for age-risk groups.\n        current_val (np.ndarray of shape (A, R)):\n            Same size as `init_val`, holds current value of `StateVariable`\n            for age-risk groups.\n        history_vals_list (list[np.ndarray]):\n            Each element is an A x R array that holds\n            history of compartment states for age-risk groups --\n            element t corresponds to previous `current_val` value at\n            end of simulation day t.\n    \"\"\"\n\n    def __init__(self, init_val=None):\n        self._init_val = init_val\n        self.current_val = copy.deepcopy(init_val)\n        self.history_vals_list = []\n\n    @property\n    def init_val(self):\n        return self._init_val\n\n    @init_val.setter\n    def init_val(self, value):\n        \"\"\"\n        We need to use properties/setters because when we change\n        `init_val`, we want `current_val` to be updated too!\n        \"\"\"\n        self._init_val = value\n        self.current_val = copy.deepcopy(value)\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending `current_val` attribute\n        to `history_vals_list` in-place..\n\n        Deep copying is CRUCIAL because `current_val` is a mutable\n        `np.ndarray` -- without deep copying, `history_vals_list` would\n        have the same value for all elements.\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets `current_val` to `init_val` and resets\n        `history_vals_list` attribute to empty list.\n        \"\"\"\n\n        self.current_val = copy.deepcopy(self.init_val)\n        self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.StateVariable.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets <code>current_val</code> to <code>init_val</code> and resets <code>history_vals_list</code> attribute to empty list.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets `current_val` to `init_val` and resets\n    `history_vals_list` attribute to empty list.\n    \"\"\"\n\n    self.current_val = copy.deepcopy(self.init_val)\n    self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.StateVariable.save_history","title":"<code>save_history() -&gt; None</code>","text":"<p>Saves current value to history by appending <code>current_val</code> attribute to <code>history_vals_list</code> in-place..</p> <p>Deep copying is CRUCIAL because <code>current_val</code> is a mutable <code>np.ndarray</code> -- without deep copying, <code>history_vals_list</code> would have the same value for all elements.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending `current_val` attribute\n    to `history_vals_list` in-place..\n\n    Deep copying is CRUCIAL because `current_val` is a mutable\n    `np.ndarray` -- without deep copying, `history_vals_list` would\n    have the same value for all elements.\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel","title":"<code>SubpopModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Contains and manages all necessary components for simulating a compartmental model for a given subpopulation.</p> <p>Each <code>SubpopModel</code> instance includes compartments, epi metrics, dynamic vals, a data container for the current simulation state, transition variables and transition variable groups, epidemiological parameters, simulation experiment simulation settings parameters, and a random number generator.</p> <p>All city-level subpopulation models, regardless of disease type and compartment/transition structure, are instances of this class.</p> <p>When creating an instance, the order of elements does not matter within <code>compartments</code>, <code>epi_metrics</code>, <code>dynamic_vals</code>, <code>transition_variables</code>, and <code>transition_variable_groups</code>. The \"flow\" and \"physics\" information are stored on the objects.</p> <p>Attributes:</p> Name Type Description <code>compartments</code> <code>objdict[str, Compartment]</code> <p>objdict of all the subpop model's <code>Compartment</code> instances.</p> <code>transition_variables</code> <code>objdict[str, TransitionVariable]</code> <p>objdict of all the subpop model's <code>TransitionVariable</code> instances.</p> <code>transition_variable_groups</code> <code>objdict[str, TransitionVariableGroup]</code> <p>objdict of all the subpop model's <code>TransitionVariableGroup</code> instances.</p> <code>epi_metrics</code> <code>objdict[str, EpiMetric]</code> <p>objdict of all the subpop model's <code>EpiMetric</code> instances.</p> <code>dynamic_vals</code> <code>objdict[str, DynamicVal]</code> <p>objdict of all the subpop model's <code>DynamicVal</code> instances.</p> <code>schedules</code> <code>objdict[str, Schedule]</code> <p>objdict of all the subpop model's <code>Schedule</code> instances.</p> <code>current_simulation_day</code> <code>int</code> <p>tracks current simulation day -- incremented by +1 when <code>simulation_settings.timesteps_per_day</code> discretized timesteps have completed.</p> <code>current_real_date</code> <code>date</code> <p>tracks real-world date -- advanced by +1 day when <code>simulation_settings.timesteps_per_day</code> discretized timesteps have completed.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class SubpopModel(ABC):\n    \"\"\"\n    Contains and manages all necessary components for\n    simulating a compartmental model for a given subpopulation.\n\n    Each `SubpopModel` instance includes compartments,\n    epi metrics, dynamic vals, a data container for the current simulation\n    state, transition variables and transition variable groups,\n    epidemiological parameters, simulation experiment simulation settings\n    parameters, and a random number generator.\n\n    All city-level subpopulation models, regardless of disease type and\n    compartment/transition structure, are instances of this class.\n\n    When creating an instance, the order of elements does not matter\n    within `compartments`, `epi_metrics`, `dynamic_vals`,\n    `transition_variables`, and `transition_variable_groups`.\n    The \"flow\" and \"physics\" information are stored on the objects.\n\n    Attributes:\n        compartments (sc.objdict[str, Compartment]):\n            objdict of all the subpop model's `Compartment` instances.\n        transition_variables (sc.objdict[str, TransitionVariable]):\n            objdict of all the subpop model's `TransitionVariable` instances.\n        transition_variable_groups (sc.objdict[str, TransitionVariableGroup]):\n            objdict of all the subpop model's `TransitionVariableGroup` instances.\n        epi_metrics (sc.objdict[str, EpiMetric]):\n            objdict of all the subpop model's `EpiMetric` instances.\n        dynamic_vals (sc.objdict[str, DynamicVal]):\n            objdict of all the subpop model's `DynamicVal` instances.\n        schedules (sc.objdict[str, Schedule]):\n            objdict of all the subpop model's `Schedule` instances.\n        current_simulation_day (int):\n            tracks current simulation day -- incremented by +1\n            when `simulation_settings.timesteps_per_day` discretized timesteps\n            have completed.\n        current_real_date (datetime.date):\n            tracks real-world date -- advanced by +1 day when\n            `simulation_settings.timesteps_per_day` discretized timesteps\n            have completed.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 state: SubpopState,\n                 params: SubpopParams,\n                 simulation_settings: SimulationSettings,\n                 RNG: np.random.Generator,\n                 name: str,\n                 metapop_model: MetapopModel = None):\n\n        \"\"\"\n        Params:\n            state (SubpopState):\n                holds current values of `SubpopModel`'s state variables.\n            params (SubpopParams):\n                data container for the model's epidemiological parameters,\n                such as the \"Greek letters\" characterizing sojourn times\n                in compartments.\n            simulation_settings (SimulationSettings):\n                data container for the model's simulation settings.\n            RNG (np.random.Generator):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            name (str):\n                unique identifier of `SubpopModel`.\n            metapop_model (Optional[MetapopModel]):\n                if not `None`, is the `MetapopModel` instance\n                associated with this `SubpopModel`.\n        \"\"\"\n\n        self.state = copy.deepcopy(state)\n        self.params = copy.deepcopy(params)\n        self.simulation_settings = copy.deepcopy(simulation_settings)\n\n        self.RNG = RNG\n\n        self.current_simulation_day = 0\n        self.start_real_date = self.get_start_real_date()\n        self.current_real_date = self.start_real_date\n\n        self.metapop_model = metapop_model\n        self.name = name\n\n        self.schedules = self.create_schedules()\n        self.compartments = self.create_compartments()\n        self.transition_variables = self.create_transition_variables()\n        self.transition_variable_groups = self.create_transition_variable_groups()\n        self.epi_metrics = self.create_epi_metrics()\n        self.dynamic_vals = self.create_dynamic_vals()\n\n        self.all_state_variables = {**self.compartments,\n                                    **self.epi_metrics,\n                                    **self.dynamic_vals,\n                                    **self.schedules}\n\n        # The model's state also has access to the model's\n        #   compartments, epi_metrics, dynamic_vals, and schedules --\n        #   so that state can easily retrieve each object's\n        #   current_val and store it\n        self.state.compartments = self.compartments\n        self.state.epi_metrics = self.epi_metrics\n        self.state.dynamic_vals = self.dynamic_vals\n        self.state.schedules = self.schedules\n\n        self.params = updated_dataclass(self.params, {\"total_pop_age_risk\": self.compute_total_pop_age_risk()})\n\n    def compute_total_pop_age_risk(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            (np.ndarray of shape (A, R))\n                A x R array, where A is the number of age groups\n                and R is the number of risk groups, corresponding to\n                total population for that age-risk group (summed\n                over all compartments in the subpop model).\n        \"\"\"\n\n        total_pop_age_risk = np.zeros((self.params.num_age_groups,\n                                       self.params.num_risk_groups))\n\n        # At initialization (before simulation is run), each\n        #   compartment's current val is equivalent to the initial val\n        #   specified in the state variables' init val JSON.\n        for compartment in self.compartments.values():\n            total_pop_age_risk += compartment.current_val\n\n        return total_pop_age_risk\n\n    def get_start_real_date(self):\n        \"\"\"\n        Fetches `start_real_date` from `simulation_settings` -- converts to\n            proper datetime.date format if originally given as\n            string.\n\n        Returns:\n            start_real_date (datetime.date):\n                real-world date that corresponds to start of\n                simulation.\n        \"\"\"\n\n        start_real_date = self.simulation_settings.start_real_date\n\n        if not isinstance(start_real_date, datetime.date):\n            try:\n                start_real_date = \\\n                    datetime.datetime.strptime(start_real_date, \"%Y-%m-%d\").date()\n            except ValueError:\n                print(\"Error: The date format should be YYYY-MM-DD.\")\n\n        return start_real_date\n\n    @abstractmethod\n    def create_compartments(self) -&gt; sc.objdict[str, Compartment]:\n        \"\"\"\n        Create the epidemiological compartments used in the model.\n        Subclasses **must override** this method to provide model-specific\n        transitions.\n\n        Returns:\n            (sc.objdict[str, Compartment]):\n                Dictionary mapping compartment names to `Compartment` objects.\n        \"\"\"\n\n        return sc.objdict()\n\n    @abstractmethod\n    def create_transition_variables(self) -&gt; sc.objdict[str, TransitionVariable]:\n        \"\"\"\n        Create the transition variables specifying how individuals transition\n        between epidemiological compartments in the model. Subclasses\n        **must override** this method to provide model-specific transitions.\n\n        See `__init__` method -- this method is called after `compartments`\n        is assigned via `create_compartments()`, so it can reference the instance's\n        compartments.\n\n        Returns:\n            (sc.objdict[str, TransitionVariable]):\n                Dictionary mapping names to `TransitionVariable` objects.\n        \"\"\"\n\n        return sc.objdict()\n\n    def create_transition_variable_groups(self) -&gt; sc.objdict[str, TransitionVariableGroup]:\n        \"\"\"\n        Create the joint transition variables specifying how transitioning\n        from compartments with multiple outflows is handled. Subclasses\n        can **optionally** override this method to provide model-specific transitions.\n\n        See `__init__` method -- this method is called after `compartments`\n        is assigned via `create_compartments()` and `transition_variables` is\n        assigned via `create_transition_variables()`, so it can reference the instance's\n        compartments and transition variables.\n\n        Returns:\n            (sc.objdict[str, TransitionVariableGroup]):\n                Dictionary mapping names to `TransitionVariableGroup` objects.\n                Default is empty `objdict`.\n        \"\"\"\n\n        return sc.objdict()\n\n    def create_epi_metrics(self) -&gt; sc.objdict[str, EpiMetric]:\n        \"\"\"\n        Create the epidemiological metrics that track deterministic functions of\n        compartments' current values. Subclasses can **optionally** override this method\n        to provide model-specific transitions.\n\n        See `__init__` method -- this method is called after `transition_variables` is\n        assigned via `create_transition_variables()`, so it can reference the instance's\n        transition variables.\n\n        Returns:\n            (sc.objdict[str, EpiMetric]):\n                Dictionary mapping names to `EpiMetric` objects. Default is empty `objdict`.\n        \"\"\"\n\n        return sc.objdict()\n\n    def create_dynamic_vals(self) -&gt; sc.objdict[str, DynamicVal]:\n        \"\"\"\n        Create dynamic values that change depending on the simulation state.\n        Subclasses can **optionally** override this method to provide model-specific transitions.\n\n        Returns:\n            (sc.objdict[str, DynamicVal]):\n                Dictionary mapping names to `DynamicVal` objects. Default is empty `objdict`.\n        \"\"\"\n\n        return sc.objdict()\n\n    def create_schedules(self) -&gt; sc.objdict[str, Schedule]:\n        \"\"\"\n        Create schedules that are deterministic functions of the real-world simulation date.\n        Subclasses can **optionally** override this method to provide model-specific transitions.\n\n        Returns:\n            (sc.objdict[str, Schedule]):\n                Dictionary mapping names to `Schedule` objects. Default is empty `objdict`.\n        \"\"\"\n\n        return sc.objdict()\n\n    def modify_random_seed(self, new_seed_number) -&gt; None:\n        \"\"\"\n        Modifies model's `RNG` attribute in-place to new generator\n        seeded at `new_seed_number`.\n\n        Args:\n            new_seed_number (int):\n                used to re-seed model's random number generator.\n        \"\"\"\n\n        self._bit_generator = np.random.MT19937(seed=new_seed_number)\n        self.RNG = np.random.Generator(self._bit_generator)\n\n    def simulate_until_day(self,\n                           simulation_end_day: int) -&gt; None:\n        \"\"\"\n        Advance simulation model time until `simulation_end_day`.\n\n        Advance time by iterating through simulation days,\n        which are simulated by iterating through discretized\n        timesteps.\n\n        Save daily simulation data as history on each `Compartment`\n        instance.\n\n        Args:\n            simulation_end_day (positive int):\n                stop simulation at `simulation_end_day` (i.e. exclusive,\n                simulate up to but not including `simulation_end_day`).\n        \"\"\"\n\n        if self.current_simulation_day &gt; simulation_end_day:\n            raise SubpopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                   f\"exceeds last simulation day ({simulation_end_day}).\")\n\n        save_daily_history = self.simulation_settings.save_daily_history\n        timesteps_per_day = self.simulation_settings.timesteps_per_day\n\n        # Adding this in case the user manually changes the initial\n        #   value or current value of any state variable --\n        #   otherwise, the state will not get updated\n        self.state.sync_to_current_vals(self.all_state_variables)\n\n        # simulation_end_day is exclusive endpoint\n        while self.current_simulation_day &lt; simulation_end_day:\n\n            self.prepare_daily_state()\n\n            self._simulate_timesteps(timesteps_per_day)\n\n            if save_daily_history:\n                self.save_daily_history()\n\n            self.increment_simulation_day()\n\n    def _simulate_timesteps(self,\n                            num_timesteps: int) -&gt; None:\n        \"\"\"\n        Subroutine for `simulate_until_day`.\n\n        Iterates through discretized timesteps to simulate next\n        simulation day. Granularity of discretization is given by\n        attribute `simulation_settings.timesteps_per_day`.\n\n        Properly scales transition variable realizations and changes\n        in dynamic vals by specified timesteps per day.\n\n        Args:\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n        \"\"\"\n\n        for timestep in range(num_timesteps):\n\n            self.update_transition_rates()\n\n            self.sample_transitions()\n\n            self.update_epi_metrics()\n\n            self.update_compartments()\n\n            self.state.sync_to_current_vals(self.epi_metrics)\n            self.state.sync_to_current_vals(self.compartments)\n\n    def prepare_daily_state(self) -&gt; None:\n        \"\"\"\n        At beginning of each day, update current value of\n        interaction terms, schedules, dynamic values --\n        note that these are only updated once a day, not\n        for every discretized timestep.\n        \"\"\"\n\n        subpop_state = self.state\n        subpop_params = self.params\n        current_real_date = self.current_real_date\n\n        # Important note: this order of updating is important,\n        #   because schedules do not depend on other state variables,\n        #   but dynamic vals may depend on schedules\n        # Interaction terms may depend on both schedules\n        #   and dynamic vals.\n\n        schedules = self.schedules\n        dynamic_vals = self.dynamic_vals\n\n        # Update schedules for current day\n        for schedule in schedules.values():\n            schedule.update_current_val(subpop_params,\n                                        current_real_date)\n\n        self.state.sync_to_current_vals(schedules)\n\n        # Update dynamic values for current day\n        for dval in dynamic_vals.values():\n            if dval.is_enabled:\n                dval.update_current_val(subpop_state, subpop_params)\n\n        self.state.sync_to_current_vals(dynamic_vals)\n\n    def update_epi_metrics(self) -&gt; None:\n        \"\"\"\n        Update current value attribute on each associated\n            `EpiMetric` instance.\n        \"\"\"\n\n        state = self.state\n        params = self.params\n        timesteps_per_day = self.simulation_settings.timesteps_per_day\n\n        for metric in self.epi_metrics.values():\n            metric.change_in_current_val = \\\n                metric.get_change_in_current_val(state,\n                                                 params,\n                                                 timesteps_per_day)\n            metric.update_current_val()\n\n    def update_transition_rates(self) -&gt; None:\n        \"\"\"\n        Compute current transition rates for each transition variable,\n            and store this updated value on each variable's\n            current_rate attribute.\n        \"\"\"\n\n        state = self.state\n        params = self.params\n\n        for tvar in self.transition_variables.values():\n            tvar.current_rate = tvar.get_current_rate(state, params)\n\n    def sample_transitions(self) -&gt; None:\n        \"\"\"\n        For each transition variable, sample a random realization\n            using its current rate. Handle jointly distributed transition\n            variables first (using `TransitionVariableGroup` logic), then\n            handle marginally distributed transition variables.\n            Use `SubpopModel`'s `RNG` to generate random variables.\n        \"\"\"\n\n        RNG = self.RNG\n        timesteps_per_day = self.simulation_settings.timesteps_per_day\n        save_transition_variables_history = self.simulation_settings.save_transition_variables_history\n\n        # Obtain transition variable realizations for jointly distributed transition variables\n        #   (i.e. when there are multiple transition variable outflows from an epi compartment)\n        for tvargroup in self.transition_variable_groups.values():\n            tvargroup.current_vals_list = tvargroup.get_joint_realization(RNG,\n                                                                          timesteps_per_day)\n            tvargroup.update_transition_variable_realizations()\n\n        # Obtain transition variable realizations for marginally distributed transition variables\n        #   (i.e. when there is only one transition variable outflow from an epi compartment)\n        # If transition variable is jointly distributed, then its realization has already\n        #   been computed by its transition variable group container previously,\n        #   so skip the marginal computation\n        for tvar in self.transition_variables.values():\n            if not tvar.is_jointly_distributed:\n                tvar.current_val = tvar.get_realization(RNG, timesteps_per_day)\n\n        if save_transition_variables_history:\n            for tvar in self.transition_variables.values():\n                tvar.save_history()\n\n    def update_compartments(self) -&gt; None:\n        \"\"\"\n        Update current value of each `Compartment`, by\n            looping through all `TransitionVariable` instances\n            and subtracting/adding their current values\n            from origin/destination compartments respectively.\n        \"\"\"\n\n        for tvar in self.transition_variables.values():\n            tvar.update_origin_outflow()\n            tvar.update_destination_inflow()\n\n        for compartment in self.compartments.values():\n            compartment.update_current_val()\n\n            # By construction (using binomial/multinomial with or without taylor expansion),\n            #   more individuals cannot leave the compartment than are in the compartment\n            # However, for Poisson any for ANY deterministic version, it is possible\n            #   to have more individuals leaving the compartment than are in the compartment,\n            #   and hence negative-valued compartments\n            # We use this function to fix this, and also use a differentiable torch\n            #   function to be consistent with the torch implementation (this still\n            #   allows us to take derivatives in the torch implementation)\n            # The syntax is janky here -- we want everything as an array, but\n            #   we need to pass a tensor to the torch functional\n            if \"deterministic\" in self.simulation_settings.transition_type:\n                compartment.current_val = \\\n                        np.array(torch.nn.functional.softplus(torch.tensor(compartment.current_val)))\n\n            # After updating the compartment's current value,\n            #   reset its inflow and outflow attributes, to\n            #   prepare for the next iteration.\n            compartment.reset_inflow()\n            compartment.reset_outflow()\n\n    def increment_simulation_day(self) -&gt; None:\n        \"\"\"\n        Move day counters to next simulation day, both\n            for integer simulation day and real date.\n        \"\"\"\n\n        self.current_simulation_day += 1\n        self.current_real_date += datetime.timedelta(days=1)\n\n    def save_daily_history(self) -&gt; None:\n        \"\"\"\n        Update history at end of each day, not at end of every\n           discretization timestep, to be efficient.\n        Update history of state variables other than `Schedule`\n           instances -- schedules do not have history.\n        \"\"\"\n        for svar in self.compartments.values() + \\\n                    self.epi_metrics.values() + \\\n                    self.dynamic_vals.values():\n            svar.save_history()\n\n    def reset_simulation(self) -&gt; None:\n        \"\"\"\n        Reset simulation in-place. Subsequent method calls of\n        `simulate_until_day` start from day 0, with original\n        day 0 state.\n\n        Returns `current_simulation_day` to 0.\n        Restores state values to initial values.\n        Clears history on model's state variables.\n        Resets transition variables' `current_val` attribute to 0.\n\n        WARNING:\n            DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n            ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n            WHERE IT LEFT OFF.\n\n        Use method `modify_random_seed` to reset model's `RNG` to its\n        initial starting seed.\n        \"\"\"\n\n        self.current_simulation_day = 0\n        self.current_real_date = self.start_real_date\n\n        # AGAIN, MUST BE CAREFUL ABOUT MUTABLE NUMPY ARRAYS -- MUST USE DEEP COPY\n        for svar in self.all_state_variables.values():\n            setattr(svar, \"current_val\", copy.deepcopy(svar.init_val))\n\n        self.state.sync_to_current_vals(self.all_state_variables)\n\n        for svar in self.all_state_variables.values():\n            svar.reset()\n\n        for tvar in self.transition_variables.values():\n            tvar.reset()\n\n        for tvargroup in self.transition_variable_groups.values():\n            tvargroup.current_vals_list = []\n\n    def find_name_by_compartment(self,\n                                 target_compartment: Compartment) -&gt; str:\n        \"\"\"\n        Given `Compartment`, returns name of that `Compartment`.\n\n        Args:\n            target_compartment (Compartment):\n                Compartment object with a name to look up\n\n        Returns:\n            (str):\n                Compartment name, given by the key to look\n                it up in the `SubpopModel`'s compartments objdict\n        \"\"\"\n\n        for name, compartment in self.compartments.items():\n            if compartment == target_compartment:\n                return name\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.__init__","title":"<code>__init__(state: SubpopState, params: SubpopParams, simulation_settings: SimulationSettings, RNG: np.random.Generator, name: str, metapop_model: MetapopModel = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds current values of <code>SubpopModel</code>'s state variables.</p> required <code>params</code> <code>SubpopParams</code> <p>data container for the model's epidemiological parameters, such as the \"Greek letters\" characterizing sojourn times in compartments.</p> required <code>simulation_settings</code> <code>SimulationSettings</code> <p>data container for the model's simulation settings.</p> required <code>RNG</code> <code>Generator</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>name</code> <code>str</code> <p>unique identifier of <code>SubpopModel</code>.</p> required <code>metapop_model</code> <code>Optional[MetapopModel]</code> <p>if not <code>None</code>, is the <code>MetapopModel</code> instance associated with this <code>SubpopModel</code>.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             state: SubpopState,\n             params: SubpopParams,\n             simulation_settings: SimulationSettings,\n             RNG: np.random.Generator,\n             name: str,\n             metapop_model: MetapopModel = None):\n\n    \"\"\"\n    Params:\n        state (SubpopState):\n            holds current values of `SubpopModel`'s state variables.\n        params (SubpopParams):\n            data container for the model's epidemiological parameters,\n            such as the \"Greek letters\" characterizing sojourn times\n            in compartments.\n        simulation_settings (SimulationSettings):\n            data container for the model's simulation settings.\n        RNG (np.random.Generator):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        name (str):\n            unique identifier of `SubpopModel`.\n        metapop_model (Optional[MetapopModel]):\n            if not `None`, is the `MetapopModel` instance\n            associated with this `SubpopModel`.\n    \"\"\"\n\n    self.state = copy.deepcopy(state)\n    self.params = copy.deepcopy(params)\n    self.simulation_settings = copy.deepcopy(simulation_settings)\n\n    self.RNG = RNG\n\n    self.current_simulation_day = 0\n    self.start_real_date = self.get_start_real_date()\n    self.current_real_date = self.start_real_date\n\n    self.metapop_model = metapop_model\n    self.name = name\n\n    self.schedules = self.create_schedules()\n    self.compartments = self.create_compartments()\n    self.transition_variables = self.create_transition_variables()\n    self.transition_variable_groups = self.create_transition_variable_groups()\n    self.epi_metrics = self.create_epi_metrics()\n    self.dynamic_vals = self.create_dynamic_vals()\n\n    self.all_state_variables = {**self.compartments,\n                                **self.epi_metrics,\n                                **self.dynamic_vals,\n                                **self.schedules}\n\n    # The model's state also has access to the model's\n    #   compartments, epi_metrics, dynamic_vals, and schedules --\n    #   so that state can easily retrieve each object's\n    #   current_val and store it\n    self.state.compartments = self.compartments\n    self.state.epi_metrics = self.epi_metrics\n    self.state.dynamic_vals = self.dynamic_vals\n    self.state.schedules = self.schedules\n\n    self.params = updated_dataclass(self.params, {\"total_pop_age_risk\": self.compute_total_pop_age_risk()})\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.compute_total_pop_age_risk","title":"<code>compute_total_pop_age_risk() -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) A x R array, where A is the number of age groups and R is the number of risk groups, corresponding to total population for that age-risk group (summed over all compartments in the subpop model).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def compute_total_pop_age_risk(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        (np.ndarray of shape (A, R))\n            A x R array, where A is the number of age groups\n            and R is the number of risk groups, corresponding to\n            total population for that age-risk group (summed\n            over all compartments in the subpop model).\n    \"\"\"\n\n    total_pop_age_risk = np.zeros((self.params.num_age_groups,\n                                   self.params.num_risk_groups))\n\n    # At initialization (before simulation is run), each\n    #   compartment's current val is equivalent to the initial val\n    #   specified in the state variables' init val JSON.\n    for compartment in self.compartments.values():\n        total_pop_age_risk += compartment.current_val\n\n    return total_pop_age_risk\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_compartments","title":"<code>create_compartments() -&gt; sc.objdict[str, Compartment]</code>  <code>abstractmethod</code>","text":"<p>Create the epidemiological compartments used in the model. Subclasses must override this method to provide model-specific transitions.</p> <p>Returns:</p> Type Description <code>objdict[str, Compartment]</code> <p>Dictionary mapping compartment names to <code>Compartment</code> objects.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef create_compartments(self) -&gt; sc.objdict[str, Compartment]:\n    \"\"\"\n    Create the epidemiological compartments used in the model.\n    Subclasses **must override** this method to provide model-specific\n    transitions.\n\n    Returns:\n        (sc.objdict[str, Compartment]):\n            Dictionary mapping compartment names to `Compartment` objects.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_dynamic_vals","title":"<code>create_dynamic_vals() -&gt; sc.objdict[str, DynamicVal]</code>","text":"<p>Create dynamic values that change depending on the simulation state. Subclasses can optionally override this method to provide model-specific transitions.</p> <p>Returns:</p> Type Description <code>objdict[str, DynamicVal]</code> <p>Dictionary mapping names to <code>DynamicVal</code> objects. Default is empty <code>objdict</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def create_dynamic_vals(self) -&gt; sc.objdict[str, DynamicVal]:\n    \"\"\"\n    Create dynamic values that change depending on the simulation state.\n    Subclasses can **optionally** override this method to provide model-specific transitions.\n\n    Returns:\n        (sc.objdict[str, DynamicVal]):\n            Dictionary mapping names to `DynamicVal` objects. Default is empty `objdict`.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_epi_metrics","title":"<code>create_epi_metrics() -&gt; sc.objdict[str, EpiMetric]</code>","text":"<p>Create the epidemiological metrics that track deterministic functions of compartments' current values. Subclasses can optionally override this method to provide model-specific transitions.</p> <p>See <code>__init__</code> method -- this method is called after <code>transition_variables</code> is assigned via <code>create_transition_variables()</code>, so it can reference the instance's transition variables.</p> <p>Returns:</p> Type Description <code>objdict[str, EpiMetric]</code> <p>Dictionary mapping names to <code>EpiMetric</code> objects. Default is empty <code>objdict</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def create_epi_metrics(self) -&gt; sc.objdict[str, EpiMetric]:\n    \"\"\"\n    Create the epidemiological metrics that track deterministic functions of\n    compartments' current values. Subclasses can **optionally** override this method\n    to provide model-specific transitions.\n\n    See `__init__` method -- this method is called after `transition_variables` is\n    assigned via `create_transition_variables()`, so it can reference the instance's\n    transition variables.\n\n    Returns:\n        (sc.objdict[str, EpiMetric]):\n            Dictionary mapping names to `EpiMetric` objects. Default is empty `objdict`.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_schedules","title":"<code>create_schedules() -&gt; sc.objdict[str, Schedule]</code>","text":"<p>Create schedules that are deterministic functions of the real-world simulation date. Subclasses can optionally override this method to provide model-specific transitions.</p> <p>Returns:</p> Type Description <code>objdict[str, Schedule]</code> <p>Dictionary mapping names to <code>Schedule</code> objects. Default is empty <code>objdict</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def create_schedules(self) -&gt; sc.objdict[str, Schedule]:\n    \"\"\"\n    Create schedules that are deterministic functions of the real-world simulation date.\n    Subclasses can **optionally** override this method to provide model-specific transitions.\n\n    Returns:\n        (sc.objdict[str, Schedule]):\n            Dictionary mapping names to `Schedule` objects. Default is empty `objdict`.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_transition_variable_groups","title":"<code>create_transition_variable_groups() -&gt; sc.objdict[str, TransitionVariableGroup]</code>","text":"<p>Create the joint transition variables specifying how transitioning from compartments with multiple outflows is handled. Subclasses can optionally override this method to provide model-specific transitions.</p> <p>See <code>__init__</code> method -- this method is called after <code>compartments</code> is assigned via <code>create_compartments()</code> and <code>transition_variables</code> is assigned via <code>create_transition_variables()</code>, so it can reference the instance's compartments and transition variables.</p> <p>Returns:</p> Type Description <code>objdict[str, TransitionVariableGroup]</code> <p>Dictionary mapping names to <code>TransitionVariableGroup</code> objects. Default is empty <code>objdict</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def create_transition_variable_groups(self) -&gt; sc.objdict[str, TransitionVariableGroup]:\n    \"\"\"\n    Create the joint transition variables specifying how transitioning\n    from compartments with multiple outflows is handled. Subclasses\n    can **optionally** override this method to provide model-specific transitions.\n\n    See `__init__` method -- this method is called after `compartments`\n    is assigned via `create_compartments()` and `transition_variables` is\n    assigned via `create_transition_variables()`, so it can reference the instance's\n    compartments and transition variables.\n\n    Returns:\n        (sc.objdict[str, TransitionVariableGroup]):\n            Dictionary mapping names to `TransitionVariableGroup` objects.\n            Default is empty `objdict`.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.create_transition_variables","title":"<code>create_transition_variables() -&gt; sc.objdict[str, TransitionVariable]</code>  <code>abstractmethod</code>","text":"<p>Create the transition variables specifying how individuals transition between epidemiological compartments in the model. Subclasses must override this method to provide model-specific transitions.</p> <p>See <code>__init__</code> method -- this method is called after <code>compartments</code> is assigned via <code>create_compartments()</code>, so it can reference the instance's compartments.</p> <p>Returns:</p> Type Description <code>objdict[str, TransitionVariable]</code> <p>Dictionary mapping names to <code>TransitionVariable</code> objects.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef create_transition_variables(self) -&gt; sc.objdict[str, TransitionVariable]:\n    \"\"\"\n    Create the transition variables specifying how individuals transition\n    between epidemiological compartments in the model. Subclasses\n    **must override** this method to provide model-specific transitions.\n\n    See `__init__` method -- this method is called after `compartments`\n    is assigned via `create_compartments()`, so it can reference the instance's\n    compartments.\n\n    Returns:\n        (sc.objdict[str, TransitionVariable]):\n            Dictionary mapping names to `TransitionVariable` objects.\n    \"\"\"\n\n    return sc.objdict()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.find_name_by_compartment","title":"<code>find_name_by_compartment(target_compartment: Compartment) -&gt; str</code>","text":"<p>Given <code>Compartment</code>, returns name of that <code>Compartment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target_compartment</code> <code>Compartment</code> <p>Compartment object with a name to look up</p> required <p>Returns:</p> Type Description <code>str</code> <p>Compartment name, given by the key to look it up in the <code>SubpopModel</code>'s compartments objdict</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def find_name_by_compartment(self,\n                             target_compartment: Compartment) -&gt; str:\n    \"\"\"\n    Given `Compartment`, returns name of that `Compartment`.\n\n    Args:\n        target_compartment (Compartment):\n            Compartment object with a name to look up\n\n    Returns:\n        (str):\n            Compartment name, given by the key to look\n            it up in the `SubpopModel`'s compartments objdict\n    \"\"\"\n\n    for name, compartment in self.compartments.items():\n        if compartment == target_compartment:\n            return name\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.get_start_real_date","title":"<code>get_start_real_date()</code>","text":"<p>Fetches <code>start_real_date</code> from <code>simulation_settings</code> -- converts to     proper datetime.date format if originally given as     string.</p> <p>Returns:</p> Name Type Description <code>start_real_date</code> <code>date</code> <p>real-world date that corresponds to start of simulation.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_start_real_date(self):\n    \"\"\"\n    Fetches `start_real_date` from `simulation_settings` -- converts to\n        proper datetime.date format if originally given as\n        string.\n\n    Returns:\n        start_real_date (datetime.date):\n            real-world date that corresponds to start of\n            simulation.\n    \"\"\"\n\n    start_real_date = self.simulation_settings.start_real_date\n\n    if not isinstance(start_real_date, datetime.date):\n        try:\n            start_real_date = \\\n                datetime.datetime.strptime(start_real_date, \"%Y-%m-%d\").date()\n        except ValueError:\n            print(\"Error: The date format should be YYYY-MM-DD.\")\n\n    return start_real_date\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.increment_simulation_day","title":"<code>increment_simulation_day() -&gt; None</code>","text":"<p>Move day counters to next simulation day, both     for integer simulation day and real date.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def increment_simulation_day(self) -&gt; None:\n    \"\"\"\n    Move day counters to next simulation day, both\n        for integer simulation day and real date.\n    \"\"\"\n\n    self.current_simulation_day += 1\n    self.current_real_date += datetime.timedelta(days=1)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.modify_random_seed","title":"<code>modify_random_seed(new_seed_number) -&gt; None</code>","text":"<p>Modifies model's <code>RNG</code> attribute in-place to new generator seeded at <code>new_seed_number</code>.</p> <p>Parameters:</p> Name Type Description Default <code>new_seed_number</code> <code>int</code> <p>used to re-seed model's random number generator.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def modify_random_seed(self, new_seed_number) -&gt; None:\n    \"\"\"\n    Modifies model's `RNG` attribute in-place to new generator\n    seeded at `new_seed_number`.\n\n    Args:\n        new_seed_number (int):\n            used to re-seed model's random number generator.\n    \"\"\"\n\n    self._bit_generator = np.random.MT19937(seed=new_seed_number)\n    self.RNG = np.random.Generator(self._bit_generator)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.prepare_daily_state","title":"<code>prepare_daily_state() -&gt; None</code>","text":"<p>At beginning of each day, update current value of interaction terms, schedules, dynamic values -- note that these are only updated once a day, not for every discretized timestep.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def prepare_daily_state(self) -&gt; None:\n    \"\"\"\n    At beginning of each day, update current value of\n    interaction terms, schedules, dynamic values --\n    note that these are only updated once a day, not\n    for every discretized timestep.\n    \"\"\"\n\n    subpop_state = self.state\n    subpop_params = self.params\n    current_real_date = self.current_real_date\n\n    # Important note: this order of updating is important,\n    #   because schedules do not depend on other state variables,\n    #   but dynamic vals may depend on schedules\n    # Interaction terms may depend on both schedules\n    #   and dynamic vals.\n\n    schedules = self.schedules\n    dynamic_vals = self.dynamic_vals\n\n    # Update schedules for current day\n    for schedule in schedules.values():\n        schedule.update_current_val(subpop_params,\n                                    current_real_date)\n\n    self.state.sync_to_current_vals(schedules)\n\n    # Update dynamic values for current day\n    for dval in dynamic_vals.values():\n        if dval.is_enabled:\n            dval.update_current_val(subpop_state, subpop_params)\n\n    self.state.sync_to_current_vals(dynamic_vals)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.reset_simulation","title":"<code>reset_simulation() -&gt; None</code>","text":"<p>Reset simulation in-place. Subsequent method calls of <code>simulate_until_day</code> start from day 0, with original day 0 state.</p> <p>Returns <code>current_simulation_day</code> to 0. Restores state values to initial values. Clears history on model's state variables. Resets transition variables' <code>current_val</code> attribute to 0.</p> WARNING <p>DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE WHERE IT LEFT OFF.</p> <p>Use method <code>modify_random_seed</code> to reset model's <code>RNG</code> to its initial starting seed.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset_simulation(self) -&gt; None:\n    \"\"\"\n    Reset simulation in-place. Subsequent method calls of\n    `simulate_until_day` start from day 0, with original\n    day 0 state.\n\n    Returns `current_simulation_day` to 0.\n    Restores state values to initial values.\n    Clears history on model's state variables.\n    Resets transition variables' `current_val` attribute to 0.\n\n    WARNING:\n        DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n        ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n        WHERE IT LEFT OFF.\n\n    Use method `modify_random_seed` to reset model's `RNG` to its\n    initial starting seed.\n    \"\"\"\n\n    self.current_simulation_day = 0\n    self.current_real_date = self.start_real_date\n\n    # AGAIN, MUST BE CAREFUL ABOUT MUTABLE NUMPY ARRAYS -- MUST USE DEEP COPY\n    for svar in self.all_state_variables.values():\n        setattr(svar, \"current_val\", copy.deepcopy(svar.init_val))\n\n    self.state.sync_to_current_vals(self.all_state_variables)\n\n    for svar in self.all_state_variables.values():\n        svar.reset()\n\n    for tvar in self.transition_variables.values():\n        tvar.reset()\n\n    for tvargroup in self.transition_variable_groups.values():\n        tvargroup.current_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.sample_transitions","title":"<code>sample_transitions() -&gt; None</code>","text":"<p>For each transition variable, sample a random realization     using its current rate. Handle jointly distributed transition     variables first (using <code>TransitionVariableGroup</code> logic), then     handle marginally distributed transition variables.     Use <code>SubpopModel</code>'s <code>RNG</code> to generate random variables.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def sample_transitions(self) -&gt; None:\n    \"\"\"\n    For each transition variable, sample a random realization\n        using its current rate. Handle jointly distributed transition\n        variables first (using `TransitionVariableGroup` logic), then\n        handle marginally distributed transition variables.\n        Use `SubpopModel`'s `RNG` to generate random variables.\n    \"\"\"\n\n    RNG = self.RNG\n    timesteps_per_day = self.simulation_settings.timesteps_per_day\n    save_transition_variables_history = self.simulation_settings.save_transition_variables_history\n\n    # Obtain transition variable realizations for jointly distributed transition variables\n    #   (i.e. when there are multiple transition variable outflows from an epi compartment)\n    for tvargroup in self.transition_variable_groups.values():\n        tvargroup.current_vals_list = tvargroup.get_joint_realization(RNG,\n                                                                      timesteps_per_day)\n        tvargroup.update_transition_variable_realizations()\n\n    # Obtain transition variable realizations for marginally distributed transition variables\n    #   (i.e. when there is only one transition variable outflow from an epi compartment)\n    # If transition variable is jointly distributed, then its realization has already\n    #   been computed by its transition variable group container previously,\n    #   so skip the marginal computation\n    for tvar in self.transition_variables.values():\n        if not tvar.is_jointly_distributed:\n            tvar.current_val = tvar.get_realization(RNG, timesteps_per_day)\n\n    if save_transition_variables_history:\n        for tvar in self.transition_variables.values():\n            tvar.save_history()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.save_daily_history","title":"<code>save_daily_history() -&gt; None</code>","text":"<p>Update history at end of each day, not at end of every    discretization timestep, to be efficient. Update history of state variables other than <code>Schedule</code>    instances -- schedules do not have history.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def save_daily_history(self) -&gt; None:\n    \"\"\"\n    Update history at end of each day, not at end of every\n       discretization timestep, to be efficient.\n    Update history of state variables other than `Schedule`\n       instances -- schedules do not have history.\n    \"\"\"\n    for svar in self.compartments.values() + \\\n                self.epi_metrics.values() + \\\n                self.dynamic_vals.values():\n        svar.save_history()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.simulate_until_day","title":"<code>simulate_until_day(simulation_end_day: int) -&gt; None</code>","text":"<p>Advance simulation model time until <code>simulation_end_day</code>.</p> <p>Advance time by iterating through simulation days, which are simulated by iterating through discretized timesteps.</p> <p>Save daily simulation data as history on each <code>Compartment</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at <code>simulation_end_day</code> (i.e. exclusive, simulate up to but not including <code>simulation_end_day</code>).</p> required Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def simulate_until_day(self,\n                       simulation_end_day: int) -&gt; None:\n    \"\"\"\n    Advance simulation model time until `simulation_end_day`.\n\n    Advance time by iterating through simulation days,\n    which are simulated by iterating through discretized\n    timesteps.\n\n    Save daily simulation data as history on each `Compartment`\n    instance.\n\n    Args:\n        simulation_end_day (positive int):\n            stop simulation at `simulation_end_day` (i.e. exclusive,\n            simulate up to but not including `simulation_end_day`).\n    \"\"\"\n\n    if self.current_simulation_day &gt; simulation_end_day:\n        raise SubpopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                               f\"exceeds last simulation day ({simulation_end_day}).\")\n\n    save_daily_history = self.simulation_settings.save_daily_history\n    timesteps_per_day = self.simulation_settings.timesteps_per_day\n\n    # Adding this in case the user manually changes the initial\n    #   value or current value of any state variable --\n    #   otherwise, the state will not get updated\n    self.state.sync_to_current_vals(self.all_state_variables)\n\n    # simulation_end_day is exclusive endpoint\n    while self.current_simulation_day &lt; simulation_end_day:\n\n        self.prepare_daily_state()\n\n        self._simulate_timesteps(timesteps_per_day)\n\n        if save_daily_history:\n            self.save_daily_history()\n\n        self.increment_simulation_day()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.update_compartments","title":"<code>update_compartments() -&gt; None</code>","text":"<p>Update current value of each <code>Compartment</code>, by     looping through all <code>TransitionVariable</code> instances     and subtracting/adding their current values     from origin/destination compartments respectively.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_compartments(self) -&gt; None:\n    \"\"\"\n    Update current value of each `Compartment`, by\n        looping through all `TransitionVariable` instances\n        and subtracting/adding their current values\n        from origin/destination compartments respectively.\n    \"\"\"\n\n    for tvar in self.transition_variables.values():\n        tvar.update_origin_outflow()\n        tvar.update_destination_inflow()\n\n    for compartment in self.compartments.values():\n        compartment.update_current_val()\n\n        # By construction (using binomial/multinomial with or without taylor expansion),\n        #   more individuals cannot leave the compartment than are in the compartment\n        # However, for Poisson any for ANY deterministic version, it is possible\n        #   to have more individuals leaving the compartment than are in the compartment,\n        #   and hence negative-valued compartments\n        # We use this function to fix this, and also use a differentiable torch\n        #   function to be consistent with the torch implementation (this still\n        #   allows us to take derivatives in the torch implementation)\n        # The syntax is janky here -- we want everything as an array, but\n        #   we need to pass a tensor to the torch functional\n        if \"deterministic\" in self.simulation_settings.transition_type:\n            compartment.current_val = \\\n                    np.array(torch.nn.functional.softplus(torch.tensor(compartment.current_val)))\n\n        # After updating the compartment's current value,\n        #   reset its inflow and outflow attributes, to\n        #   prepare for the next iteration.\n        compartment.reset_inflow()\n        compartment.reset_outflow()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.update_epi_metrics","title":"<code>update_epi_metrics() -&gt; None</code>","text":"<p>Update current value attribute on each associated     <code>EpiMetric</code> instance.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_epi_metrics(self) -&gt; None:\n    \"\"\"\n    Update current value attribute on each associated\n        `EpiMetric` instance.\n    \"\"\"\n\n    state = self.state\n    params = self.params\n    timesteps_per_day = self.simulation_settings.timesteps_per_day\n\n    for metric in self.epi_metrics.values():\n        metric.change_in_current_val = \\\n            metric.get_change_in_current_val(state,\n                                             params,\n                                             timesteps_per_day)\n        metric.update_current_val()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModel.update_transition_rates","title":"<code>update_transition_rates() -&gt; None</code>","text":"<p>Compute current transition rates for each transition variable,     and store this updated value on each variable's     current_rate attribute.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_transition_rates(self) -&gt; None:\n    \"\"\"\n    Compute current transition rates for each transition variable,\n        and store this updated value on each variable's\n        current_rate attribute.\n    \"\"\"\n\n    state = self.state\n    params = self.params\n\n    for tvar in self.transition_variables.values():\n        tvar.current_rate = tvar.get_current_rate(state, params)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopModelError","title":"<code>SubpopModelError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for subpopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class SubpopModelError(Exception):\n    \"\"\"Custom exceptions for subpopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopParams","title":"<code>SubpopParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Data container for pre-specified and fixed epidemiological parameters in model.</p> <p>Assume that <code>SubpopParams</code> fields are constant or piecewise constant throughout the simulation. For variables that are more complicated and time-dependent, use an <code>EpiMetric</code> instead.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass SubpopParams(ABC):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in model.\n\n    Assume that `SubpopParams` fields are constant or piecewise\n    constant throughout the simulation. For variables that\n    are more complicated and time-dependent, use an `EpiMetric`\n    instead.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopState","title":"<code>SubpopState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Holds current values of <code>SubpopModel</code>'s simulation state.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>@dataclass\nclass SubpopState(ABC):\n    \"\"\"\n    Holds current values of `SubpopModel`'s simulation state.\n    \"\"\"\n\n    def sync_to_current_vals(self, lookup_dict: dict):\n        \"\"\"\n        Updates `SubpopState`'s attributes according to\n        data in `lookup_dict.` Keys of `lookup_dict` must match\n        names of attributes of `SubpopState` instance.\n        \"\"\"\n\n        for name, item in lookup_dict.items():\n            setattr(self, name, item.current_val)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.SubpopState.sync_to_current_vals","title":"<code>sync_to_current_vals(lookup_dict: dict)</code>","text":"<p>Updates <code>SubpopState</code>'s attributes according to data in <code>lookup_dict.</code> Keys of <code>lookup_dict</code> must match names of attributes of <code>SubpopState</code> instance.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>def sync_to_current_vals(self, lookup_dict: dict):\n    \"\"\"\n    Updates `SubpopState`'s attributes according to\n    data in `lookup_dict.` Keys of `lookup_dict` must match\n    names of attributes of `SubpopState` instance.\n    \"\"\"\n\n    for name, item in lookup_dict.items():\n        setattr(self, name, item.current_val)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionTypes","title":"<code>TransitionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Defines available options for <code>transition_type</code> in <code>TransitionVariable</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_data_structures.py</code> <pre><code>class TransitionTypes(str, Enum):\n    \"\"\"\n    Defines available options for `transition_type` in `TransitionVariable`.\n    \"\"\"\n    BINOM = \"binom\"\n    BINOM_DETERMINISTIC = \"binom_deterministic\"\n    BINOM_DETERMINISTIC_NO_ROUND = \"binom_deterministic_no_round\"\n    BINOM_TAYLOR_APPROX = \"binom_taylor_approx\"\n    BINOM_TAYLOR_APPROX_DETERMINISTIC = \"binom_taylor_approx_deterministic\"\n    POISSON = \"poisson\"\n    POISSON_DETERMINISTIC = \"poisson_deterministic\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable","title":"<code>TransitionVariable</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for transition variables in epidemiological model.</p> <p>For example, in an S-I-R model, the new number infected every iteration (the number going from S to I) in an iteration is modeled as a <code>TransitionVariable</code> subclass, with a concrete implementation of the abstract method <code>get_current_rate</code>.</p> <p>When an instance is initialized, its <code>get_realization</code> attribute is dynamically assigned, just like in the case of <code>TransitionVariableGroup</code> instantiation.</p> Dimensions <p>A (int):     Number of age groups. R (int):     Number of risk groups.</p> <p>Attributes:</p> Name Type Description <code>_transition_type</code> <code>str</code> <p>only values defined in <code>TransitionTypes</code> are valid, specifying probability distribution of transitions between compartments.</p> <code>get_current_rate</code> <code>function</code> <p>provides specific implementation for computing current rate as a function of current subpopulation simulation state and epidemiological parameters.</p> <code>current_rate</code> <code>np.ndarray of shape (A, R</code> <p>holds output from <code>get_current_rate</code> method -- used to generate random variable realizations for transitions between compartments.</p> <code>current_val</code> <code>np.ndarray of shape (A, R</code> <p>holds realization of random variable parameterized by <code>current_rate</code>.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of <code>current_val</code>, holds history of transition variable realizations for age-risk groups -- element t corresponds to previous <code>current_val</code> value at end of simulation day t.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class TransitionVariable(ABC):\n    \"\"\"\n    Abstract base class for transition variables in\n    epidemiological model.\n\n    For example, in an S-I-R model, the new number infected\n    every iteration (the number going from S to I) in an iteration\n    is modeled as a `TransitionVariable` subclass, with a concrete\n    implementation of the abstract method `get_current_rate`.\n\n    When an instance is initialized, its `get_realization` attribute\n    is dynamically assigned, just like in the case of\n    `TransitionVariableGroup` instantiation.\n\n    Dimensions:\n        A (int):\n            Number of age groups.\n        R (int):\n            Number of risk groups.\n\n    Attributes:\n        _transition_type (str):\n            only values defined in `TransitionTypes` are valid, specifying\n            probability distribution of transitions between compartments.\n        get_current_rate (function):\n            provides specific implementation for computing current rate\n            as a function of current subpopulation simulation state and\n            epidemiological parameters.\n        current_rate (np.ndarray of shape (A, R)):\n            holds output from `get_current_rate` method -- used to generate\n            random variable realizations for transitions between compartments.\n        current_val (np.ndarray of shape (A, R)):\n            holds realization of random variable parameterized by\n            `current_rate`.\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of `current_val`, holds\n            history of transition variable realizations for age-risk\n            groups -- element t corresponds to previous `current_val`\n            value at end of simulation day t.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin: Compartment,\n                 destination: Compartment,\n                 transition_type: TransitionTypes,\n                 is_jointly_distributed: str = False):\n        \"\"\"\n        Parameters:\n            origin (Compartment):\n                `Compartment` from which `TransitionVariable` exits.\n            destination (Compartment):\n                `Compartment` that the `TransitionVariable` enters.\n            transition_type (TransitionTypes):\n                Specifies probability distribution of transitions between compartments.\n            is_jointly_distributed (bool):\n                Indicates if transition quantity must be jointly computed\n                (i.e. if there are multiple outflows from the origin compartment).\n        \"\"\"\n\n        self.origin = origin\n        self.destination = destination\n\n        # Also see __init__ method in TransitionVariableGroup class.\n        #   The structure is similar.\n        self._transition_type = transition_type\n        self._is_jointly_distributed = is_jointly_distributed\n\n        # Assigns appropriate realization method based on transition type.\n        # If jointly distributed, no single realization function applies.\n        if is_jointly_distributed:\n            self.get_realization = None\n        else:\n            self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_rate = None\n        self.current_val = None\n\n        self.history_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; TransitionTypes:\n        return self._transition_type\n\n    @property\n    def is_jointly_distributed(self) -&gt; bool:\n        return self._is_jointly_distributed\n\n    @abstractmethod\n    def get_current_rate(self,\n                         state: SubpopState,\n                         params: SubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns current rate of transition variable,\n        based on current state of the simulation and epidemiological parameters.\n\n        Args:\n            state (SubpopState):\n                Holds subpopulation simulation state\n                (current values of `StateVariable` instances).\n            params (SubpopParams):\n                Holds values of epidemiological parameters.\n\n        Returns:\n            np.ndarray:\n                Holds age-risk transition rate.\n        \"\"\"\n        pass\n\n    def update_origin_outflow(self) -&gt; None:\n        \"\"\"\n        Adds current realization of `TransitionVariable` to\n            its origin `Compartment`'s current_outflow.\n            Used to compute total number leaving that\n            origin `Compartment`.\n        \"\"\"\n\n        self.origin.current_outflow = self.origin.current_outflow + self.current_val\n\n    def update_destination_inflow(self) -&gt; None:\n        \"\"\"\n        Adds current realization of `TransitionVariable` to\n            its destination `Compartment`'s `current_inflow`.\n            Used to compute total number leaving that\n            destination `Compartment`.\n        \"\"\"\n\n        self.destination.current_inflow = self.destination.current_inflow + self.current_val\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending `current_val`\n        attribute to `history_vals_list` in-place..\n\n        Deep copying is CRUCIAL because `current_val` is a mutable\n        np.ndarray -- without deep copying, `history_vals_list` would\n        have the same value for all elements.\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets `history_vals_list` attribute to empty list.\n        \"\"\"\n\n        self.current_rate = None\n        self.current_val = None\n        self.history_vals_list = []\n\n    def get_realization(self,\n                        RNG: np.random.Generator,\n                        num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Generate a realization of the transition process.\n\n        This method is dynamically assigned to the appropriate transition-specific\n        function (e.g., `get_binom_realization`) depending on the transition type.\n        Provides common interface so realizations can always be obtained via\n        ``get_realization``.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 Used to generate stochastic transitions in the model and control\n                 reproducibility. If deterministic transitions are used, the\n                 RNG is passed for a consistent function interface but the RNG\n                 is not used.\n            num_timesteps (int):\n                Number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            (np.ndarray of shape (A, R)):\n                Number of transitions for age-risk groups.\n        \"\"\"\n\n        pass\n\n    def get_binom_realization(self,\n                              RNG: np.random.Generator,\n                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses `RNG` to generate binomial random variable with\n        number of trials equal to population count in the\n        origin `Compartment` and probability computed from\n        a function of the `TransitionVariable`'s current rate\n        -- see `approx_binom_probability_from_rate` function\n        for details.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Element-wise Binomial distributed transitions for each\n                age-risk group, with the probability parameter generated\n                using a conversion from rates to probabilities.\n        \"\"\"\n\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n\n    def get_binom_taylor_approx_realization(self,\n                                            RNG: np.random.Generator,\n                                            num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses `RNG` to generate binomial random variable with\n            number of trials equal to population count in the\n            origin `Compartment` and probability equal to\n            the `TransitionVariable`'s `current_rate` / `num_timesteps`.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Element-wise Binomial distributed transitions for each\n                age-risk group, with the probability parameter generated\n                using a Taylor approximation.\n        \"\"\"\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=self.current_rate * (1.0 / num_timesteps))\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Generates realizations from a Poisson distribution.\n\n        The rate is computed element-wise from each age-risk group as:\n        (origin compartment population count x `current_rate` / `num_timesteps`)\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Poisson-distributed integers representing number\n                of individuals transitioning in each age-risk group.\n        \"\"\"\n        return RNG.poisson(self.base_count * self.current_rate / float(num_timesteps))\n\n    def get_binom_deterministic_realization(self,\n                                            RNG: np.random.Generator,\n                                            num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of binomial distribution\n        (number of trials x probability), where number of trials\n        equals population count in the origin `Compartment` and\n        probability is computed from a function of the `TransitionVariable`'s\n        current rate -- see the `approx_binom_probability_from_rate`\n        function for details.\n\n        See `get_realization` for parameters. The `RNG` parameter is not used\n        and is only included to maintain a consistent interface.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Number of individuals transitioning compartments in each age-risk group.\n        \"\"\"\n\n        return np.asarray(self.base_count *\n                          approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps),\n                          dtype=int)\n\n    def get_binom_deterministic_no_round_realization(self,\n                                                     RNG: np.random.Generator,\n                                                     num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        The same as `get_binom_deterministic_realization` except no rounding --\n        so the populations can be non-integer. This is used to test the torch\n        implementation (because that implementation does not round either).\n\n        See `get_realization` for parameters. The `RNG` parameter is not used\n        and is only included to maintain a consistent interface.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                (Non-integer) \"number of individuals\" transitioning compartments in\n                each age-risk group.\n        \"\"\"\n\n        return np.asarray(self.base_count *\n                          approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n\n    def get_binom_taylor_approx_deterministic_realization(self,\n                                                          RNG: np.random.Generator,\n                                                          num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of binomial distribution\n        (number of trials x probability), where number of trials\n        equals population count in the origin `Compartment` and\n        probability equals the `TransitionVariable`'s `current_rate` /\n        `num_timesteps`.\n\n        See `get_realization` for parameters. The `RNG` parameter is not used\n        and is only included to maintain a consistent interface.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Number of individuals transitioning compartments in each age-risk group.\n        \"\"\"\n\n        return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n\n    def get_poisson_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of Poisson distribution,\n        given by (population count in the origin `Compartment` x\n        `TransitionVariable`'s `current_rate` / `num_timesteps`).\n\n        See `get_realization` for parameters. The `RNG` parameter is not used\n        and is only included to maintain a consistent interface.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Number of individuals transitioning compartments in each age-risk group.\n        \"\"\"\n\n        return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n\n    @property\n    def base_count(self) -&gt; np.ndarray:\n        return self.origin.current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.__init__","title":"<code>__init__(origin: Compartment, destination: Compartment, transition_type: TransitionTypes, is_jointly_distributed: str = False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Compartment</code> <p><code>Compartment</code> from which <code>TransitionVariable</code> exits.</p> required <code>destination</code> <code>Compartment</code> <p><code>Compartment</code> that the <code>TransitionVariable</code> enters.</p> required <code>transition_type</code> <code>TransitionTypes</code> <p>Specifies probability distribution of transitions between compartments.</p> required <code>is_jointly_distributed</code> <code>bool</code> <p>Indicates if transition quantity must be jointly computed (i.e. if there are multiple outflows from the origin compartment).</p> <code>False</code> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             origin: Compartment,\n             destination: Compartment,\n             transition_type: TransitionTypes,\n             is_jointly_distributed: str = False):\n    \"\"\"\n    Parameters:\n        origin (Compartment):\n            `Compartment` from which `TransitionVariable` exits.\n        destination (Compartment):\n            `Compartment` that the `TransitionVariable` enters.\n        transition_type (TransitionTypes):\n            Specifies probability distribution of transitions between compartments.\n        is_jointly_distributed (bool):\n            Indicates if transition quantity must be jointly computed\n            (i.e. if there are multiple outflows from the origin compartment).\n    \"\"\"\n\n    self.origin = origin\n    self.destination = destination\n\n    # Also see __init__ method in TransitionVariableGroup class.\n    #   The structure is similar.\n    self._transition_type = transition_type\n    self._is_jointly_distributed = is_jointly_distributed\n\n    # Assigns appropriate realization method based on transition type.\n    # If jointly distributed, no single realization function applies.\n    if is_jointly_distributed:\n        self.get_realization = None\n    else:\n        self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_rate = None\n    self.current_val = None\n\n    self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_deterministic_no_round_realization","title":"<code>get_binom_deterministic_no_round_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>The same as <code>get_binom_deterministic_realization</code> except no rounding -- so the populations can be non-integer. This is used to test the torch implementation (because that implementation does not round either).</p> <p>See <code>get_realization</code> for parameters. The <code>RNG</code> parameter is not used and is only included to maintain a consistent interface.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) (Non-integer) \"number of individuals\" transitioning compartments in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_deterministic_no_round_realization(self,\n                                                 RNG: np.random.Generator,\n                                                 num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    The same as `get_binom_deterministic_realization` except no rounding --\n    so the populations can be non-integer. This is used to test the torch\n    implementation (because that implementation does not round either).\n\n    See `get_realization` for parameters. The `RNG` parameter is not used\n    and is only included to maintain a consistent interface.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            (Non-integer) \"number of individuals\" transitioning compartments in\n            each age-risk group.\n    \"\"\"\n\n    return np.asarray(self.base_count *\n                      approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_deterministic_realization","title":"<code>get_binom_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministically returns mean of binomial distribution (number of trials x probability), where number of trials equals population count in the origin <code>Compartment</code> and probability is computed from a function of the <code>TransitionVariable</code>'s current rate -- see the <code>approx_binom_probability_from_rate</code> function for details.</p> <p>See <code>get_realization</code> for parameters. The <code>RNG</code> parameter is not used and is only included to maintain a consistent interface.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Number of individuals transitioning compartments in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_deterministic_realization(self,\n                                        RNG: np.random.Generator,\n                                        num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of binomial distribution\n    (number of trials x probability), where number of trials\n    equals population count in the origin `Compartment` and\n    probability is computed from a function of the `TransitionVariable`'s\n    current rate -- see the `approx_binom_probability_from_rate`\n    function for details.\n\n    See `get_realization` for parameters. The `RNG` parameter is not used\n    and is only included to maintain a consistent interface.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Number of individuals transitioning compartments in each age-risk group.\n    \"\"\"\n\n    return np.asarray(self.base_count *\n                      approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps),\n                      dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_realization","title":"<code>get_binom_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Uses <code>RNG</code> to generate binomial random variable with number of trials equal to population count in the origin <code>Compartment</code> and probability computed from a function of the <code>TransitionVariable</code>'s current rate -- see <code>approx_binom_probability_from_rate</code> function for details.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Element-wise Binomial distributed transitions for each age-risk group, with the probability parameter generated using a conversion from rates to probabilities.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_realization(self,\n                          RNG: np.random.Generator,\n                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses `RNG` to generate binomial random variable with\n    number of trials equal to population count in the\n    origin `Compartment` and probability computed from\n    a function of the `TransitionVariable`'s current rate\n    -- see `approx_binom_probability_from_rate` function\n    for details.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Element-wise Binomial distributed transitions for each\n            age-risk group, with the probability parameter generated\n            using a conversion from rates to probabilities.\n    \"\"\"\n\n    return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                        p=approx_binom_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_taylor_approx_deterministic_realization","title":"<code>get_binom_taylor_approx_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministically returns mean of binomial distribution (number of trials x probability), where number of trials equals population count in the origin <code>Compartment</code> and probability equals the <code>TransitionVariable</code>'s <code>current_rate</code> / <code>num_timesteps</code>.</p> <p>See <code>get_realization</code> for parameters. The <code>RNG</code> parameter is not used and is only included to maintain a consistent interface.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Number of individuals transitioning compartments in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_taylor_approx_deterministic_realization(self,\n                                                      RNG: np.random.Generator,\n                                                      num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of binomial distribution\n    (number of trials x probability), where number of trials\n    equals population count in the origin `Compartment` and\n    probability equals the `TransitionVariable`'s `current_rate` /\n    `num_timesteps`.\n\n    See `get_realization` for parameters. The `RNG` parameter is not used\n    and is only included to maintain a consistent interface.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Number of individuals transitioning compartments in each age-risk group.\n    \"\"\"\n\n    return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_binom_taylor_approx_realization","title":"<code>get_binom_taylor_approx_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Uses <code>RNG</code> to generate binomial random variable with     number of trials equal to population count in the     origin <code>Compartment</code> and probability equal to     the <code>TransitionVariable</code>'s <code>current_rate</code> / <code>num_timesteps</code>.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Element-wise Binomial distributed transitions for each age-risk group, with the probability parameter generated using a Taylor approximation.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_binom_taylor_approx_realization(self,\n                                        RNG: np.random.Generator,\n                                        num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses `RNG` to generate binomial random variable with\n        number of trials equal to population count in the\n        origin `Compartment` and probability equal to\n        the `TransitionVariable`'s `current_rate` / `num_timesteps`.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Element-wise Binomial distributed transitions for each\n            age-risk group, with the probability parameter generated\n            using a Taylor approximation.\n    \"\"\"\n    return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                        p=self.current_rate * (1.0 / num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_current_rate","title":"<code>get_current_rate(state: SubpopState, params: SubpopParams) -&gt; np.ndarray</code>  <code>abstractmethod</code>","text":"<p>Computes and returns current rate of transition variable, based on current state of the simulation and epidemiological parameters.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>Holds subpopulation simulation state (current values of <code>StateVariable</code> instances).</p> required <code>params</code> <code>SubpopParams</code> <p>Holds values of epidemiological parameters.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: Holds age-risk transition rate.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>@abstractmethod\ndef get_current_rate(self,\n                     state: SubpopState,\n                     params: SubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns current rate of transition variable,\n    based on current state of the simulation and epidemiological parameters.\n\n    Args:\n        state (SubpopState):\n            Holds subpopulation simulation state\n            (current values of `StateVariable` instances).\n        params (SubpopParams):\n            Holds values of epidemiological parameters.\n\n    Returns:\n        np.ndarray:\n            Holds age-risk transition rate.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_poisson_deterministic_realization","title":"<code>get_poisson_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministically returns mean of Poisson distribution, given by (population count in the origin <code>Compartment</code> x <code>TransitionVariable</code>'s <code>current_rate</code> / <code>num_timesteps</code>).</p> <p>See <code>get_realization</code> for parameters. The <code>RNG</code> parameter is not used and is only included to maintain a consistent interface.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Number of individuals transitioning compartments in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_poisson_deterministic_realization(self,\n                                          RNG: np.random.Generator,\n                                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of Poisson distribution,\n    given by (population count in the origin `Compartment` x\n    `TransitionVariable`'s `current_rate` / `num_timesteps`).\n\n    See `get_realization` for parameters. The `RNG` parameter is not used\n    and is only included to maintain a consistent interface.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Number of individuals transitioning compartments in each age-risk group.\n    \"\"\"\n\n    return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_poisson_realization","title":"<code>get_poisson_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Generates realizations from a Poisson distribution.</p> <p>The rate is computed element-wise from each age-risk group as: (origin compartment population count x <code>current_rate</code> / <code>num_timesteps</code>)</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Poisson-distributed integers representing number of individuals transitioning in each age-risk group.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_poisson_realization(self,\n                            RNG: np.random.Generator,\n                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Generates realizations from a Poisson distribution.\n\n    The rate is computed element-wise from each age-risk group as:\n    (origin compartment population count x `current_rate` / `num_timesteps`)\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Poisson-distributed integers representing number\n            of individuals transitioning in each age-risk group.\n    \"\"\"\n    return RNG.poisson(self.base_count * self.current_rate / float(num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.get_realization","title":"<code>get_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Generate a realization of the transition process.</p> <p>This method is dynamically assigned to the appropriate transition-specific function (e.g., <code>get_binom_realization</code>) depending on the transition type. Provides common interface so realizations can always be obtained via <code>get_realization</code>.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>Used to generate stochastic transitions in the model and control  reproducibility. If deterministic transitions are used, the  RNG is passed for a consistent function interface but the RNG  is not used.</p> required <code>num_timesteps</code> <code>int</code> <p>Number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>np.ndarray of shape (A, R)</code> <p>Number of transitions for age-risk groups.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_realization(self,\n                    RNG: np.random.Generator,\n                    num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Generate a realization of the transition process.\n\n    This method is dynamically assigned to the appropriate transition-specific\n    function (e.g., `get_binom_realization`) depending on the transition type.\n    Provides common interface so realizations can always be obtained via\n    ``get_realization``.\n\n    Parameters:\n        RNG (np.random.Generator object):\n             Used to generate stochastic transitions in the model and control\n             reproducibility. If deterministic transitions are used, the\n             RNG is passed for a consistent function interface but the RNG\n             is not used.\n        num_timesteps (int):\n            Number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        (np.ndarray of shape (A, R)):\n            Number of transitions for age-risk groups.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets <code>history_vals_list</code> attribute to empty list.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets `history_vals_list` attribute to empty list.\n    \"\"\"\n\n    self.current_rate = None\n    self.current_val = None\n    self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.save_history","title":"<code>save_history() -&gt; None</code>","text":"<p>Saves current value to history by appending <code>current_val</code> attribute to <code>history_vals_list</code> in-place..</p> <p>Deep copying is CRUCIAL because <code>current_val</code> is a mutable np.ndarray -- without deep copying, <code>history_vals_list</code> would have the same value for all elements.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending `current_val`\n    attribute to `history_vals_list` in-place..\n\n    Deep copying is CRUCIAL because `current_val` is a mutable\n    np.ndarray -- without deep copying, `history_vals_list` would\n    have the same value for all elements.\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.update_destination_inflow","title":"<code>update_destination_inflow() -&gt; None</code>","text":"<p>Adds current realization of <code>TransitionVariable</code> to     its destination <code>Compartment</code>'s <code>current_inflow</code>.     Used to compute total number leaving that     destination <code>Compartment</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_destination_inflow(self) -&gt; None:\n    \"\"\"\n    Adds current realization of `TransitionVariable` to\n        its destination `Compartment`'s `current_inflow`.\n        Used to compute total number leaving that\n        destination `Compartment`.\n    \"\"\"\n\n    self.destination.current_inflow = self.destination.current_inflow + self.current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariable.update_origin_outflow","title":"<code>update_origin_outflow() -&gt; None</code>","text":"<p>Adds current realization of <code>TransitionVariable</code> to     its origin <code>Compartment</code>'s current_outflow.     Used to compute total number leaving that     origin <code>Compartment</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_origin_outflow(self) -&gt; None:\n    \"\"\"\n    Adds current realization of `TransitionVariable` to\n        its origin `Compartment`'s current_outflow.\n        Used to compute total number leaving that\n        origin `Compartment`.\n    \"\"\"\n\n    self.origin.current_outflow = self.origin.current_outflow + self.current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup","title":"<code>TransitionVariableGroup</code>","text":"<p>Container for <code>TransitionVariable</code> objects to handle joint sampling, when there are multiple outflows from a single compartment.</p> <p>For example, if all outflows of compartment <code>H</code> are: <code>R</code> and <code>D</code>, i.e. from the hospital, individuals either recover or die, a <code>TransitionVariableGroup</code> that holds both <code>R</code> and <code>D</code> handles the correct correlation structure between <code>R</code> and <code>D.</code></p> <p>When an instance is initialized, its <code>get_joint_realization</code> attribute is dynamically assigned to a method according to its <code>transition_type</code> attribute. This enables all instances to use the same method during simulation.</p> Dimensions <p>M (int):     number of outgoing compartments from the origin compartment A (int):     number of age groups R (int):     number of risk groups</p> <p>Attributes:</p> Name Type Description <code>origin</code> <code>Compartment</code> <p>Specifies origin of <code>TransitionVariableGroup</code> -- corresponding populations leave this compartment.</p> <code>_transition_type</code> <code>str</code> <p>Only values defined in <code>JointTransitionTypes</code> are valid, specifies joint probability distribution of all outflows from origin.</p> <code>transition_variables</code> <code>list[`TransitionVariable`]</code> <p>Specifying <code>TransitionVariable</code> instances that outflow from origin -- order does not matter.</p> <code>get_joint_realization</code> <code>function</code> <p>Assigned at initialization, generates realizations according to probability distribution given by <code>transition_type</code>, returns np.ndarray of either shape (M, A, R) or ((M+1), A, R), where M is the length of <code>transition_variables</code> (i.e., number of outflows from origin), A is the number of age groups, R is number of risk groups.</p> <code>current_vals_list</code> <code>list</code> <p>Used to store results from <code>get_joint_realization</code> -- has either M or M+1 arrays of shape (A, R).</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>class TransitionVariableGroup:\n    \"\"\"\n    Container for `TransitionVariable` objects to handle joint sampling,\n    when there are multiple outflows from a single compartment.\n\n    For example, if all outflows of compartment `H` are: `R` and `D`,\n    i.e. from the hospital, individuals either recover or die,\n    a `TransitionVariableGroup` that holds both `R` and `D` handles\n    the correct correlation structure between `R` and `D.`\n\n    When an instance is initialized, its `get_joint_realization` attribute\n    is dynamically assigned to a method according to its `transition_type`\n    attribute. This enables all instances to use the same method during\n    simulation.\n\n    Dimensions:\n        M (int):\n            number of outgoing compartments from the origin compartment\n        A (int):\n            number of age groups\n        R (int):\n            number of risk groups\n\n    Attributes:\n        origin (Compartment):\n            Specifies origin of `TransitionVariableGroup` --\n            corresponding populations leave this compartment.\n        _transition_type (str):\n            Only values defined in `JointTransitionTypes` are valid,\n            specifies joint probability distribution of all outflows\n            from origin.\n        transition_variables (list[`TransitionVariable`]):\n            Specifying `TransitionVariable` instances that outflow from origin --\n            order does not matter.\n        get_joint_realization (function):\n            Assigned at initialization, generates realizations according\n            to probability distribution given by `transition_type`,\n            returns np.ndarray of either shape (M, A, R) or ((M+1), A, R),\n            where M is the length of `transition_variables` (i.e., number of\n            outflows from origin), A is the number of age groups, R is number of\n            risk groups.\n        current_vals_list (list):\n            Used to store results from `get_joint_realization` --\n            has either M or M+1 arrays of shape (A, R).\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin: Compartment,\n                 transition_type: TransitionTypes,\n                 transition_variables: list[TransitionVariable]):\n        \"\"\"\n        Args:\n            transition_type (TransitionTypes):\n                Specifies probability distribution of transitions between compartments.\n\n        See class docstring for other parameters.\n        \"\"\"\n\n        self.origin = origin\n\n        # Using a list is important here because we want to keep the order\n        #   of transition variables -- this determines the index in the\n        #   current rates array\n        self.transition_variables = transition_variables\n\n        # If marginal transition type is any kind of binomial transition,\n        #   then its joint transition type is a multinomial counterpart\n        # For example, if the marginal transition type is TransitionTypes.BINOM_DETERMINISTIC,\n        #   then the joint transition type is JointTransitionTypes.MULTINOM_DETERMINISTIC\n        transition_type = transition_type.replace(\"binom\", \"multinom\")\n        self._transition_type = transition_type\n\n        # Dynamically assign a method to get_joint_realization attribute\n        #   based on the value of transition_type\n        # getattr fetches a method by name\n        self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; JointTransitionTypes:\n        return self._transition_type\n\n    def get_total_rate(self) -&gt; np.ndarray:\n        \"\"\"\n        Return the age-risk-specific total transition rate,\n        which is the sum of the current rate of each transition variable\n        in this transition variable group.\n\n        Used to properly scale multinomial probabilities vector so\n        that elements sum to 1.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                Array with values corresponding to sum of current rates of\n                transition variables in transition variable group, where\n                elements correspond to age-risk groups.\n        \"\"\"\n\n        # axis 0: corresponds to outgoing transition variable\n        # axis 1: corresponds to age groups\n        # axis 2: corresponds to risk groups\n        # --&gt; summing over axis 0 gives the total rate for each age-risk group\n        return np.sum(self.get_current_rates_array(), axis=0)\n\n    def get_probabilities_array(self,\n                                num_timesteps: int) -&gt; list:\n        \"\"\"\n        Returns an array of probabilities used for joint binomial\n        (multinomial) transitions (`get_multinom_realization` method).\n\n        Returns:\n            (np.ndarray of shape (M+1, A, R)\n                Contains positive floats &lt;= 1, corresponding to probability\n                of transitioning to a compartment for that outgoing compartment\n                and age-risk group -- note the \"+1\" corresponds to the multinomial\n                outcome of staying in the same compartment (we can think of as\n                transitioning to the same compartment).\n        \"\"\"\n\n        total_rate = self.get_total_rate()\n\n        total_outgoing_probability = approx_binom_probability_from_rate(total_rate,\n                                                                        1 / num_timesteps)\n\n        # Create probabilities_list, where element i corresponds to the\n        #   transition variable i's current rate divided by the total rate,\n        #   multiplized by the total outgoing probability\n        # This generates the probabilities array that parameterizes the\n        #   multinomial distribution\n        probabilities_list = []\n\n        for transition_variable in self.transition_variables:\n            probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                      total_outgoing_probability)\n\n        # Append the probability that a person stays in the compartment\n        probabilities_list.append(1 - total_outgoing_probability)\n\n        return np.asarray(probabilities_list)\n\n    def get_current_rates_array(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of current rates of transition variables in\n        `transition_variables` -- ith element in array\n        corresponds to current rate of ith transition variable.\n\n        Returns:\n            (np.ndarray of shape (M, A, R))\n                array of positive floats corresponding to current rate\n                element-wise for an outgoing compartment and age-risk group\n        \"\"\"\n\n        current_rates_list = []\n        for tvar in self.transition_variables:\n            current_rates_list.append(tvar.current_rate)\n\n        return np.asarray(current_rates_list)\n\n    def get_joint_realization(self,\n                              RNG: np.random.Generator,\n                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        This function is dynamically assigned based on the `TransitionVariableGroup`'s\n            `transition_type`. It is set to the appropriate distribution-specific method.\n\n        See `get_realization` for parameters.\n        \"\"\"\n\n        pass\n\n    def get_multinom_realization(self,\n                                 RNG: np.random.Generator,\n                                 num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive floats with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    probabilities_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_multinom_taylor_approx_realization(self,\n                                               RNG: np.random.Generator,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution\n        using Taylor Series approximation for probability parameter.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive integers with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        current_rates_array = self.get_current_rates_array()\n\n        total_rate = self.get_total_rate()\n\n        # Multiply current rates array by length of time interval (1 / num_timesteps)\n        # Also append additional value corresponding to probability of\n        #   remaining in current epi compartment (not transitioning at all)\n        # Note: \"vstack\" function here works better than append function because append\n        #   automatically flattens the resulting array, resulting in dimension issues\n        current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                                np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    current_scaled_rates_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from Poisson distribution.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M, A, R))\n                contains positive integers with transition realizations\n                for individuals going to compartment m in age-risk group (a, r)\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n        transition_variables = self.transition_variables\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                for outflow_ix in range(num_outflows):\n                    realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                        self.origin.current_val[age_group, risk_group] *\n                        transition_variables[outflow_ix].current_rate[\n                            age_group, risk_group] / num_timesteps)\n\n        return realizations_array\n\n    def get_multinom_deterministic_realization(self,\n                                               RNG: np.random.Generator,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to `get_multinom_realization` --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive integers with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n        return np.asarray(self.origin.current_val * probabilities_array, dtype=int)\n\n    def get_multinom_deterministic_no_round_realization(self,\n                                                        RNG: np.random.Generator,\n                                                        num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        The same as `get_multinom_deterministic_realization` except no rounding --\n        so the populations can be non-integer. This is used to test the torch\n        implementation (because that implementation does not round either).\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive floats with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n        return np.asarray(self.origin.current_val * probabilities_array)\n\n    def get_multinom_taylor_approx_deterministic_realization(self,\n                                                             RNG: np.random.Generator,\n                                                             num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to `get_multinom_taylor_approx_realization` --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (M + 1, A, R))\n                contains positive floats with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        current_rates_array = self.get_current_rates_array()\n        return np.asarray(self.origin.current_val * current_rates_array / num_timesteps, dtype=int)\n\n    def get_poisson_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to `get_poisson_realization` --\n        uses mean (rate array) as realization rather than randomly sampling.\n\n        See `get_realization` for parameters.\n\n        Returns:\n            (np.ndarray of shape (A, R))\n                contains positive integers with transition realizations\n                for individuals going to compartment m in age-risk group (a, r) --\n        \"\"\"\n\n        return np.asarray(self.origin.current_val *\n                          self.get_current_rates_array() / num_timesteps, dtype=int)\n\n    def reset(self) -&gt; None:\n        self.current_vals_list = []\n\n    def update_transition_variable_realizations(self) -&gt; None:\n        \"\"\"\n        Updates current_val attribute on all `TransitionVariable`\n        instances contained in this `TransitionVariableGroup`.\n        \"\"\"\n\n        # Since the ith element in probabilities_array corresponds to the ith transition variable\n        #   in transition_variables, the ith element in multinom_realizations_list\n        #   also corresponds to the ith transition variable in transition_variables\n        # Update the current realization of the transition variables contained in this group\n        for ix in range(len(self.transition_variables)):\n            self.transition_variables[ix].current_val = \\\n                self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.__init__","title":"<code>__init__(origin: Compartment, transition_type: TransitionTypes, transition_variables: list[TransitionVariable])</code>","text":"<p>Parameters:</p> Name Type Description Default <code>transition_type</code> <code>TransitionTypes</code> <p>Specifies probability distribution of transitions between compartments.</p> required <p>See class docstring for other parameters.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def __init__(self,\n             origin: Compartment,\n             transition_type: TransitionTypes,\n             transition_variables: list[TransitionVariable]):\n    \"\"\"\n    Args:\n        transition_type (TransitionTypes):\n            Specifies probability distribution of transitions between compartments.\n\n    See class docstring for other parameters.\n    \"\"\"\n\n    self.origin = origin\n\n    # Using a list is important here because we want to keep the order\n    #   of transition variables -- this determines the index in the\n    #   current rates array\n    self.transition_variables = transition_variables\n\n    # If marginal transition type is any kind of binomial transition,\n    #   then its joint transition type is a multinomial counterpart\n    # For example, if the marginal transition type is TransitionTypes.BINOM_DETERMINISTIC,\n    #   then the joint transition type is JointTransitionTypes.MULTINOM_DETERMINISTIC\n    transition_type = transition_type.replace(\"binom\", \"multinom\")\n    self._transition_type = transition_type\n\n    # Dynamically assign a method to get_joint_realization attribute\n    #   based on the value of transition_type\n    # getattr fetches a method by name\n    self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_current_rates_array","title":"<code>get_current_rates_array() -&gt; np.ndarray</code>","text":"<p>Returns an array of current rates of transition variables in <code>transition_variables</code> -- ith element in array corresponds to current rate of ith transition variable.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M, A, R)) array of positive floats corresponding to current rate element-wise for an outgoing compartment and age-risk group</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_current_rates_array(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of current rates of transition variables in\n    `transition_variables` -- ith element in array\n    corresponds to current rate of ith transition variable.\n\n    Returns:\n        (np.ndarray of shape (M, A, R))\n            array of positive floats corresponding to current rate\n            element-wise for an outgoing compartment and age-risk group\n    \"\"\"\n\n    current_rates_list = []\n    for tvar in self.transition_variables:\n        current_rates_list.append(tvar.current_rate)\n\n    return np.asarray(current_rates_list)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_joint_realization","title":"<code>get_joint_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>This function is dynamically assigned based on the <code>TransitionVariableGroup</code>'s     <code>transition_type</code>. It is set to the appropriate distribution-specific method.</p> <p>See <code>get_realization</code> for parameters.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_joint_realization(self,\n                          RNG: np.random.Generator,\n                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    This function is dynamically assigned based on the `TransitionVariableGroup`'s\n        `transition_type`. It is set to the appropriate distribution-specific method.\n\n    See `get_realization` for parameters.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_deterministic_no_round_realization","title":"<code>get_multinom_deterministic_no_round_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>The same as <code>get_multinom_deterministic_realization</code> except no rounding -- so the populations can be non-integer. This is used to test the torch implementation (because that implementation does not round either).</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive floats with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_deterministic_no_round_realization(self,\n                                                    RNG: np.random.Generator,\n                                                    num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    The same as `get_multinom_deterministic_realization` except no rounding --\n    so the populations can be non-integer. This is used to test the torch\n    implementation (because that implementation does not round either).\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive floats with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n    return np.asarray(self.origin.current_val * probabilities_array)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_deterministic_realization","title":"<code>get_multinom_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministic counterpart to <code>get_multinom_realization</code> -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive integers with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_deterministic_realization(self,\n                                           RNG: np.random.Generator,\n                                           num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to `get_multinom_realization` --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive integers with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n    return np.asarray(self.origin.current_val * probabilities_array, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_realization","title":"<code>get_multinom_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive floats with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_realization(self,\n                             RNG: np.random.Generator,\n                             num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive floats with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                probabilities_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_taylor_approx_deterministic_realization","title":"<code>get_multinom_taylor_approx_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministic counterpart to <code>get_multinom_taylor_approx_realization</code> -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive floats with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_taylor_approx_deterministic_realization(self,\n                                                         RNG: np.random.Generator,\n                                                         num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to `get_multinom_taylor_approx_realization` --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive floats with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    current_rates_array = self.get_current_rates_array()\n    return np.asarray(self.origin.current_val * current_rates_array / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_multinom_taylor_approx_realization","title":"<code>get_multinom_taylor_approx_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution using Taylor Series approximation for probability parameter.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M + 1, A, R)) contains positive integers with transition realizations for individuals going to compartment m in age-risk group (a, r) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_multinom_taylor_approx_realization(self,\n                                           RNG: np.random.Generator,\n                                           num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution\n    using Taylor Series approximation for probability parameter.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M + 1, A, R))\n            contains positive integers with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    current_rates_array = self.get_current_rates_array()\n\n    total_rate = self.get_total_rate()\n\n    # Multiply current rates array by length of time interval (1 / num_timesteps)\n    # Also append additional value corresponding to probability of\n    #   remaining in current epi compartment (not transitioning at all)\n    # Note: \"vstack\" function here works better than append function because append\n    #   automatically flattens the resulting array, resulting in dimension issues\n    current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                            np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                current_scaled_rates_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_poisson_deterministic_realization","title":"<code>get_poisson_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministic counterpart to <code>get_poisson_realization</code> -- uses mean (rate array) as realization rather than randomly sampling.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) contains positive integers with transition realizations for individuals going to compartment m in age-risk group (a, r) --</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_poisson_deterministic_realization(self,\n                                          RNG: np.random.Generator,\n                                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to `get_poisson_realization` --\n    uses mean (rate array) as realization rather than randomly sampling.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            contains positive integers with transition realizations\n            for individuals going to compartment m in age-risk group (a, r) --\n    \"\"\"\n\n    return np.asarray(self.origin.current_val *\n                      self.get_current_rates_array() / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_poisson_realization","title":"<code>get_poisson_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from Poisson distribution.</p> <p>See <code>get_realization</code> for parameters.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (M, A, R)) contains positive integers with transition realizations for individuals going to compartment m in age-risk group (a, r)</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_poisson_realization(self,\n                            RNG: np.random.Generator,\n                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from Poisson distribution.\n\n    See `get_realization` for parameters.\n\n    Returns:\n        (np.ndarray of shape (M, A, R))\n            contains positive integers with transition realizations\n            for individuals going to compartment m in age-risk group (a, r)\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n    transition_variables = self.transition_variables\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            for outflow_ix in range(num_outflows):\n                realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                    self.origin.current_val[age_group, risk_group] *\n                    transition_variables[outflow_ix].current_rate[\n                        age_group, risk_group] / num_timesteps)\n\n    return realizations_array\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_probabilities_array","title":"<code>get_probabilities_array(num_timesteps: int) -&gt; list</code>","text":"<p>Returns an array of probabilities used for joint binomial (multinomial) transitions (<code>get_multinom_realization</code> method).</p> <p>Returns:</p> Type Description <code>list</code> <p>(np.ndarray of shape (M+1, A, R) Contains positive floats &lt;= 1, corresponding to probability of transitioning to a compartment for that outgoing compartment and age-risk group -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (we can think of as transitioning to the same compartment).</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_probabilities_array(self,\n                            num_timesteps: int) -&gt; list:\n    \"\"\"\n    Returns an array of probabilities used for joint binomial\n    (multinomial) transitions (`get_multinom_realization` method).\n\n    Returns:\n        (np.ndarray of shape (M+1, A, R)\n            Contains positive floats &lt;= 1, corresponding to probability\n            of transitioning to a compartment for that outgoing compartment\n            and age-risk group -- note the \"+1\" corresponds to the multinomial\n            outcome of staying in the same compartment (we can think of as\n            transitioning to the same compartment).\n    \"\"\"\n\n    total_rate = self.get_total_rate()\n\n    total_outgoing_probability = approx_binom_probability_from_rate(total_rate,\n                                                                    1 / num_timesteps)\n\n    # Create probabilities_list, where element i corresponds to the\n    #   transition variable i's current rate divided by the total rate,\n    #   multiplized by the total outgoing probability\n    # This generates the probabilities array that parameterizes the\n    #   multinomial distribution\n    probabilities_list = []\n\n    for transition_variable in self.transition_variables:\n        probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                  total_outgoing_probability)\n\n    # Append the probability that a person stays in the compartment\n    probabilities_list.append(1 - total_outgoing_probability)\n\n    return np.asarray(probabilities_list)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.get_total_rate","title":"<code>get_total_rate() -&gt; np.ndarray</code>","text":"<p>Return the age-risk-specific total transition rate, which is the sum of the current rate of each transition variable in this transition variable group.</p> <p>Used to properly scale multinomial probabilities vector so that elements sum to 1.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>(np.ndarray of shape (A, R)) Array with values corresponding to sum of current rates of transition variables in transition variable group, where elements correspond to age-risk groups.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def get_total_rate(self) -&gt; np.ndarray:\n    \"\"\"\n    Return the age-risk-specific total transition rate,\n    which is the sum of the current rate of each transition variable\n    in this transition variable group.\n\n    Used to properly scale multinomial probabilities vector so\n    that elements sum to 1.\n\n    Returns:\n        (np.ndarray of shape (A, R))\n            Array with values corresponding to sum of current rates of\n            transition variables in transition variable group, where\n            elements correspond to age-risk groups.\n    \"\"\"\n\n    # axis 0: corresponds to outgoing transition variable\n    # axis 1: corresponds to age groups\n    # axis 2: corresponds to risk groups\n    # --&gt; summing over axis 0 gives the total rate for each age-risk group\n    return np.sum(self.get_current_rates_array(), axis=0)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.TransitionVariableGroup.update_transition_variable_realizations","title":"<code>update_transition_variable_realizations() -&gt; None</code>","text":"<p>Updates current_val attribute on all <code>TransitionVariable</code> instances contained in this <code>TransitionVariableGroup</code>.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def update_transition_variable_realizations(self) -&gt; None:\n    \"\"\"\n    Updates current_val attribute on all `TransitionVariable`\n    instances contained in this `TransitionVariableGroup`.\n    \"\"\"\n\n    # Since the ith element in probabilities_array corresponds to the ith transition variable\n    #   in transition_variables, the ith element in multinom_realizations_list\n    #   also corresponds to the ith transition variable in transition_variables\n    # Update the current realization of the transition variables contained in this group\n    for ix in range(len(self.transition_variables)):\n        self.transition_variables[ix].current_val = \\\n            self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.approx_binom_probability_from_rate","title":"<code>approx_binom_probability_from_rate(rate: np.ndarray, interval_length: int) -&gt; np.ndarray</code>","text":"<p>Converts a rate (events per time) to the probability of any event occurring in the next time interval of length <code>interval_length</code>, assuming the number of events occurring in time interval follows a Poisson distribution with given rate parameter.</p> <p>The probability of 0 events in <code>interval_length</code> is e^(-<code>rate</code> * <code>interval_length</code>), so the probability of any event in <code>interval_length</code> is 1 - e^(-<code>rate</code> * <code>interval_length</code>).</p> <p>Rate must be A x R <code>np.ndarray</code>, where A is the number of age groups and R is the number of risk groups. Rate is transformed to A x R <code>np.ndarray</code> corresponding to probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>np.ndarray of shape (A, R</code> <p>Rate parameters in a Poisson distribution per age-risk group.</p> required <code>interval_length</code> <code>positive int</code> <p>Length of time interval in simulation days.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R): Array of positive scalars corresponding to probability that any individual in an age-risk group transitions compartments.</p> Source code in <code>CLT_BaseModel/clt_toolkit/base_components.py</code> <pre><code>def approx_binom_probability_from_rate(rate: np.ndarray,\n                                       interval_length: int) -&gt; np.ndarray:\n    \"\"\"\n    Converts a rate (events per time) to the probability of any event\n    occurring in the next time interval of length `interval_length`,\n    assuming the number of events occurring in time interval\n    follows a Poisson distribution with given rate parameter.\n\n    The probability of 0 events in `interval_length` is\n    e^(-`rate` * `interval_length`), so the probability of any event\n    in `interval_length` is 1 - e^(-`rate` * `interval_length`).\n\n    Rate must be A x R `np.ndarray`, where A is the number of\n    age groups and R is the number of risk groups. Rate is transformed to\n    A x R `np.ndarray` corresponding to probabilities.\n\n    Parameters:\n        rate (np.ndarray of shape (A, R)):\n            Rate parameters in a Poisson distribution per age-risk group.\n        interval_length (positive int):\n            Length of time interval in simulation days.\n\n    Returns:\n        np.ndarray of shape (A, R):\n            Array of positive scalars corresponding to probability that\n            any individual in an age-risk group transitions compartments.\n    \"\"\"\n\n    return 1 - np.exp(-rate * interval_length)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.convert_dict_vals_lists_to_arrays","title":"<code>convert_dict_vals_lists_to_arrays(d: dict) -&gt; dict</code>","text":"<p>Converts dictionary of lists to dictionary of arrays to support <code>numpy</code> operations.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def convert_dict_vals_lists_to_arrays(d: dict) -&gt; dict:\n    \"\"\"\n    Converts dictionary of lists to dictionary of arrays\n    to support `numpy` operations.\n    \"\"\"\n\n    for key, val in d.items():\n        if type(val) is list:\n            d[key] = np.asarray(val)\n\n    return d\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.load_json_augment_dict","title":"<code>load_json_augment_dict(json_filepath: str, d: dict) -&gt; dict</code>","text":"<p>Augments pre-existing dictionary with information from <code>JSON</code> file -- if keys already exist, the previous values are overriden, otherwise the new key-value pairs are added. Lists are automatically converted to numpy arrays for computational compatibility, since <code>JSON</code> does not natively support <code>np.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>json_filepath</code> <code>str</code> <p>Full <code>JSON</code> filepath.</p> required <code>d</code> <code>dict</code> <p>Dictionary to be augmented with new <code>JSON</code> values.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary loaded with <code>JSON</code> information.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def load_json_augment_dict(json_filepath: str,\n                           d: dict) -&gt; dict:\n    \"\"\"\n    Augments pre-existing dictionary with information\n    from `JSON` file -- if keys already exist, the previous values\n    are overriden, otherwise the new key-value pairs are added.\n    Lists are automatically converted to numpy arrays for\n    computational compatibility, since `JSON` does not natively\n    support `np.ndarray`.\n\n    Args:\n        json_filepath (str):\n            Full `JSON` filepath.\n        d (dict):\n            Dictionary to be augmented with new `JSON` values.\n\n    Returns:\n        (dict):\n            Dictionary loaded with `JSON` information.\n    \"\"\"\n\n    with open(json_filepath, 'r') as file:\n        data = json.load(file)\n\n    data = convert_dict_vals_lists_to_arrays(data)\n\n    for key, val in data.items():\n        d[key] = val\n\n    return d\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.load_json_new_dict","title":"<code>load_json_new_dict(json_filepath: str) -&gt; dict</code>","text":"<p>Loads specified <code>JSON</code> file into new dictionary. Lists are automatically converted to numpy arrays for computational compatibility, since <code>JSON</code> does not natively support <code>np.ndarray</code>.</p> <p>Parameters:</p> Name Type Description Default <code>json_filepath</code> <code>str</code> <p>Full <code>JSON</code> filepath.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary loaded with <code>JSON</code> information.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def load_json_new_dict(json_filepath: str) -&gt; dict:\n    \"\"\"\n    Loads specified `JSON` file into new dictionary.\n    Lists are automatically converted to numpy arrays for\n    computational compatibility, since `JSON` does not natively\n    support `np.ndarray`.\n\n    Args:\n        json_filepath (str):\n            Full `JSON` filepath.\n\n    Returns:\n        (dict):\n            Dictionary loaded with `JSON` information.\n    \"\"\"\n\n    # Note: the \"with open\" is important for file handling\n    #   and avoiding resource leaks -- otherwise,\n    #   we have to manually close the file, which is a bit\n    #   more cumbersome\n    with open(json_filepath, 'r') as file:\n        data = json.load(file)\n\n    # json does not support numpy, so we must convert\n    #   lists to numpy arrays\n    return convert_dict_vals_lists_to_arrays(data)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.make_dataclass_from_dict","title":"<code>make_dataclass_from_dict(dataclass_ref: Type[DataClassProtocol], d: dict) -&gt; DataClassProtocol</code>","text":"<p>Create instance of class dataclass_ref, based on information in dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dataclass_ref</code> <code>Type[DataClassProtocol]</code> <p>(class, not instance) from which to create instance -- must have dataclass decorator.</p> required <code>d</code> <code>dict</code> <p>all keys and values respectively must match name and datatype of dataclass_ref instance attributes.</p> required <p>Returns:</p> Name Type Description <code>DataClassProtocol</code> <code>DataClassProtocol</code> <p>instance of dataclass_ref with attributes dynamically assigned by json_filepath file contents.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def make_dataclass_from_dict(dataclass_ref: Type[DataClassProtocol],\n                             d: dict) -&gt; DataClassProtocol:\n    \"\"\"\n    Create instance of class dataclass_ref,\n    based on information in dictionary.\n\n    Args:\n        dataclass_ref (Type[DataClassProtocol]):\n            (class, not instance) from which to create instance --\n            must have dataclass decorator.\n        d (dict):\n            all keys and values respectively must match name and datatype\n            of dataclass_ref instance attributes.\n\n    Returns:\n        DataClassProtocol:\n            instance of dataclass_ref with attributes dynamically\n            assigned by json_filepath file contents.\n    \"\"\"\n\n    d = convert_dict_vals_lists_to_arrays(d)\n\n    return dataclass_ref(**d)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.make_dataclass_from_json","title":"<code>make_dataclass_from_json(json_filepath: str, dataclass_ref: Type[DataClassProtocol]) -&gt; DataClassProtocol</code>","text":"<p>Create instance of class dataclass_ref, based on information in json_filepath.</p> <p>Parameters:</p> Name Type Description Default <code>json_filepath</code> <code>str</code> <p>path to json file (path includes actual filename with suffix \".json\") -- all json fields must match name and datatype of dataclass_ref instance attributes.</p> required <code>dataclass_ref</code> <code>Type[DataClassProtocol]</code> <p>(class, not instance) from which to create instance -- must have dataclass decorator.</p> required <p>Returns:</p> Name Type Description <code>DataClassProtocol</code> <code>DataClassProtocol</code> <p>instance of dataclass_ref with attributes dynamically assigned by json_filepath file contents.</p> Source code in <code>CLT_BaseModel/clt_toolkit/input_parsers.py</code> <pre><code>def make_dataclass_from_json(json_filepath: str,\n                             dataclass_ref: Type[DataClassProtocol]) -&gt; DataClassProtocol:\n    \"\"\"\n    Create instance of class dataclass_ref,\n    based on information in json_filepath.\n\n    Args:\n        json_filepath (str):\n            path to json file (path includes actual filename\n            with suffix \".json\") -- all json fields must\n            match name and datatype of dataclass_ref instance\n            attributes.\n        dataclass_ref (Type[DataClassProtocol]):\n            (class, not instance) from which to create instance --\n            must have dataclass decorator.\n\n    Returns:\n        DataClassProtocol:\n            instance of dataclass_ref with attributes dynamically\n            assigned by json_filepath file contents.\n    \"\"\"\n\n    d = load_json_new_dict(json_filepath)\n\n    return make_dataclass_from_dict(dataclass_ref, d)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_basic_compartment_history","title":"<code>plot_metapop_basic_compartment_history(metapop_model: MetapopModel, axes: matplotlib.axes.Axes = None)</code>","text":"<p>Plots the compartment data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_basic_compartment_history(metapop_model: MetapopModel,\n                                           axes: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots the compartment data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    # Iterate over subpop models and plot\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_basic_compartment_history(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_decorator","title":"<code>plot_metapop_decorator(plot_func)</code>","text":"<p>Decorator to handle common metapopulation plotting tasks.</p> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>def plot_metapop_decorator(plot_func):\n    \"\"\"\n    Decorator to handle common metapopulation plotting tasks.\n    \"\"\"\n\n    @functools.wraps(plot_func)\n    def wrapper(metapop_model: MetapopModel,\n                savefig_filename = None):\n\n        num_plots = len(metapop_model.subpop_models)\n        num_cols = 2\n        num_rows = (num_plots + num_cols - 1) // num_cols\n\n        # Create figure and axes\n        fig, axes = plt.subplots(num_rows, num_cols, figsize=(5 * num_cols, 4 * num_rows))\n        axes = axes.flatten()\n\n        plot_func(metapop_model=metapop_model, axes=axes)\n\n        # Turn off any unused subplots\n        for j in range(num_plots, len(axes)):\n            fig.delaxes(axes[j])  # Remove empty subplot\n\n        # Adjust layout and save/show the figure\n        plt.tight_layout()\n\n        if savefig_filename:\n            plt.savefig(savefig_filename, dpi=1200)\n\n        plt.show()\n\n    return wrapper\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_epi_metrics","title":"<code>plot_metapop_epi_metrics(metapop_model: MetapopModel, axes: matplotlib.axes.Axes)</code>","text":"<p>Plots the EpiMetric data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_epi_metrics(metapop_model: MetapopModel,\n                             axes: matplotlib.axes.Axes):\n    \"\"\"\n    Plots the EpiMetric data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_epi_metrics(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_metapop_total_infected_deaths","title":"<code>plot_metapop_total_infected_deaths(metapop_model: MetapopModel, axes: matplotlib.axes.Axes)</code>","text":"<p>Plots the total infected (IP+IS+IA) and deaths data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_total_infected_deaths(metapop_model: MetapopModel,\n                                       axes: matplotlib.axes.Axes):\n    \"\"\"\n    Plots the total infected (IP+IS+IA) and deaths data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    # Iterate over subpop models and plot\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_total_infected_deaths(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_basic_compartment_history","title":"<code>plot_subpop_basic_compartment_history(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots data for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_basic_compartment_history(subpop_model: SubpopModel,\n                                          ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots data for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    for name, compartment in subpop_model.compartments.items():\n        # Compute summed history values for each age-risk group\n        history_vals_list = [np.sum(age_risk_group_entry) for\n                             age_risk_group_entry in compartment.history_vals_list]\n\n        # Plot data with a label\n        ax.plot(history_vals_list, label=name, alpha=0.6)\n\n    # Set axis title and labels\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Number of individuals\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_decorator","title":"<code>plot_subpop_decorator(plot_func)</code>","text":"<p>Decorator to handle common subpopulation plotting tasks.</p> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>def plot_subpop_decorator(plot_func):\n    \"\"\"\n    Decorator to handle common subpopulation plotting tasks.\n    \"\"\"\n\n    @functools.wraps(plot_func)\n    def wrapper(subpop_model: SubpopModel,\n                ax: matplotlib.axes.Axes = None,\n                savefig_filename: str = None):\n        \"\"\"\n        Args:\n            subpop_model (SubpopModel):\n                SubpopModel to plot.\n            ax (matplotlib.axes.Axes):\n                Matplotlib axis to plot on.\n            savefig_filename (str):\n                Optional filename to save the figure.\n        \"\"\"\n\n        ax_provided = ax\n\n        # If no axis is provided, create own axis\n        if ax is None:\n            fig, ax = plt.subplots()\n\n        plot_func(subpop_model=subpop_model, ax=ax)\n\n        if savefig_filename:\n            plt.savefig(savefig_filename, dpi=1200)\n\n        if ax_provided is None:\n            plt.show()\n\n    return wrapper\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_epi_metrics","title":"<code>plot_subpop_epi_metrics(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots EpiMetric history for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_epi_metrics(subpop_model: SubpopModel,\n                            ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots EpiMetric history for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    for name, epi_metric in subpop_model.epi_metrics.items():\n\n        # Compute summed history values for each age-risk group\n        history_vals_list = [np.average(age_risk_group_entry) for\n                             age_risk_group_entry in epi_metric.history_vals_list]\n\n        # Plot data with a label\n        ax.plot(history_vals_list, label=name, alpha=0.6)\n\n    # Set axis title and labels\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Epi Metric Value\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.plot_subpop_total_infected_deaths","title":"<code>plot_subpop_total_infected_deaths(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots data for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_toolkit/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_total_infected_deaths(subpop_model: SubpopModel,\n                                      ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots data for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    infected_compartment_names = [name for name in subpop_model.compartments.keys() if\n                                  \"I\" in name or \"H\" in name]\n\n    infected_compartments_history = [subpop_model.compartments[compartment_name].history_vals_list\n                                     for compartment_name in infected_compartment_names]\n\n    total_infected = np.sum(np.asarray(infected_compartments_history), axis=(0, 2, 3))\n\n    ax.plot(total_infected, label=\"Total infected\", alpha=0.6)\n\n    if \"D\" in subpop_model.compartments.keys():\n        deaths = [np.sum(age_risk_group_entry)\n                  for age_risk_group_entry\n                  in subpop_model.compartments.D.history_vals_list]\n\n        ax.plot(deaths, label=\"D\", alpha=0.6)\n\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Number of individuals\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_toolkit.updated_dataclass","title":"<code>updated_dataclass(original, updates)</code>","text":"Source code in <code>CLT_BaseModel/clt_toolkit/utils.py</code> <pre><code>def updated_dataclass(original, updates):\n    return replace(original, **updates)\n</code></pre>"},{"location":"flu_components_reference/","title":"Flu Core API Reference","text":"<p>Docstrings and references for <code>flu_core</code> module.</p>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.base_path","title":"<code>base_path = clt.utils.PROJECT_ROOT / 'flu_instances' / 'texas_input_files'</code>  <code>module-attribute</code>","text":""},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AbsoluteHumidity","title":"<code>AbsoluteHumidity</code>","text":"<p>               Bases: <code>Schedule</code></p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class AbsoluteHumidity(clt.Schedule):\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: pd.DataFrame = None):\n        \"\"\"\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                must have columns \"date\" and \"absolute_humidity\" --\n                \"date\" entries must correspond to consecutive calendar days\n                and must either be strings with `\"YYYY-MM-DD\"` format or\n                `datetime.date` objects -- \"value\" entries correspond to\n                absolute humidity on those days. Identical to\n                `FluSubpopSchedules` field of same name.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.timeseries_df = timeseries_df\n\n    def update_current_val(self, params, current_date: datetime.date) -&gt; None:\n        self.current_val = self.timeseries_df.loc[\n            self.timeseries_df[\"date\"] == current_date, \"absolute_humidity\"].values[0]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AbsoluteHumidity.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, timeseries_df: pd.DataFrame = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>must have columns \"date\" and \"absolute_humidity\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to absolute humidity on those days. Identical to <code>FluSubpopSchedules</code> field of same name.</p> <code>None</code> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             timeseries_df: pd.DataFrame = None):\n    \"\"\"\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            must have columns \"date\" and \"absolute_humidity\" --\n            \"date\" entries must correspond to consecutive calendar days\n            and must either be strings with `\"YYYY-MM-DD\"` format or\n            `datetime.date` objects -- \"value\" entries correspond to\n            absolute humidity on those days. Identical to\n            `FluSubpopSchedules` field of same name.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.AsympToRecovered","title":"<code>AsympToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IA\" to \"R\" compartment. The functional form is the same across subpopulations.</p> <p>Returns:</p> Type Description <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class AsympToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IA\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.IA_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.BetaReduce","title":"<code>BetaReduce</code>","text":"<p>               Bases: <code>DynamicVal</code></p> <p>\"Toy\" function representing staged-alert policy     that reduces transmission by 50% when more than 5%     of the total population is infected. Note: the     numbers are completely made up :) The \"permanent_lockdown\" toggle is to avoid \"bang-bang\"     behavior where the staged-alert policy gets triggered     one day and then is off the next, and then is on the     day after, and so on... but as the name suggests,     it IS permanent. TODO: replace with realistic function.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class BetaReduce(clt.DynamicVal):\n    \"\"\"\n    \"Toy\" function representing staged-alert policy\n        that reduces transmission by 50% when more than 5%\n        of the total population is infected. Note: the\n        numbers are completely made up :)\n    The \"permanent_lockdown\" toggle is to avoid \"bang-bang\"\n        behavior where the staged-alert policy gets triggered\n        one day and then is off the next, and then is on the\n        day after, and so on... but as the name suggests,\n        it IS permanent.\n    TODO: replace with realistic function.\n    \"\"\"\n\n    def __init__(self, init_val, is_enabled):\n        super().__init__(init_val, is_enabled)\n        self.permanent_lockdown = False\n\n    def update_current_val(self, state, params):\n        if np.sum(state.IS) / np.sum(params.total_pop_age_risk) &gt; 0.05:\n            self.current_val = .5\n            self.permanent_lockdown = True\n        else:\n            if not self.permanent_lockdown:\n                self.current_val = 0.0\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.DailyVaccines","title":"<code>DailyVaccines</code>","text":"<p>               Bases: <code>Schedule</code></p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class DailyVaccines(clt.Schedule):\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: pd.DataFrame = None):\n        \"\"\"\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                must have \"date\" and \"daily_vaccines\" -- \"date\" entries must\n                correspond to consecutive calendar days and must either\n                be strings with `\"YYYY-MM-DD\"` format or `datetime.date`\n                objects -- \"value\" entries correspond to historical\n                number vaccinated on those days. Identical to\n                `FluSubpopSchedules` field of same name.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.timeseries_df = timeseries_df\n\n    def update_current_val(self, params, current_date: datetime.date) -&gt; None:\n        self.current_val = self.timeseries_df.loc[\n            self.timeseries_df[\"date\"] == current_date, \"daily_vaccines\"].values[0]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.DailyVaccines.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, timeseries_df: pd.DataFrame = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>must have \"date\" and \"daily_vaccines\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to historical number vaccinated on those days. Identical to <code>FluSubpopSchedules</code> field of same name.</p> <code>None</code> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             timeseries_df: pd.DataFrame = None):\n    \"\"\"\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            must have \"date\" and \"daily_vaccines\" -- \"date\" entries must\n            correspond to consecutive calendar days and must either\n            be strings with `\"YYYY-MM-DD\"` format or `datetime.date`\n            objects -- \"value\" entries correspond to historical\n            number vaccinated on those days. Identical to\n            `FluSubpopSchedules` field of same name.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToAsymp","title":"<code>ExposedToAsymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"E\" to \"IA\" compartment. The functional form is the same across subpopulations.</p> <p>Each ExposedToAsymp instance forms a TransitionVariableGroup with a corresponding ExposedToPresymp instance (these two transition variables are jointly distributed).</p> <p>Returns:</p> Type Description <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class ExposedToAsymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"E\" to \"IA\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each ExposedToAsymp instance forms a TransitionVariableGroup with\n    a corresponding ExposedToPresymp instance (these two\n    transition variables are jointly distributed).\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.E_to_I_rate * params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.ExposedToPresymp","title":"<code>ExposedToPresymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"E\" to \"IP\" compartment. The functional form is the same across subpopulations.</p> <p>Each ExposedToPresymp instance forms a TransitionVariableGroup with a corresponding ExposedToAsymp instance (these two transition variables are jointly distributed).</p> <p>Returns:</p> Type Description <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class ExposedToPresymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"E\" to \"IP\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each ExposedToPresymp instance forms a TransitionVariableGroup with\n    a corresponding ExposedToAsymp instance (these two\n    transition variables are jointly distributed).\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.E_to_I_rate * (1 - params.E_to_IA_prop))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluContactMatrix","title":"<code>FluContactMatrix</code>","text":"<p>               Bases: <code>Schedule</code></p> <p>Flu contact matrix.</p> <p>Attributes:</p> Name Type Description <code>timeseries_df</code> <code>DataFrame</code> <p>must have columns \"date\", \"is_school_day\", and \"is_work_day\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> object and \"is_school_day\" and \"is_work_day\" entries are Booleans indicating if that date is a school day or work day. Identical to <code>FluSubpopSchedules</code> field of same name.</p> <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluContactMatrix(clt.Schedule):\n    \"\"\"\n    Flu contact matrix.\n\n    Attributes:\n        timeseries_df (pd.DataFrame):\n            must have columns \"date\", \"is_school_day\", and \"is_work_day\"\n            -- \"date\" entries must correspond to consecutive calendar\n            days and must either be strings with `\"YYYY-MM-DD\"` format\n            or `datetime.date` object and \"is_school_day\" and\n            \"is_work_day\" entries are Booleans indicating if that date is\n            a school day or work day. Identical to `FluSubpopSchedules` field\n            of same name.\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: pd.DataFrame = None):\n\n        super().__init__(init_val)\n\n        self.timeseries_df = timeseries_df\n\n    def update_current_val(self,\n                           subpop_params: FluSubpopParams,\n                           current_date: datetime.date) -&gt; None:\n\n        df = self.timeseries_df\n\n        try:\n            current_row = df[df[\"date\"] == current_date].iloc[0]\n            self.current_val = subpop_params.total_contact_matrix - \\\n                               (1 - current_row[\"is_school_day\"]) * subpop_params.school_contact_matrix - \\\n                               (1 - current_row[\"is_work_day\"]) * subpop_params.work_contact_matrix\n        except IndexError:\n            # print(f\"Error: {current_date} is not in `timeseries_df`. Using total contact matrix.\")\n            self.current_val = subpop_params.total_contact_matrix\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluFullMetapopParamsTensors","title":"<code>FluFullMetapopParamsTensors</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FluTravelParamsTensors</code></p> <p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from parameters on each location/subpopulation model, as well as from the metapopulation's associated <code>FluMixingParams</code> instance). Note that in contrast to <code>FluTravelParamsTensors</code>, ALL fields in <code>FluSubpopParams</code> are included -- this is for running the simulation via torch.</p> <p>Attributes:</p> Name Type Description <code>num_locations</code> <code>(Tensor, 0 - dimensional)</code> <p>number of locations (subpopulations) in the metapopulation model and therefore the travel model.</p> <code>travel_proportions</code> <code>Tensor</code> <p>L x L array, where L is the number of locations or subpopulations, where element i,j corresponds to the proportion of the population in location i who travels to location j (on average).</p> <p>See <code>FluSubpopParams</code> docstring for other attributes. Other fields are analogous except they are size (L, A, R) tensors or size 0 tensors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluFullMetapopParamsTensors(FluTravelParamsTensors):\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays that\n    contain data across all subpopulations (collected from parameters\n    on each location/subpopulation model, as well as from the\n    metapopulation's associated `FluMixingParams` instance).\n    Note that in contrast to `FluTravelParamsTensors`,\n    ALL fields in `FluSubpopParams` are included --\n    this is for running the simulation via torch.\n\n    Attributes:\n        num_locations (torch.Tensor, 0-dimensional):\n            number of locations (subpopulations) in the\n            metapopulation model and therefore the travel\n            model.\n        travel_proportions (torch.Tensor):\n            L x L array, where L is the number of locations\n            or subpopulations, where element i,j corresponds\n            to the proportion of the population in location i\n            who travels to location j (on average).\n\n    See `FluSubpopParams` docstring for other attributes.\n    Other fields are analogous except they are size (L, A, R)\n    tensors or size 0 tensors.\n    \"\"\"\n\n    beta_baseline: Optional[torch.Tensor] = None\n    total_pop_age_risk: Optional[torch.Tensor] = None\n    humidity_impact: Optional[torch.Tensor] = None\n\n    inf_induced_saturation: Optional[torch.Tensor] = None\n    inf_induced_immune_wane: Optional[torch.Tensor] = None\n    vax_induced_saturation: Optional[torch.Tensor] = None\n    vax_induced_immune_wane: Optional[torch.Tensor] = None\n    inf_induced_inf_risk_reduce: Optional[torch.Tensor] = None\n    inf_induced_hosp_risk_reduce: Optional[torch.Tensor] = None\n    inf_induced_death_risk_reduce: Optional[torch.Tensor] = None\n    vax_induced_inf_risk_reduce: Optional[torch.Tensor] = None\n    vax_induced_hosp_risk_reduce: Optional[torch.Tensor] = None\n    vax_induced_death_risk_reduce: Optional[torch.Tensor] = None\n\n    R_to_S_rate: Optional[torch.Tensor] = None\n    E_to_I_rate: Optional[torch.Tensor] = None\n    IP_to_IS_rate: Optional[torch.Tensor] = None\n    IS_to_R_rate: Optional[torch.Tensor] = None\n    IA_to_R_rate: Optional[torch.Tensor] = None\n    IS_to_H_rate: Optional[torch.Tensor] = None\n    H_to_R_rate: Optional[torch.Tensor] = None\n    H_to_D_rate: Optional[torch.Tensor] = None\n    E_to_IA_prop: Optional[torch.Tensor] = None\n\n    IS_to_H_adjusted_prop: Optional[torch.Tensor] = None\n    H_to_D_adjusted_prop: Optional[torch.Tensor] = None\n\n    IP_relative_inf: Optional[torch.Tensor] = None\n    IA_relative_inf: Optional[torch.Tensor] = None\n\n    relative_suscept: Optional[torch.Tensor] = None\n    mobility_modifier: Optional[torch.Tensor] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluFullMetapopScheduleTensors","title":"<code>FluFullMetapopScheduleTensors</code>  <code>dataclass</code>","text":"Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluFullMetapopScheduleTensors:\n\n    absolute_humidity: Optional[list[torch.tensor]] = None\n    is_school_day: Optional[list[torch.tensor]] = None\n    is_work_day: Optional[list[torch.tensor]] = None\n    daily_vaccines: Optional[list[torch.tensor]] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluFullMetapopStateTensors","title":"<code>FluFullMetapopStateTensors</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FluTravelStateTensors</code></p> <p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from each location/subpopulation model). In contrast to <code>FluTravelStateTensors</code>, ALL fields in <code>FluSubpopState</code> are included -- this is for running the simulation via torch.</p> <p>Attributes:</p> Name Type Description <code>flu_contact_matrix</code> <code>torch.Tensor of nonnegative integers</code> <p>contact matrix for location-age-risk groups -- the lth element holds current_val of <code>FluContactMatrix</code> <code>Schedule</code> for subpopulation l -- this value is a combination of the total contact matrix, the work contact matrix, and the school contact matrix (and the value is adjusted depending on whether the date is a work or school day)</p> <code>init_vals</code> <code>dict</code> <p>dictionary of torch.Tensor instances, where keys correspond to \"IP\", \"IS\", \"IA\", and \"H\", and values correspond to their initial values for location-age-risk groups.</p> <p>See <code>FluSubpopState</code> and <code>FluTravelStateTensors</code> for other     attributes -- other attributes here correspond to     <code>FluSubpopState</code>, but are size (L, A, R) tensors for     location-age-risk or size 0 tensors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluFullMetapopStateTensors(FluTravelStateTensors):\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays that\n    contain data across all subpopulations (collected from each\n    location/subpopulation model). In contrast to `FluTravelStateTensors`,\n    ALL fields in `FluSubpopState` are included -- this is\n    for running the simulation via torch.\n\n    Attributes:\n        flu_contact_matrix (torch.Tensor of nonnegative integers):\n            contact matrix for location-age-risk groups -- the\n            lth element holds current_val of `FluContactMatrix`\n            `Schedule` for subpopulation l -- this value is a\n            combination of the total contact matrix, the\n            work contact matrix, and the school contact matrix\n            (and the value is adjusted depending on whether\n            the date is a work or school day)\n        init_vals (dict):\n            dictionary of torch.Tensor instances, where keys\n            correspond to \"IP\", \"IS\", \"IA\", and \"H\", and values\n            correspond to their initial values for location-age-risk\n            groups.\n\n    See `FluSubpopState` and `FluTravelStateTensors` for other\n        attributes -- other attributes here correspond to\n        `FluSubpopState`, but are size (L, A, R) tensors for\n        location-age-risk or size 0 tensors.\n    \"\"\"\n\n    # `IP`, `IS`, `IA`, `H`, `flu_contact_matrix` already in\n    #   parent class\n    # Same with `init_vals`\n\n    S: Optional[torch.Tensor] = None\n    E: Optional[torch.Tensor] = None\n    R: Optional[torch.Tensor] = None\n    D: Optional[torch.Tensor] = None\n\n    M: Optional[torch.Tensor] = None\n    MV: Optional[torch.Tensor] = None\n\n    absolute_humidity: Optional[float] = None\n    daily_vaccines: Optional[torch.Tensor] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel","title":"<code>FluMetapopModel</code>","text":"<p>               Bases: <code>MetapopModel</code>, <code>ABC</code></p> <p>MetapopModel-derived class specific to flu model.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluMetapopModel(clt.MetapopModel, ABC):\n    \"\"\"\n    MetapopModel-derived class specific to flu model.\n    \"\"\"\n\n    def __init__(self,\n                 subpop_models: list[dict],\n                 mixing_params: FluMixingParams,\n                 name: str = \"\"):\n\n        super().__init__(subpop_models,\n                         mixing_params,\n                         name)\n\n        # Confirm validity and consistency of `FluMixingParams`\n        try:\n            num_locations = mixing_params.num_locations\n        except KeyError:\n            raise FluMetapopModelError(\"'mixing_params' must contain the key 'num_locations'. \\n\"\n                                       \"Please specify it before continuing.\")\n        if num_locations != len(subpop_models):\n            raise FluMetapopModelError(\"'num_locations' should equal the number of items in \\n\"\n                                       \"'subpop_models'. Please amend before continuing.\")\n\n        self.travel_state_tensors = FluTravelStateTensors()\n        self.update_travel_state_tensors()\n\n        # `FluMixingParams` info is stored on `FluTravelParamsTensors` --\n        # this order of operations below is important, because\n        # `mixing_params` attribute must be defined before `update_travel_params_tensors()`\n        # is called.\n        self.mixing_params = mixing_params\n        self.travel_params_tensors = FluTravelParamsTensors()\n        self.update_travel_params_tensors()\n\n        total_pop_LAR_tensor = self.compute_total_pop_LAR_tensor()\n\n        self.precomputed = FluPrecomputedTensors(total_pop_LAR_tensor,\n                                                 self.travel_params_tensors)\n\n        # Generally not used unless using torch version\n        self._full_metapop_params_tensors = None\n        self._full_metapop_state_tensors = None\n        self._full_metapop_schedule_tensors = None\n\n    def modify_mixing_params(self,\n                             updates_dict: dict):\n        \"\"\"\n        `FluMixingParams` is a frozen dataclass to avoid users\n        naively changing parameter values and getting undesirable results.\n\n        This method lets users safely modify a `FluMixingParams` field;\n        the metapopulation-wide tensors are updated automatically afterward.\n\n        Parameters:\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `FluSubpopParams` instance -- keys must match the\n                field names of `FluSubpopParams`. \n        \"\"\"\n\n        self.mixing_params = clt.updated_dataclass(self.mixing_params, updates_dict)\n        self.update_travel_params_tensors()\n\n        nonlocal_travel_prop = self.travel_params_tensors.travel_proportions.clone().fill_diagonal_(0.0)\n\n        self.precomputed.sum_residents_nonlocal_travel_prop = nonlocal_travel_prop.sum(dim=1)\n\n        # Adding this for extra safety in case the user does not\n        # call `get_flu_torch_inputs` for accessing the\n        # `FullMetapopParams` instance.\n\n        # If this attribute is not `None`, it means we are using\n        # the `torch` implementation, and we should update the\n        # corresponding `FullMetapopParams` instance with the new\n        # `FluMixingParams` values.\n        if self._full_metapop_params_tensors:\n            self.update_full_metapop_params_tensors()\n\n    def compute_total_pop_LAR_tensor(self) -&gt; torch.tensor:\n        \"\"\"\n        For each subpopulation, sum initial values of population\n        in each compartment for age-risk groups. Store all information\n        as tensor and return tensor.\n\n        Returns:\n            torch.tensor of size (L, A, R):\n                Total population (across all compartments) for\n                location-age-risk (l, a, r).\n        \"\"\"\n\n        # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n        #   to preserve correct index order in tensors!\n        #   See `update_travel_params_tensors` for detailed note.\n        subpop_models_ordered = self._subpop_models_ordered\n\n        total_pop_LAR_tensor = torch.zeros(self.travel_params_tensors.num_locations,\n                                           self.travel_params_tensors.num_age_groups,\n                                           self.travel_params_tensors.num_risk_groups)\n\n        # All subpop models should have the same compartments' keys\n        for name in subpop_models_ordered[0].compartments.keys():\n\n            metapop_vals = []\n\n            for model in subpop_models_ordered.values():\n                compartment = getattr(model.compartments, name)\n                metapop_vals.append(compartment.current_val)\n\n            total_pop_LAR_tensor = total_pop_LAR_tensor + torch.tensor(np.asarray(metapop_vals))\n\n        return total_pop_LAR_tensor\n\n    def update_state_tensors(self,\n                             target: FluTravelStateTensors) -&gt; None:\n        \"\"\"\n        Update `target` instance in-place with current simulation\n        values. Each field of `target` corresponds to a field in\n        `FluSubpopState`, and contains either a tensor of size\n        (L, A, R) or a tensor of size (L), where (l, a, r) refers to\n        location-age-risk.\n        \"\"\"\n\n        # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n        #   to preserve correct index order in tensors!\n        #   See `update_travel_params_tensors` for detailed note.\n        subpop_models_ordered = self._subpop_models_ordered\n\n        for field in fields(target):\n\n            name = field.name\n\n            # FluTravelStateTensors has an attribute\n            #   that is a dictionary called `init_vals` --\n            #   disregard, as this only used to store\n            #   initial values for resetting, but is not\n            #   used in the travel model computation\n            if name == \"init_vals\":\n                continue\n\n            metapop_vals = []\n\n            for model in subpop_models_ordered.values():\n                current_val = getattr(model.state, name)\n                metapop_vals.append(current_val)\n\n            # Probably want to update this to be cleaner...\n            # `SubpopState` fields that correspond to `Schedule` instances\n            # have initial values of `None` -- but we cannot build a tensor\n            # with `None` values, so we convert values to 0s.\n            if any(v is None for v in metapop_vals):\n                setattr(target, name, torch.tensor(np.full(np.shape(metapop_vals), 0.0)))\n            else:\n                setattr(target, name, torch.tensor(np.asarray(metapop_vals)))\n\n            # Only fields corresponding to `Schedule` instances can be\n            # size (L) -- this is because the schedule value may be scalar for\n            # each subpopulation. Other fields should all be size (L, A, R). \n\n    def update_travel_state_tensors(self) -&gt; None:\n        \"\"\"\n        Update `travel_state_tensors` attribute in-place.\n        `FluTravelStateTensors` only has fields corresponding\n        to state variables relevant for the travel model.\n        Converts subpopulation-specific state to\n        tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        self.update_state_tensors(self.travel_state_tensors)\n\n    def update_full_metapop_state_tensors(self) -&gt; None:\n        \"\"\"\n        Update `_full_metapop_state_tensors` attribute in-place.\n        `FluFullMetapopStateTensors` has fields corresponding\n        to all state variables in the simulation.\n        Converts subpopulation-specific state to\n        tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        if self._full_metapop_state_tensors is None:\n            self._full_metapop_state_tensors = FluFullMetapopStateTensors()\n        self.update_state_tensors(self._full_metapop_state_tensors)\n\n    def update_params_tensors(self,\n                              target: FluTravelParamsTensors) -&gt; FluTravelParamsTensors:\n        \"\"\"\n        Update `target` in-place. Converts subpopulation-specific\n        parameters to tensors of size (L, A, R) for location-age-risk,\n        except for `num_locations` and `travel_proportions`, which\n        have size 1 and (L, L) respectively.\n        \"\"\"\n\n        # USE THE ORDERED DICTIONARY HERE FOR SAFETY!\n        #   AGAIN, ORDER MATTERS BECAUSE ORDER DETERMINES\n        #   THE SUBPOPULATION INDEX IN THE METAPOPULATION\n        #   TENSOR!\n        subpop_models_ordered = self._subpop_models_ordered\n\n        for field in fields(target):\n\n            name = field.name\n\n            metapop_vals = []\n\n            if name == \"num_locations\" or name == \"travel_proportions\":\n                setattr(target, name, torch.tensor(getattr(self.mixing_params, name)))\n\n            else:\n                for model in subpop_models_ordered.values():\n                    metapop_vals.append(getattr(model.params, name))\n\n                # If all values are equal to each other, then\n                #   simply store the first value (since its value is common\n                #   across metapopulations)\n                first_val = metapop_vals[0]\n                if all(np.allclose(x, first_val) for x in metapop_vals):\n                    metapop_vals = first_val\n\n                # Converting list of arrays to tensors is slow --\n                #   better to convert to array first\n                if isinstance(metapop_vals, list):\n                    metapop_vals = np.array(metapop_vals)\n\n                setattr(target, name, torch.tensor(metapop_vals))\n\n        # Convert all tensors to correct size!\n        target.standardize_shapes()\n\n    def update_travel_params_tensors(self) -&gt; None:\n        \"\"\"\n        Update `travel_params_tensors` attribute in-place.\n        `FluTravelParamsTensors` only has fields corresponding\n        to parameters relevant for the travel model.\n        Converts subpopulation-specific parameters to\n        tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        self.update_params_tensors(target=self.travel_params_tensors)\n\n    def update_full_metapop_params_tensors(self) -&gt; None:\n        \"\"\"\n        Update `_full_metapop_params_tensors` attribute in-place.\n        `FluFullMetapopParamsTensors` has fields corresponding\n        to all parameters in the simulation. Converts subpopulation-specific\n        parameters to tensors of size (L, A, R) for location-age-risk\n        (except for a few exceptions that have different dimensions).\n        \"\"\"\n\n        if self._full_metapop_params_tensors is None:\n            self._full_metapop_params_tensors = FluFullMetapopParamsTensors()\n        self.update_params_tensors(target=self._full_metapop_params_tensors)\n\n    def apply_inter_subpop_updates(self) -&gt; None:\n        \"\"\"\n        Update the `FluTravelStateTensors` according to the simulation state\n        and compute the total mixing exposure, which includes across-subpopulation\n        mixing/travel. Update the `total_mixing_exposure` attribute on each\n        subpopulation's `SusceptibleToExposed` instance accordingly, so each\n        of these transition variables can compute its transition rate.\n\n        See `apply_inter_subpop_updates` on `MetapopModel` base class\n        for logic of how/when this is called in the simulation.\n        \"\"\"\n\n        self.update_travel_state_tensors()\n\n        total_mixing_exposure = compute_total_mixing_exposure(self.travel_state_tensors,\n                                                              self.travel_params_tensors,\n                                                              self.precomputed)\n\n        # Again, `self.subpop_models` is an ordered dictionary --\n        #   so iterating over the dictionary like this is well-defined\n        #   and responsible -- the order is important because it\n        #   determines the order (index) in any metapopulation tensors\n        subpop_models = self._subpop_models_ordered\n\n        # Updates `total_mixing_exposure` attribute on each `SusceptibleToExposed`\n        # instance -- this value captures across-population travel/mixing.\n        for i in range(len(subpop_models)):\n            subpop_models.values()[i].transition_variables.S_to_E.total_mixing_exposure = \\\n                total_mixing_exposure[i, :, :]\n\n    def setup_full_metapop_schedule_tensors(self):\n        \"\"\"\n        Creates `FluFullMetapopScheduleTensors` instance and assigns to\n        `_full_metapop_schedule_tensors` attribute.\n\n        For the metapopulation model's L locations/subpopulations, for each day,\n        each value-related column in each schedule is either a float or\n        array of size (A, R) for age-risk groups.\n\n        We aggregate and reformat this schedule information and put it\n        into a `FluFullMetapopScheduleTensors` instance, where fields\n        correspond to a schedule value, and values are lists of tensors of\n        size (L, A, R). The ith element of each list corresponds to the\n        ith simulation day.\n        \"\"\"\n\n        self._full_metapop_schedule_tensors = FluFullMetapopScheduleTensors()\n\n        L = self.precomputed.L\n        A = self.precomputed.A\n        R = self.precomputed.R\n\n        # Note: there is probably a more consistent way to do this,\n        # because now `flu_contact_matrix` has two values: \"is_school_day\"\n        # and \"is_work_day\" -- other schedules' dataframes only have one\n        # relevant column value rather than two\n        for item in [(\"absolute_humidity\", \"absolute_humidity\"),\n                     (\"flu_contact_matrix\", \"is_school_day\"),\n                     (\"flu_contact_matrix\", \"is_work_day\"),\n                     (\"daily_vaccines\", \"daily_vaccines\")]:\n\n            schedule_name = item[0]\n            values_column_name = item[1]\n\n            metapop_vals = []\n\n            for subpop_model in self._subpop_models_ordered.values():\n                df = subpop_model.schedules[schedule_name].timeseries_df\n\n                # Using the `start_real_date` specification given in subpop's `SimulationSettings`,\n                # extract the relevant part of the dataframe with dates &gt;= the simulation start date.\n                # Note that `start_real_date` should be the same for each subpopulation\n                start_date = datetime.datetime.strptime(subpop_model.simulation_settings.start_real_date, \"%Y-%m-%d\")\n                df[\"simulation_day\"] = (pd.to_datetime(df[\"date\"], format=\"%Y-%m-%d\") - start_date).dt.days\n                df = df[df[\"simulation_day\"] &gt;= 0]\n\n                # Make each day's value an A x R array\n                # Pandas complains about `SettingWithCopyWarning` so we work on a copy explicitly to stop it\n                #   from complaining...\n                df = df.copy()\n                df[values_column_name] = df[values_column_name].astype(object)\n                df.loc[:, values_column_name] = df[values_column_name].apply(\n                    lambda x, A=A, R=R: np.broadcast_to(np.asarray(x).reshape(1, 1), (A, R))\n                )\n\n                metapop_vals.append(np.asarray(df[values_column_name]))\n\n            # IMPORTANT: tedious array/tensor shape/size manipulation here\n            # metapop_vals: list of L arrays, each shape (num_days, A, R)\n            # We need to transpose this... to be a list of num_days tensors, of size L x A x R\n            num_items = metapop_vals[0].shape[0]\n\n            # This is ugly and inefficient -- but at least we only do this once, when we get the initial\n            #   state of a metapopulation model in tensor form\n            transposed_metapop_vals = [torch.tensor(np.array([metapop_vals[l][i] for l in range(L)])) for i in\n                                       range(num_items)]\n\n            setattr(self._full_metapop_schedule_tensors, values_column_name, transposed_metapop_vals)\n\n    def get_flu_torch_inputs(self) -&gt; dict:\n        \"\"\"\n        Prepares and returns metapopulation simulation data in tensor format\n        that can be directly used for `torch` implementation.\n\n        Returns:\n             d (dict):\n                Has keys \"state_tensors\", \"params_tensors\", \"schedule_tensors\",\n                and \"precomputed\". Corresponds to `FluFullMetapopStateTensors`,\n                `FluFullMetapopParamsTensors`, `FluFullMetapopScheduleTensors`,\n                and `FluPrecomputedTensors` instances respectively.\n        \"\"\"\n\n        self.update_full_metapop_state_tensors()\n        self.update_full_metapop_params_tensors()\n        self._full_metapop_params_tensors.standardize_shapes()\n        self.setup_full_metapop_schedule_tensors()\n\n        d = {}\n\n        d[\"state_tensors\"] = copy.deepcopy(self._full_metapop_state_tensors)\n        d[\"params_tensors\"] = copy.deepcopy(self._full_metapop_params_tensors)\n        d[\"schedule_tensors\"] = copy.deepcopy(self._full_metapop_schedule_tensors)\n        d[\"precomputed\"] = copy.deepcopy(self.precomputed)\n\n        return d\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.apply_inter_subpop_updates","title":"<code>apply_inter_subpop_updates() -&gt; None</code>","text":"<p>Update the <code>FluTravelStateTensors</code> according to the simulation state and compute the total mixing exposure, which includes across-subpopulation mixing/travel. Update the <code>total_mixing_exposure</code> attribute on each subpopulation's <code>SusceptibleToExposed</code> instance accordingly, so each of these transition variables can compute its transition rate.</p> <p>See <code>apply_inter_subpop_updates</code> on <code>MetapopModel</code> base class for logic of how/when this is called in the simulation.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def apply_inter_subpop_updates(self) -&gt; None:\n    \"\"\"\n    Update the `FluTravelStateTensors` according to the simulation state\n    and compute the total mixing exposure, which includes across-subpopulation\n    mixing/travel. Update the `total_mixing_exposure` attribute on each\n    subpopulation's `SusceptibleToExposed` instance accordingly, so each\n    of these transition variables can compute its transition rate.\n\n    See `apply_inter_subpop_updates` on `MetapopModel` base class\n    for logic of how/when this is called in the simulation.\n    \"\"\"\n\n    self.update_travel_state_tensors()\n\n    total_mixing_exposure = compute_total_mixing_exposure(self.travel_state_tensors,\n                                                          self.travel_params_tensors,\n                                                          self.precomputed)\n\n    # Again, `self.subpop_models` is an ordered dictionary --\n    #   so iterating over the dictionary like this is well-defined\n    #   and responsible -- the order is important because it\n    #   determines the order (index) in any metapopulation tensors\n    subpop_models = self._subpop_models_ordered\n\n    # Updates `total_mixing_exposure` attribute on each `SusceptibleToExposed`\n    # instance -- this value captures across-population travel/mixing.\n    for i in range(len(subpop_models)):\n        subpop_models.values()[i].transition_variables.S_to_E.total_mixing_exposure = \\\n            total_mixing_exposure[i, :, :]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.compute_total_pop_LAR_tensor","title":"<code>compute_total_pop_LAR_tensor() -&gt; torch.tensor</code>","text":"<p>For each subpopulation, sum initial values of population in each compartment for age-risk groups. Store all information as tensor and return tensor.</p> <p>Returns:</p> Type Description <code>tensor</code> <p>torch.tensor of size (L, A, R): Total population (across all compartments) for location-age-risk (l, a, r).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def compute_total_pop_LAR_tensor(self) -&gt; torch.tensor:\n    \"\"\"\n    For each subpopulation, sum initial values of population\n    in each compartment for age-risk groups. Store all information\n    as tensor and return tensor.\n\n    Returns:\n        torch.tensor of size (L, A, R):\n            Total population (across all compartments) for\n            location-age-risk (l, a, r).\n    \"\"\"\n\n    # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n    #   to preserve correct index order in tensors!\n    #   See `update_travel_params_tensors` for detailed note.\n    subpop_models_ordered = self._subpop_models_ordered\n\n    total_pop_LAR_tensor = torch.zeros(self.travel_params_tensors.num_locations,\n                                       self.travel_params_tensors.num_age_groups,\n                                       self.travel_params_tensors.num_risk_groups)\n\n    # All subpop models should have the same compartments' keys\n    for name in subpop_models_ordered[0].compartments.keys():\n\n        metapop_vals = []\n\n        for model in subpop_models_ordered.values():\n            compartment = getattr(model.compartments, name)\n            metapop_vals.append(compartment.current_val)\n\n        total_pop_LAR_tensor = total_pop_LAR_tensor + torch.tensor(np.asarray(metapop_vals))\n\n    return total_pop_LAR_tensor\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.get_flu_torch_inputs","title":"<code>get_flu_torch_inputs() -&gt; dict</code>","text":"<p>Prepares and returns metapopulation simulation data in tensor format that can be directly used for <code>torch</code> implementation.</p> <p>Returns:</p> Name Type Description <code>d</code> <code>dict</code> <p>Has keys \"state_tensors\", \"params_tensors\", \"schedule_tensors\", and \"precomputed\". Corresponds to <code>FluFullMetapopStateTensors</code>, <code>FluFullMetapopParamsTensors</code>, <code>FluFullMetapopScheduleTensors</code>, and <code>FluPrecomputedTensors</code> instances respectively.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_flu_torch_inputs(self) -&gt; dict:\n    \"\"\"\n    Prepares and returns metapopulation simulation data in tensor format\n    that can be directly used for `torch` implementation.\n\n    Returns:\n         d (dict):\n            Has keys \"state_tensors\", \"params_tensors\", \"schedule_tensors\",\n            and \"precomputed\". Corresponds to `FluFullMetapopStateTensors`,\n            `FluFullMetapopParamsTensors`, `FluFullMetapopScheduleTensors`,\n            and `FluPrecomputedTensors` instances respectively.\n    \"\"\"\n\n    self.update_full_metapop_state_tensors()\n    self.update_full_metapop_params_tensors()\n    self._full_metapop_params_tensors.standardize_shapes()\n    self.setup_full_metapop_schedule_tensors()\n\n    d = {}\n\n    d[\"state_tensors\"] = copy.deepcopy(self._full_metapop_state_tensors)\n    d[\"params_tensors\"] = copy.deepcopy(self._full_metapop_params_tensors)\n    d[\"schedule_tensors\"] = copy.deepcopy(self._full_metapop_schedule_tensors)\n    d[\"precomputed\"] = copy.deepcopy(self.precomputed)\n\n    return d\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.modify_mixing_params","title":"<code>modify_mixing_params(updates_dict: dict)</code>","text":"<p><code>FluMixingParams</code> is a frozen dataclass to avoid users naively changing parameter values and getting undesirable results.</p> <p>This method lets users safely modify a <code>FluMixingParams</code> field; the metapopulation-wide tensors are updated automatically afterward.</p> <p>Parameters:</p> Name Type Description Default <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>FluSubpopParams</code> instance -- keys must match the field names of <code>FluSubpopParams</code>.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def modify_mixing_params(self,\n                         updates_dict: dict):\n    \"\"\"\n    `FluMixingParams` is a frozen dataclass to avoid users\n    naively changing parameter values and getting undesirable results.\n\n    This method lets users safely modify a `FluMixingParams` field;\n    the metapopulation-wide tensors are updated automatically afterward.\n\n    Parameters:\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `FluSubpopParams` instance -- keys must match the\n            field names of `FluSubpopParams`. \n    \"\"\"\n\n    self.mixing_params = clt.updated_dataclass(self.mixing_params, updates_dict)\n    self.update_travel_params_tensors()\n\n    nonlocal_travel_prop = self.travel_params_tensors.travel_proportions.clone().fill_diagonal_(0.0)\n\n    self.precomputed.sum_residents_nonlocal_travel_prop = nonlocal_travel_prop.sum(dim=1)\n\n    # Adding this for extra safety in case the user does not\n    # call `get_flu_torch_inputs` for accessing the\n    # `FullMetapopParams` instance.\n\n    # If this attribute is not `None`, it means we are using\n    # the `torch` implementation, and we should update the\n    # corresponding `FullMetapopParams` instance with the new\n    # `FluMixingParams` values.\n    if self._full_metapop_params_tensors:\n        self.update_full_metapop_params_tensors()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.setup_full_metapop_schedule_tensors","title":"<code>setup_full_metapop_schedule_tensors()</code>","text":"<p>Creates <code>FluFullMetapopScheduleTensors</code> instance and assigns to <code>_full_metapop_schedule_tensors</code> attribute.</p> <p>For the metapopulation model's L locations/subpopulations, for each day, each value-related column in each schedule is either a float or array of size (A, R) for age-risk groups.</p> <p>We aggregate and reformat this schedule information and put it into a <code>FluFullMetapopScheduleTensors</code> instance, where fields correspond to a schedule value, and values are lists of tensors of size (L, A, R). The ith element of each list corresponds to the ith simulation day.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def setup_full_metapop_schedule_tensors(self):\n    \"\"\"\n    Creates `FluFullMetapopScheduleTensors` instance and assigns to\n    `_full_metapop_schedule_tensors` attribute.\n\n    For the metapopulation model's L locations/subpopulations, for each day,\n    each value-related column in each schedule is either a float or\n    array of size (A, R) for age-risk groups.\n\n    We aggregate and reformat this schedule information and put it\n    into a `FluFullMetapopScheduleTensors` instance, where fields\n    correspond to a schedule value, and values are lists of tensors of\n    size (L, A, R). The ith element of each list corresponds to the\n    ith simulation day.\n    \"\"\"\n\n    self._full_metapop_schedule_tensors = FluFullMetapopScheduleTensors()\n\n    L = self.precomputed.L\n    A = self.precomputed.A\n    R = self.precomputed.R\n\n    # Note: there is probably a more consistent way to do this,\n    # because now `flu_contact_matrix` has two values: \"is_school_day\"\n    # and \"is_work_day\" -- other schedules' dataframes only have one\n    # relevant column value rather than two\n    for item in [(\"absolute_humidity\", \"absolute_humidity\"),\n                 (\"flu_contact_matrix\", \"is_school_day\"),\n                 (\"flu_contact_matrix\", \"is_work_day\"),\n                 (\"daily_vaccines\", \"daily_vaccines\")]:\n\n        schedule_name = item[0]\n        values_column_name = item[1]\n\n        metapop_vals = []\n\n        for subpop_model in self._subpop_models_ordered.values():\n            df = subpop_model.schedules[schedule_name].timeseries_df\n\n            # Using the `start_real_date` specification given in subpop's `SimulationSettings`,\n            # extract the relevant part of the dataframe with dates &gt;= the simulation start date.\n            # Note that `start_real_date` should be the same for each subpopulation\n            start_date = datetime.datetime.strptime(subpop_model.simulation_settings.start_real_date, \"%Y-%m-%d\")\n            df[\"simulation_day\"] = (pd.to_datetime(df[\"date\"], format=\"%Y-%m-%d\") - start_date).dt.days\n            df = df[df[\"simulation_day\"] &gt;= 0]\n\n            # Make each day's value an A x R array\n            # Pandas complains about `SettingWithCopyWarning` so we work on a copy explicitly to stop it\n            #   from complaining...\n            df = df.copy()\n            df[values_column_name] = df[values_column_name].astype(object)\n            df.loc[:, values_column_name] = df[values_column_name].apply(\n                lambda x, A=A, R=R: np.broadcast_to(np.asarray(x).reshape(1, 1), (A, R))\n            )\n\n            metapop_vals.append(np.asarray(df[values_column_name]))\n\n        # IMPORTANT: tedious array/tensor shape/size manipulation here\n        # metapop_vals: list of L arrays, each shape (num_days, A, R)\n        # We need to transpose this... to be a list of num_days tensors, of size L x A x R\n        num_items = metapop_vals[0].shape[0]\n\n        # This is ugly and inefficient -- but at least we only do this once, when we get the initial\n        #   state of a metapopulation model in tensor form\n        transposed_metapop_vals = [torch.tensor(np.array([metapop_vals[l][i] for l in range(L)])) for i in\n                                   range(num_items)]\n\n        setattr(self._full_metapop_schedule_tensors, values_column_name, transposed_metapop_vals)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_full_metapop_params_tensors","title":"<code>update_full_metapop_params_tensors() -&gt; None</code>","text":"<p>Update <code>_full_metapop_params_tensors</code> attribute in-place. <code>FluFullMetapopParamsTensors</code> has fields corresponding to all parameters in the simulation. Converts subpopulation-specific parameters to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_full_metapop_params_tensors(self) -&gt; None:\n    \"\"\"\n    Update `_full_metapop_params_tensors` attribute in-place.\n    `FluFullMetapopParamsTensors` has fields corresponding\n    to all parameters in the simulation. Converts subpopulation-specific\n    parameters to tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    if self._full_metapop_params_tensors is None:\n        self._full_metapop_params_tensors = FluFullMetapopParamsTensors()\n    self.update_params_tensors(target=self._full_metapop_params_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_full_metapop_state_tensors","title":"<code>update_full_metapop_state_tensors() -&gt; None</code>","text":"<p>Update <code>_full_metapop_state_tensors</code> attribute in-place. <code>FluFullMetapopStateTensors</code> has fields corresponding to all state variables in the simulation. Converts subpopulation-specific state to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_full_metapop_state_tensors(self) -&gt; None:\n    \"\"\"\n    Update `_full_metapop_state_tensors` attribute in-place.\n    `FluFullMetapopStateTensors` has fields corresponding\n    to all state variables in the simulation.\n    Converts subpopulation-specific state to\n    tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    if self._full_metapop_state_tensors is None:\n        self._full_metapop_state_tensors = FluFullMetapopStateTensors()\n    self.update_state_tensors(self._full_metapop_state_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_params_tensors","title":"<code>update_params_tensors(target: FluTravelParamsTensors) -&gt; FluTravelParamsTensors</code>","text":"<p>Update <code>target</code> in-place. Converts subpopulation-specific parameters to tensors of size (L, A, R) for location-age-risk, except for <code>num_locations</code> and <code>travel_proportions</code>, which have size 1 and (L, L) respectively.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_params_tensors(self,\n                          target: FluTravelParamsTensors) -&gt; FluTravelParamsTensors:\n    \"\"\"\n    Update `target` in-place. Converts subpopulation-specific\n    parameters to tensors of size (L, A, R) for location-age-risk,\n    except for `num_locations` and `travel_proportions`, which\n    have size 1 and (L, L) respectively.\n    \"\"\"\n\n    # USE THE ORDERED DICTIONARY HERE FOR SAFETY!\n    #   AGAIN, ORDER MATTERS BECAUSE ORDER DETERMINES\n    #   THE SUBPOPULATION INDEX IN THE METAPOPULATION\n    #   TENSOR!\n    subpop_models_ordered = self._subpop_models_ordered\n\n    for field in fields(target):\n\n        name = field.name\n\n        metapop_vals = []\n\n        if name == \"num_locations\" or name == \"travel_proportions\":\n            setattr(target, name, torch.tensor(getattr(self.mixing_params, name)))\n\n        else:\n            for model in subpop_models_ordered.values():\n                metapop_vals.append(getattr(model.params, name))\n\n            # If all values are equal to each other, then\n            #   simply store the first value (since its value is common\n            #   across metapopulations)\n            first_val = metapop_vals[0]\n            if all(np.allclose(x, first_val) for x in metapop_vals):\n                metapop_vals = first_val\n\n            # Converting list of arrays to tensors is slow --\n            #   better to convert to array first\n            if isinstance(metapop_vals, list):\n                metapop_vals = np.array(metapop_vals)\n\n            setattr(target, name, torch.tensor(metapop_vals))\n\n    # Convert all tensors to correct size!\n    target.standardize_shapes()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_state_tensors","title":"<code>update_state_tensors(target: FluTravelStateTensors) -&gt; None</code>","text":"<p>Update <code>target</code> instance in-place with current simulation values. Each field of <code>target</code> corresponds to a field in <code>FluSubpopState</code>, and contains either a tensor of size (L, A, R) or a tensor of size (L), where (l, a, r) refers to location-age-risk.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_state_tensors(self,\n                         target: FluTravelStateTensors) -&gt; None:\n    \"\"\"\n    Update `target` instance in-place with current simulation\n    values. Each field of `target` corresponds to a field in\n    `FluSubpopState`, and contains either a tensor of size\n    (L, A, R) or a tensor of size (L), where (l, a, r) refers to\n    location-age-risk.\n    \"\"\"\n\n    # ORDER MATTERS! USE ORDERED DICTIONARY HERE\n    #   to preserve correct index order in tensors!\n    #   See `update_travel_params_tensors` for detailed note.\n    subpop_models_ordered = self._subpop_models_ordered\n\n    for field in fields(target):\n\n        name = field.name\n\n        # FluTravelStateTensors has an attribute\n        #   that is a dictionary called `init_vals` --\n        #   disregard, as this only used to store\n        #   initial values for resetting, but is not\n        #   used in the travel model computation\n        if name == \"init_vals\":\n            continue\n\n        metapop_vals = []\n\n        for model in subpop_models_ordered.values():\n            current_val = getattr(model.state, name)\n            metapop_vals.append(current_val)\n\n        # Probably want to update this to be cleaner...\n        # `SubpopState` fields that correspond to `Schedule` instances\n        # have initial values of `None` -- but we cannot build a tensor\n        # with `None` values, so we convert values to 0s.\n        if any(v is None for v in metapop_vals):\n            setattr(target, name, torch.tensor(np.full(np.shape(metapop_vals), 0.0)))\n        else:\n            setattr(target, name, torch.tensor(np.asarray(metapop_vals)))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_travel_params_tensors","title":"<code>update_travel_params_tensors() -&gt; None</code>","text":"<p>Update <code>travel_params_tensors</code> attribute in-place. <code>FluTravelParamsTensors</code> only has fields corresponding to parameters relevant for the travel model. Converts subpopulation-specific parameters to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_travel_params_tensors(self) -&gt; None:\n    \"\"\"\n    Update `travel_params_tensors` attribute in-place.\n    `FluTravelParamsTensors` only has fields corresponding\n    to parameters relevant for the travel model.\n    Converts subpopulation-specific parameters to\n    tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    self.update_params_tensors(target=self.travel_params_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModel.update_travel_state_tensors","title":"<code>update_travel_state_tensors() -&gt; None</code>","text":"<p>Update <code>travel_state_tensors</code> attribute in-place. <code>FluTravelStateTensors</code> only has fields corresponding to state variables relevant for the travel model. Converts subpopulation-specific state to tensors of size (L, A, R) for location-age-risk (except for a few exceptions that have different dimensions).</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def update_travel_state_tensors(self) -&gt; None:\n    \"\"\"\n    Update `travel_state_tensors` attribute in-place.\n    `FluTravelStateTensors` only has fields corresponding\n    to state variables relevant for the travel model.\n    Converts subpopulation-specific state to\n    tensors of size (L, A, R) for location-age-risk\n    (except for a few exceptions that have different dimensions).\n    \"\"\"\n\n    self.update_state_tensors(self.travel_state_tensors)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMetapopModelError","title":"<code>FluMetapopModelError</code>","text":"<p>               Bases: <code>MetapopModelError</code></p> <p>Custom exceptions for flu metapopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluMetapopModelError(clt.MetapopModelError):\n    \"\"\"Custom exceptions for flu metapopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluMixingParams","title":"<code>FluMixingParams</code>  <code>dataclass</code>","text":"<p>Contains parameters corresponding to inter-subpopulation (metapopulation model) specifications: the number of subpopulations included, and the travel proportions between them.</p> <p>Parameters:</p> Name Type Description Default <code>num_locations</code> <code>int</code> <p>Number of locations (subpopulations) in the metapopulation model.</p> required <code>travel_proportions</code> <code>np.ndarray of shape (A, R</code> <p>L x L array of floats in [0,1], where L is the number of locations (subpopulations), and the i-jth element is the proportion of people in subpopulation i that travel to subpopulation j.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass FluMixingParams:\n    \"\"\"\n    Contains parameters corresponding to inter-subpopulation\n    (metapopulation model) specifications: the number of\n    subpopulations included, and the travel proportions between them.\n\n    Params:\n        num_locations (int):\n            Number of locations (subpopulations) in the\n            metapopulation model.\n        travel_proportions (np.ndarray of shape (A, R)):\n            L x L array of floats in [0,1], where L is the number\n            of locations (subpopulations), and the i-jth element\n            is the proportion of people in subpopulation i that\n            travel to subpopulation j.\n    \"\"\"\n\n    num_locations: Optional[int]\n    travel_proportions: Optional[np.ndarray]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluPrecomputedTensors","title":"<code>FluPrecomputedTensors</code>","text":"<p>Stores precomputed quantities that are repeatedly used, for computational efficiency.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>class FluPrecomputedTensors:\n    \"\"\"\n    Stores precomputed quantities that are repeatedly\n    used, for computational efficiency.\n    \"\"\"\n\n    def __init__(self,\n                 total_pop_LAR_tensor: torch.Tensor,\n                 params: FluTravelParamsTensors) -&gt; None:\n\n        self.total_pop_LAR_tensor = total_pop_LAR_tensor\n\n        self.L = int(params.num_locations.item())\n        self.A = int(params.num_age_groups.item())\n        self.R = int(params.num_risk_groups.item())\n\n        self.total_pop_LA = torch.sum(self.total_pop_LAR_tensor, dim=2)\n\n        # Remove the diagonal!\n        self.nonlocal_travel_prop = params.travel_proportions.clone().fill_diagonal_(0.0)\n\n        # We don't need einsum for residents traveling\n        #   -- Dave and Remy helped me check this\n        # \\sum_{k \\not = \\ell} v^{\\ell \\rightarrow k}\n        # Note we already have k \\not = \\ell because we set the diagonal of\n        #   nonlocal_travel_prop to 0\n        self.sum_residents_nonlocal_travel_prop = self.nonlocal_travel_prop.sum(dim=1)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel","title":"<code>FluSubpopModel</code>","text":"<p>               Bases: <code>SubpopModel</code></p> <p>Class for creating ImmunoSEIRS flu model with predetermined fixed structure -- initial values and epidemiological structure are populated by user-specified <code>JSON</code> files.</p> <p>Key method create_transmission_model returns a <code>SubpopModel</code> instance with S-E-I-H-R-D compartments and M and MV epi metrics.</p> The update structure is as follows <ul> <li>S &lt;- S + R_to_S - S_to_E</li> <li>E &lt;- E + S_to_E - E_to_IP - E_to_IA</li> <li>IA &lt;- IA + E_to_IA - IA_to_R </li> <li>IP &lt;- IP + E_to_IP - IP_to_IS</li> <li>IS &lt;- IS + IP_to_IS - IS_to_R - IS_to_H</li> <li>H &lt;- H + IS_to_H - H_to_R - H_to_D</li> <li>R &lt;- R + IS_to_R + H_to_R - R_to_S</li> <li>D &lt;- D + H_to_D</li> </ul> The following are TransitionVariable instances <ul> <li>R_to_S is a RecoveredToSusceptible instance</li> <li>S_to_E is a SusceptibleToExposed instance</li> <li>IP_to_IS is a PresympToSymp instance</li> <li>IS_to_H is a SympToHosp instance</li> <li>IS_to_R is a SympToRecovered instance</li> <li>H_to_R is a HospToRecovered instance</li> <li>H_to_D is a HospToDead instance</li> </ul> There are three TransitionVariableGroups <ul> <li>E_out (handles E_to_IP and E_to_IA)</li> <li>IS_out (handles IS_to_H and IS_to_R)</li> <li>H_out (handles H_to_R and H_to_D)</li> </ul> The following are EpiMetric instances <ul> <li>M is a InfInducedImmunity instance</li> <li>MV is a VaxInducedImmunity instance</li> </ul> <p>Transition rates and update formulas are specified in corresponding classes.</p> <p>See parent class <code>SubpopModel</code>'s docstring for additional attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluSubpopModel(clt.SubpopModel):\n    \"\"\"\n    Class for creating ImmunoSEIRS flu model with predetermined fixed\n    structure -- initial values and epidemiological structure are\n    populated by user-specified `JSON` files.\n\n    Key method create_transmission_model returns a `SubpopModel`\n    instance with S-E-I-H-R-D compartments and M\n    and MV epi metrics.\n\n    The update structure is as follows:\n        - S &lt;- S + R_to_S - S_to_E\n        - E &lt;- E + S_to_E - E_to_IP - E_to_IA\n        - IA &lt;- IA + E_to_IA - IA_to_R \n        - IP &lt;- IP + E_to_IP - IP_to_IS\n        - IS &lt;- IS + IP_to_IS - IS_to_R - IS_to_H\n        - H &lt;- H + IS_to_H - H_to_R - H_to_D\n        - R &lt;- R + IS_to_R + H_to_R - R_to_S\n        - D &lt;- D + H_to_D\n\n    The following are TransitionVariable instances:\n        - R_to_S is a RecoveredToSusceptible instance\n        - S_to_E is a SusceptibleToExposed instance\n        - IP_to_IS is a PresympToSymp instance\n        - IS_to_H is a SympToHosp instance\n        - IS_to_R is a SympToRecovered instance\n        - H_to_R is a HospToRecovered instance\n        - H_to_D is a HospToDead instance\n\n    There are three TransitionVariableGroups:\n        - E_out (handles E_to_IP and E_to_IA)\n        - IS_out (handles IS_to_H and IS_to_R)\n        - H_out (handles H_to_R and H_to_D)\n\n    The following are EpiMetric instances:\n        - M is a InfInducedImmunity instance\n        - MV is a VaxInducedImmunity instance\n\n    Transition rates and update formulas are specified in\n    corresponding classes.\n\n    See parent class `SubpopModel`'s docstring for additional attributes.\n    \"\"\"\n\n    def __init__(self,\n                 state: FluSubpopState,\n                 params: FluSubpopParams,\n                 simulation_settings: FluSubpopSchedules,\n                 RNG: np.random.Generator,\n                 schedules_spec: FluSubpopSchedules,\n                 name: str):\n        \"\"\"\n        Args:\n            state (FluSubpopState):\n                holds current simulation state information,\n                such as current values of epidemiological compartments\n                and epi metrics.\n            params (FluSubpopParams):\n                holds epidemiological parameter values.\n            simulation_settings (SimulationSettings):\n                holds simulation settings.\n            RNG (np.random.Generator):\n                numpy random generator object used to obtain\n                random numbers.\n            schedules_spec (FluSubpopSchedules):\n                holds dataframes that specify `Schedule` instances.\n            name (str):\n                unique name of MetapopModel instance.\n        \"\"\"\n\n        self.schedules_spec = schedules_spec\n\n        # IMPORTANT NOTE: as always, we must be careful with mutable objects\n        # and generally use deep copies to avoid modification of the same\n        # object. But in this function call, using deep copies is unnecessary\n        # (redundant) because the parent class `SubpopModel`'s `__init__`\n        # creates deep copies.\n        super().__init__(state, params, simulation_settings, RNG, name)\n\n    def modify_params(self,\n                      updates_dict: dict):\n        \"\"\"\n        `SubpopParams` is a frozen dataclass to avoid users\n        naively changing parameter values and getting undesirable results.\n\n        In a `FluMetapopModel`, subpopulation parameters are combined into\n        (L, A, R) tensors across L subpopulations. This method lets users\n        safely modify a single subpopulation field; the metapopulation-wide\n        tensors are updated automatically afterward.\n\n        Parameters:\n            updates_dict (dict):\n                Dictionary specifying values to update in a\n                `FluSubpopParams` instance -- keys must match the\n                field names of `FluSubpopParams`. \n        \"\"\"\n\n        # Since `SubpopParams` is frozen, we return a new instance\n        #   with the reflected updates\n        self.params = clt.updated_dataclass(self.params, updates_dict)\n\n        if self.metapop_model:\n            self.metapop_model.update_travel_params_tensors()\n\n            # Adding this for extra safety in case the user does not\n            # call `get_flu_torch_inputs` for accessing the\n            # `FullMetapopParams` instance.\n\n            # If this attribute is not `None`, it means we are using\n            # the `torch` implementation, and we should update the\n            # corresponding `FullMetapopParams` instance with the new\n            # `FluMixingParams` values.\n            if self._full_metapop_params_tensors:\n                self.update_full_metapop_params_tensors()\n\n    def create_compartments(self) -&gt; sc.objdict[str, clt.Compartment]:\n\n        # Create `Compartment` instances S-E-IA-IP-IS-H-R-D (7 compartments total)\n        # Save instances in `sc.objdict` and return objdict\n\n        compartments = sc.objdict()\n\n        for name in (\"S\", \"E\", \"IP\", \"IS\", \"IA\", \"H\", \"R\", \"D\"):\n            compartments[name] = clt.Compartment(getattr(self.state, name))\n\n        return compartments\n\n    def create_dynamic_vals(self) -&gt; sc.objdict[str, clt.DynamicVal]:\n        \"\"\"\n        Create all `DynamicVal` instances, save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        dynamic_vals = sc.objdict()\n\n        dynamic_vals[\"beta_reduce\"] = BetaReduce(init_val=0.0,\n                                                 is_enabled=False)\n\n        return dynamic_vals\n\n    def create_schedules(self) -&gt; sc.objdict[str, clt.Schedule]:\n        \"\"\"\n        Create all `Schedule` instances, save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        schedules = sc.objdict()\n\n        schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n        schedules[\"flu_contact_matrix\"] = FluContactMatrix()\n        schedules[\"daily_vaccines\"] = DailyVaccines()\n\n        for field, df in asdict(self.schedules_spec).items():\n\n            try:\n                df[\"date\"] = pd.to_datetime(df[\"date\"], format='%Y-%m-%d').dt.date\n            except ValueError as e:\n                raise ValueError(\"Error: dates should be strings in YYYY-MM-DD format or \"\n                                 \"`date.datetime` objects.\") from e\n\n            schedules[field].timeseries_df = df\n\n        return schedules\n\n    def create_transition_variables(self) -&gt; sc.objdict[str, clt.TransitionVariable]:\n        \"\"\"\n        Create all `TransitionVariable` instances,\n        save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        # NOTE: see the parent class `SubpopModel`'s `__init__` --\n        # `create_transition_variables` is called after\n        # `simulation_settings` is assigned\n\n        transition_type = self.simulation_settings.transition_type\n\n        transition_variables = sc.objdict()\n\n        S = self.compartments.S\n        E = self.compartments.E\n        IP = self.compartments.IP\n        IS = self.compartments.IS\n        IA = self.compartments.IA\n        H = self.compartments.H\n        R = self.compartments.R\n        D = self.compartments.D\n\n        transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n        transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n        transition_variables.IP_to_IS = PresympToSymp(IP, IS, transition_type)\n        transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n        transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n        transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n        transition_variables.IS_to_R = SympToRecovered(IS, R, transition_type, True)\n        transition_variables.IS_to_H = SympToHosp(IS, H, transition_type, True)\n        transition_variables.H_to_R = HospToRecovered(H, R, transition_type, True)\n        transition_variables.H_to_D = HospToDead(H, D, transition_type, True)\n\n        return transition_variables\n\n    def create_transition_variable_groups(self) -&gt; sc.objdict[str, clt.TransitionVariableGroup]:\n        \"\"\"\n        Create all transition variable groups described in docstring (2 transition\n        variable groups total), save in `sc.objdict`, return objdict\n        \"\"\"\n\n        # Shortcuts for attribute access\n        # NOTE: see the parent class `SubpopModel`'s `__init__` --\n        # `create_transition_variable_groups` is called after\n        # `simulation_settings` is assigned\n\n        transition_type = self.simulation_settings.transition_type\n\n        transition_variable_groups = sc.objdict()\n\n        transition_variable_groups.E_out = clt.TransitionVariableGroup(self.compartments.E,\n                                                                       transition_type,\n                                                                       (self.transition_variables.E_to_IP,\n                                                                        self.transition_variables.E_to_IA))\n\n        transition_variable_groups.IS_out = clt.TransitionVariableGroup(self.compartments.IS,\n                                                                        transition_type,\n                                                                        (self.transition_variables.IS_to_R,\n                                                                         self.transition_variables.IS_to_H))\n\n        transition_variable_groups.H_out = clt.TransitionVariableGroup(self.compartments.H,\n                                                                       transition_type,\n                                                                       (self.transition_variables.H_to_R,\n                                                                        self.transition_variables.H_to_D))\n\n        return transition_variable_groups\n\n    def create_epi_metrics(self) -&gt; sc.objdict[str, clt.EpiMetric]:\n        \"\"\"\n        Create all epi metric described in docstring (2 state\n        variables total), save in `sc.objdict`, and return objdict\n        \"\"\"\n\n        epi_metrics = sc.objdict()\n\n        epi_metrics.M = \\\n            InfInducedImmunity(getattr(self.state, \"M\"),\n                               self.transition_variables.R_to_S)\n\n        epi_metrics.MV = \\\n            VaxInducedImmunity(getattr(self.state, \"MV\"))\n\n        return epi_metrics\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.__init__","title":"<code>__init__(state: FluSubpopState, params: FluSubpopParams, simulation_settings: FluSubpopSchedules, RNG: np.random.Generator, schedules_spec: FluSubpopSchedules, name: str)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>FluSubpopState</code> <p>holds current simulation state information, such as current values of epidemiological compartments and epi metrics.</p> required <code>params</code> <code>FluSubpopParams</code> <p>holds epidemiological parameter values.</p> required <code>simulation_settings</code> <code>SimulationSettings</code> <p>holds simulation settings.</p> required <code>RNG</code> <code>Generator</code> <p>numpy random generator object used to obtain random numbers.</p> required <code>schedules_spec</code> <code>FluSubpopSchedules</code> <p>holds dataframes that specify <code>Schedule</code> instances.</p> required <code>name</code> <code>str</code> <p>unique name of MetapopModel instance.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def __init__(self,\n             state: FluSubpopState,\n             params: FluSubpopParams,\n             simulation_settings: FluSubpopSchedules,\n             RNG: np.random.Generator,\n             schedules_spec: FluSubpopSchedules,\n             name: str):\n    \"\"\"\n    Args:\n        state (FluSubpopState):\n            holds current simulation state information,\n            such as current values of epidemiological compartments\n            and epi metrics.\n        params (FluSubpopParams):\n            holds epidemiological parameter values.\n        simulation_settings (SimulationSettings):\n            holds simulation settings.\n        RNG (np.random.Generator):\n            numpy random generator object used to obtain\n            random numbers.\n        schedules_spec (FluSubpopSchedules):\n            holds dataframes that specify `Schedule` instances.\n        name (str):\n            unique name of MetapopModel instance.\n    \"\"\"\n\n    self.schedules_spec = schedules_spec\n\n    # IMPORTANT NOTE: as always, we must be careful with mutable objects\n    # and generally use deep copies to avoid modification of the same\n    # object. But in this function call, using deep copies is unnecessary\n    # (redundant) because the parent class `SubpopModel`'s `__init__`\n    # creates deep copies.\n    super().__init__(state, params, simulation_settings, RNG, name)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_dynamic_vals","title":"<code>create_dynamic_vals() -&gt; sc.objdict[str, clt.DynamicVal]</code>","text":"<p>Create all <code>DynamicVal</code> instances, save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_dynamic_vals(self) -&gt; sc.objdict[str, clt.DynamicVal]:\n    \"\"\"\n    Create all `DynamicVal` instances, save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    dynamic_vals = sc.objdict()\n\n    dynamic_vals[\"beta_reduce\"] = BetaReduce(init_val=0.0,\n                                             is_enabled=False)\n\n    return dynamic_vals\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_epi_metrics","title":"<code>create_epi_metrics() -&gt; sc.objdict[str, clt.EpiMetric]</code>","text":"<p>Create all epi metric described in docstring (2 state variables total), save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_epi_metrics(self) -&gt; sc.objdict[str, clt.EpiMetric]:\n    \"\"\"\n    Create all epi metric described in docstring (2 state\n    variables total), save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    epi_metrics = sc.objdict()\n\n    epi_metrics.M = \\\n        InfInducedImmunity(getattr(self.state, \"M\"),\n                           self.transition_variables.R_to_S)\n\n    epi_metrics.MV = \\\n        VaxInducedImmunity(getattr(self.state, \"MV\"))\n\n    return epi_metrics\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_schedules","title":"<code>create_schedules() -&gt; sc.objdict[str, clt.Schedule]</code>","text":"<p>Create all <code>Schedule</code> instances, save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_schedules(self) -&gt; sc.objdict[str, clt.Schedule]:\n    \"\"\"\n    Create all `Schedule` instances, save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    schedules = sc.objdict()\n\n    schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n    schedules[\"flu_contact_matrix\"] = FluContactMatrix()\n    schedules[\"daily_vaccines\"] = DailyVaccines()\n\n    for field, df in asdict(self.schedules_spec).items():\n\n        try:\n            df[\"date\"] = pd.to_datetime(df[\"date\"], format='%Y-%m-%d').dt.date\n        except ValueError as e:\n            raise ValueError(\"Error: dates should be strings in YYYY-MM-DD format or \"\n                             \"`date.datetime` objects.\") from e\n\n        schedules[field].timeseries_df = df\n\n    return schedules\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_transition_variable_groups","title":"<code>create_transition_variable_groups() -&gt; sc.objdict[str, clt.TransitionVariableGroup]</code>","text":"<p>Create all transition variable groups described in docstring (2 transition variable groups total), save in <code>sc.objdict</code>, return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_transition_variable_groups(self) -&gt; sc.objdict[str, clt.TransitionVariableGroup]:\n    \"\"\"\n    Create all transition variable groups described in docstring (2 transition\n    variable groups total), save in `sc.objdict`, return objdict\n    \"\"\"\n\n    # Shortcuts for attribute access\n    # NOTE: see the parent class `SubpopModel`'s `__init__` --\n    # `create_transition_variable_groups` is called after\n    # `simulation_settings` is assigned\n\n    transition_type = self.simulation_settings.transition_type\n\n    transition_variable_groups = sc.objdict()\n\n    transition_variable_groups.E_out = clt.TransitionVariableGroup(self.compartments.E,\n                                                                   transition_type,\n                                                                   (self.transition_variables.E_to_IP,\n                                                                    self.transition_variables.E_to_IA))\n\n    transition_variable_groups.IS_out = clt.TransitionVariableGroup(self.compartments.IS,\n                                                                    transition_type,\n                                                                    (self.transition_variables.IS_to_R,\n                                                                     self.transition_variables.IS_to_H))\n\n    transition_variable_groups.H_out = clt.TransitionVariableGroup(self.compartments.H,\n                                                                   transition_type,\n                                                                   (self.transition_variables.H_to_R,\n                                                                    self.transition_variables.H_to_D))\n\n    return transition_variable_groups\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.create_transition_variables","title":"<code>create_transition_variables() -&gt; sc.objdict[str, clt.TransitionVariable]</code>","text":"<p>Create all <code>TransitionVariable</code> instances, save in <code>sc.objdict</code>, and return objdict</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def create_transition_variables(self) -&gt; sc.objdict[str, clt.TransitionVariable]:\n    \"\"\"\n    Create all `TransitionVariable` instances,\n    save in `sc.objdict`, and return objdict\n    \"\"\"\n\n    # NOTE: see the parent class `SubpopModel`'s `__init__` --\n    # `create_transition_variables` is called after\n    # `simulation_settings` is assigned\n\n    transition_type = self.simulation_settings.transition_type\n\n    transition_variables = sc.objdict()\n\n    S = self.compartments.S\n    E = self.compartments.E\n    IP = self.compartments.IP\n    IS = self.compartments.IS\n    IA = self.compartments.IA\n    H = self.compartments.H\n    R = self.compartments.R\n    D = self.compartments.D\n\n    transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n    transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n    transition_variables.IP_to_IS = PresympToSymp(IP, IS, transition_type)\n    transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n    transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n    transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n    transition_variables.IS_to_R = SympToRecovered(IS, R, transition_type, True)\n    transition_variables.IS_to_H = SympToHosp(IS, H, transition_type, True)\n    transition_variables.H_to_R = HospToRecovered(H, R, transition_type, True)\n    transition_variables.H_to_D = HospToDead(H, D, transition_type, True)\n\n    return transition_variables\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModel.modify_params","title":"<code>modify_params(updates_dict: dict)</code>","text":"<p><code>SubpopParams</code> is a frozen dataclass to avoid users naively changing parameter values and getting undesirable results.</p> <p>In a <code>FluMetapopModel</code>, subpopulation parameters are combined into (L, A, R) tensors across L subpopulations. This method lets users safely modify a single subpopulation field; the metapopulation-wide tensors are updated automatically afterward.</p> <p>Parameters:</p> Name Type Description Default <code>updates_dict</code> <code>dict</code> <p>Dictionary specifying values to update in a <code>FluSubpopParams</code> instance -- keys must match the field names of <code>FluSubpopParams</code>.</p> required Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def modify_params(self,\n                  updates_dict: dict):\n    \"\"\"\n    `SubpopParams` is a frozen dataclass to avoid users\n    naively changing parameter values and getting undesirable results.\n\n    In a `FluMetapopModel`, subpopulation parameters are combined into\n    (L, A, R) tensors across L subpopulations. This method lets users\n    safely modify a single subpopulation field; the metapopulation-wide\n    tensors are updated automatically afterward.\n\n    Parameters:\n        updates_dict (dict):\n            Dictionary specifying values to update in a\n            `FluSubpopParams` instance -- keys must match the\n            field names of `FluSubpopParams`. \n    \"\"\"\n\n    # Since `SubpopParams` is frozen, we return a new instance\n    #   with the reflected updates\n    self.params = clt.updated_dataclass(self.params, updates_dict)\n\n    if self.metapop_model:\n        self.metapop_model.update_travel_params_tensors()\n\n        # Adding this for extra safety in case the user does not\n        # call `get_flu_torch_inputs` for accessing the\n        # `FullMetapopParams` instance.\n\n        # If this attribute is not `None`, it means we are using\n        # the `torch` implementation, and we should update the\n        # corresponding `FullMetapopParams` instance with the new\n        # `FluMixingParams` values.\n        if self._full_metapop_params_tensors:\n            self.update_full_metapop_params_tensors()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopModelError","title":"<code>FluSubpopModelError</code>","text":"<p>               Bases: <code>SubpopModelError</code></p> <p>Custom exceptions for flu subpopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class FluSubpopModelError(clt.SubpopModelError):\n    \"\"\"Custom exceptions for flu subpopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopParams","title":"<code>FluSubpopParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubpopParams</code></p> <p>Data container for pre-specified and fixed epidemiological parameters in <code>FluSubpopModel</code>.</p> <p>Each field of datatype np.ndarray must be A x R, where A is the number of age groups and R is the number of risk groups. Note: this means all arrays should be 2D. See FluSubpopState docstring for important formatting note on 2D arrays.</p> <p>Note: the user does not have to specify <code>total_pop_age_risk</code> -- this is automatically computed when a <code>FluSubpopModel</code> is instantiated. This is to ensure that the total population (summed across all compartments) actually equals <code>total_pop_age_risk</code> -- and the user doesn't change one without updating the other.</p> <p>Attributes:</p> Name Type Description <code>num_age_groups</code> <code>positive int</code> <p>number of age groups.</p> <code>num_risk_groups</code> <code>positive int</code> <p>number of risk groups.</p> <code>beta_baseline</code> <code>positive float</code> <p>transmission rate.</p> <code>total_pop_age_risk</code> <code>np.ndarray of positive ints</code> <p>total number in population, summed across all age-risk groups.</p> <code>humidity_impact</code> <code>positive float</code> <p>coefficient that determines how much absolute humidity affects beta_baseline.</p> <code>inf_induced_saturation</code> <code>np.ndarray of positive floats</code> <p>constant(s) modeling saturation of antibody production of infected individuals.</p> <code>inf_induced_immune_wane</code> <code>positive float</code> <p>rate at which infection-induced immunity against infection wanes.</p> <code>vax_induced_saturation</code> <code>np.ndarray of positive floats</code> <p>constant(s) modeling saturation of antibody production of vaccinated individuals.</p> <code>vax_induced_immune_wane</code> <code>positive float</code> <p>rate at which vaccine-induced immunity against infection wanes.</p> <code>inf_induced_inf_risk_reduce</code> <code>positive float</code> <p>reduction in risk of getting infected after getting infected</p> <code>inf_induced_hosp_risk_reduce</code> <code>positive float</code> <p>reduction in risk of hospitalization after getting infected</p> <code>inf_induced_death_risk_reduce</code> <code>positive float</code> <p>reduction in risk of death after getting infected</p> <code>vax_induced_inf_risk_reduce</code> <code>positive float</code> <p>reduction in risk of getting infected after getting vaccinated</p> <code>vax_induced_hosp_risk_reduce</code> <code>positive float</code> <p>reduction in risk of hospitalization after getting vaccinated</p> <code>vax_induced_death_risk_reduce</code> <code>positive float</code> <p>reduction in risk of death after getting vaccinated</p> <code>R_to_S_rate</code> <code>positive float</code> <p>rate at which people in R move to S.</p> <code>E_to_I_rate</code> <code>positive float</code> <p>rate at which people in E move to I (both IP and IA, infected pre-symptomatic and infected asymptomatic)</p> <code>IP_to_IS_rate</code> <code>positive float</code> <p>rate a which people in IP (infected pre-symptomatic) move to IS (infected symptomatic)</p> <code>IS_to_R_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to R.</p> <code>IA_to_R_rate</code> <code>positive float</code> <p>rate at which people in IA (infected asymptomatic) move to R</p> <code>IS_to_H_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to H.</p> <code>H_to_R_rate</code> <code>positive float</code> <p>rate at which people in H move to R.</p> <code>H_to_D_rate</code> <code>positive float</code> <p>rate at which people in H move to D.</p> <code>E_to_IA_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>proportion exposed who are asymptomatic based on age-risk groups.</p> <code>IS_to_H_adjusted_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion infected who are hospitalized based on age-risk groups.</p> <code>H_to_D_adjusted_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion hospitalized who die based on age-risk groups.</p> <code>IP_relative_inf</code> <code>positive float</code> <p>relative infectiousness of pre-symptomatic to symptomatic people (IP to IS compartment).</p> <code>IA_relative_inf</code> <code>positive float</code> <p>relative infectiousness of asymptomatic to symptomatic people (IA to IS compartment).</p> <code>relative_suscept</code> <code>np.ndarray of positive floats in [0,1]</code> <p>relative susceptibility to infection by age group</p> <code>mobility_modifier</code> <code>np.ndarray of positive floats in [0,1]</code> <p>total proportion of time spent away from home by age group</p> <code>total_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A contact matrix (where A is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has</p> <code>school_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A contact matrix (where A is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has at school -- this matrix plus the work_contact_matrix must be less than the total_contact_matrix, element-wise</p> <code>work_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A contact matrix (where A is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has at work -- this matrix plus the work_contact_matrix must be less than the total_contact_matrix, element-wise</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass(frozen=True)\nclass FluSubpopParams(clt.SubpopParams):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in `FluSubpopModel`.\n\n    Each field of datatype np.ndarray must be A x R,\n    where A is the number of age groups and R is the number of\n    risk groups. Note: this means all arrays should be 2D.\n    See FluSubpopState docstring for important formatting note\n    on 2D arrays.\n\n    Note: the user does not have to specify `total_pop_age_risk` --\n    this is automatically computed when a `FluSubpopModel` is\n    instantiated. This is to ensure that the total population\n    (summed across all compartments) actually equals `total_pop_age_risk` --\n    and the user doesn't change one without updating the other.\n\n    Attributes:\n        num_age_groups (positive int):\n            number of age groups.\n        num_risk_groups (positive int):\n            number of risk groups.\n        beta_baseline (positive float): transmission rate.\n        total_pop_age_risk (np.ndarray of positive ints):\n            total number in population, summed across all\n            age-risk groups.\n        humidity_impact (positive float):\n            coefficient that determines how much absolute\n            humidity affects beta_baseline.\n        inf_induced_saturation (np.ndarray of positive floats):\n            constant(s) modeling saturation of antibody\n            production of infected individuals.\n        inf_induced_immune_wane (positive float):\n            rate at which infection-induced immunity\n            against infection wanes.\n        vax_induced_saturation (np.ndarray of positive floats):\n            constant(s) modeling saturation of antibody\n            production of vaccinated individuals.\n        vax_induced_immune_wane (positive float):\n            rate at which vaccine-induced immunity\n            against infection wanes.\n        inf_induced_inf_risk_reduce (positive float):\n            reduction in risk of getting infected\n            after getting infected\n        inf_induced_hosp_risk_reduce (positive float):\n            reduction in risk of hospitalization\n            after getting infected\n        inf_induced_death_risk_reduce (positive float):\n            reduction in risk of death\n            after getting infected\n        vax_induced_inf_risk_reduce (positive float):\n            reduction in risk of getting infected\n            after getting vaccinated\n        vax_induced_hosp_risk_reduce (positive float):\n            reduction in risk of hospitalization\n            after getting vaccinated\n        vax_induced_death_risk_reduce (positive float):\n            reduction in risk of death\n            after getting vaccinated\n        R_to_S_rate (positive float):\n            rate at which people in R move to S.\n        E_to_I_rate (positive float):\n            rate at which people in E move to I (both\n            IP and IA, infected pre-symptomatic and infected\n            asymptomatic)\n        IP_to_IS_rate (positive float):\n            rate a which people in IP (infected pre-symptomatic)\n            move to IS (infected symptomatic)\n        IS_to_R_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to R.\n        IA_to_R_rate (positive float):\n            rate at which people in IA (infected asymptomatic)\n            move to R\n        IS_to_H_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to H.\n        H_to_R_rate (positive float):\n            rate at which people in H move to R.\n        H_to_D_rate (positive float):\n            rate at which people in H move to D.\n        E_to_IA_prop (np.ndarray of positive floats in [0,1]):\n            proportion exposed who are asymptomatic based on\n            age-risk groups.\n        IS_to_H_adjusted_prop (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion infected who are hospitalized\n            based on age-risk groups.\n        H_to_D_adjusted_prop (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion hospitalized who die based on\n            age-risk groups.\n        IP_relative_inf (positive float):\n            relative infectiousness of pre-symptomatic to symptomatic\n            people (IP to IS compartment).\n        IA_relative_inf (positive float):\n            relative infectiousness of asymptomatic to symptomatic\n            people (IA to IS compartment).\n        relative_suscept (np.ndarray of positive floats in [0,1]):\n            relative susceptibility to infection by age group\n        mobility_modifier (np.ndarray of positive floats in [0,1]):\n            total proportion of time spent away from home by age group\n        total_contact_matrix (np.ndarray of positive floats):\n            A x A contact matrix (where A is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has\n        school_contact_matrix (np.ndarray of positive floats):\n            A x A contact matrix (where A is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has at school -- this matrix plus the\n            work_contact_matrix must be less than the\n            total_contact_matrix, element-wise\n        work_contact_matrix (np.ndarray of positive floats):\n            A x A contact matrix (where A is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has at work -- this matrix plus the\n            work_contact_matrix must be less than the\n            total_contact_matrix, element-wise\n    \"\"\"\n\n    num_age_groups: Optional[int] = None\n    num_risk_groups: Optional[int] = None\n    beta_baseline: Optional[float] = None\n    total_pop_age_risk: Optional[np.ndarray] = None\n    humidity_impact: Optional[float] = None\n\n    inf_induced_saturation: Optional[float] = None\n    inf_induced_immune_wane: Optional[float] = None\n    vax_induced_saturation: Optional[float] = None\n    vax_induced_immune_wane: Optional[float] = None\n    inf_induced_inf_risk_reduce: Optional[float] = None\n    inf_induced_hosp_risk_reduce: Optional[float] = None\n    inf_induced_death_risk_reduce: Optional[float] = None\n    vax_induced_inf_risk_reduce: Optional[float] = None\n    vax_induced_hosp_risk_reduce: Optional[float] = None\n    vax_induced_death_risk_reduce: Optional[float] = None\n\n    R_to_S_rate: Optional[float] = None\n    E_to_I_rate: Optional[float] = None\n    IP_to_IS_rate: Optional[float] = None\n    IS_to_R_rate: Optional[float] = None\n    IA_to_R_rate: Optional[float] = None\n    IS_to_H_rate: Optional[float] = None\n    H_to_R_rate: Optional[float] = None\n    H_to_D_rate: Optional[float] = None\n    E_to_IA_prop: Optional[np.ndarray] = None\n\n    IS_to_H_adjusted_prop: Optional[np.ndarray] = None\n    H_to_D_adjusted_prop: Optional[np.ndarray] = None\n\n    IP_relative_inf: Optional[float] = None\n    IA_relative_inf: Optional[float] = None\n\n    relative_suscept: Optional[np.ndarray] = None\n\n    mobility_modifier: Optional[np.ndarray] = None\n\n    total_contact_matrix: Optional[np.ndarray] = None\n    school_contact_matrix: Optional[np.ndarray] = None\n    work_contact_matrix: Optional[np.ndarray] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopSchedules","title":"<code>FluSubpopSchedules</code>  <code>dataclass</code>","text":"<p>Data container for dataframes used to specify schedules for each <code>FluSubpopModel</code> instance.</p> <p>THE FORMAT FOR EACH DATAFRAME IS VERY IMPORTANT -- please read and implement carefully.</p> <p>Attributes:</p> Name Type Description <code>absolute_humidity</code> <code>DataFrame</code> <p>must have columns \"date\" and \"absolute_humidity\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to absolute humidity on those days</p> <code>flu_contact_matrix</code> <code>DataFrame</code> <p>must have columns \"date\", \"is_school_day\", and \"is_work_day\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> object and \"is_school_day\" and \"is_work_day\" entries are Booleans indicating if that date is a school day or work day</p> <code>daily_vaccines</code> <code>DataFrame</code> <p>must have \"date\" and \"daily_vaccines\" -- \"date\" entries must correspond to consecutive calendar days and must either be strings with <code>\"YYYY-MM-DD\"</code> format or <code>datetime.date</code> objects -- \"value\" entries correspond to historical number vaccinated on those days</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluSubpopSchedules:\n    \"\"\"\n    Data container for dataframes used to specify schedules\n    for each `FluSubpopModel` instance.\n\n    THE FORMAT FOR EACH DATAFRAME IS VERY IMPORTANT -- please\n    read and implement carefully.\n\n    Attributes:\n        absolute_humidity (pd.DataFrame):\n            must have columns \"date\" and \"absolute_humidity\" --\n            \"date\" entries must correspond to consecutive calendar days\n            and must either be strings with `\"YYYY-MM-DD\"` format or\n            `datetime.date` objects -- \"value\" entries correspond to\n            absolute humidity on those days\n        flu_contact_matrix (pd.DataFrame):\n            must have columns \"date\", \"is_school_day\", and \"is_work_day\"\n            -- \"date\" entries must correspond to consecutive calendar\n            days and must either be strings with `\"YYYY-MM-DD\"` format\n            or `datetime.date` object and \"is_school_day\" and\n            \"is_work_day\" entries are Booleans indicating if that date is\n            a school day or work day\n        daily_vaccines (pd.DataFrame):\n            must have \"date\" and \"daily_vaccines\" -- \"date\" entries must\n            correspond to consecutive calendar days and must either\n            be strings with `\"YYYY-MM-DD\"` format or `datetime.date`\n            objects -- \"value\" entries correspond to historical\n            number vaccinated on those days\n    \"\"\"\n\n    absolute_humidity: Optional[pd.DataFrame] = None\n    flu_contact_matrix: Optional[pd.DataFrame] = None\n    daily_vaccines: Optional[pd.DataFrame] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluSubpopState","title":"<code>FluSubpopState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubpopState</code></p> <p>Data container for pre-specified and fixed set of Compartment initial values and EpiMetric initial values for <code>FluSubpopModel</code>.</p> <p>Each field below should be A x R np.ndarray, where A is the number of age groups and R is the number of risk groups. Note: this means all arrays should be 2D. Even if there is 1 age group and 1 risk group (no group stratification), each array should be 1x1, which is two-dimensional. For example, np.array([[100]]) is correct -- np.array([100]) is wrong.</p> <p>Attributes:</p> Name Type Description <code>S</code> <code>np.ndarray of nonnegative integers</code> <p>susceptible compartment for age-risk groups -- (holds current_val of Compartment \"S\").</p> <code>E</code> <code>np.ndarray of nonnegative integers</code> <p>exposed compartment for age-risk groups -- (holds current_val of Compartment \"E\").</p> <code>IP</code> <code>np.ndarray of nonnegative integers</code> <p>infected pre-symptomatic compartment for age-risk groups (holds current_val of Compartment \"IP\").</p> <code>IS</code> <code>np.ndarray of nonnegative integers</code> <p>infected symptomatic compartment for age-risk groups (holds current_val of Compartment \"IS\").</p> <code>IA</code> <code>np.ndarray of nonnegative integers</code> <p>infected asymptomatic compartment for age-risk groups (holds current_val of Compartment \"IA\").</p> <code>H</code> <code>np.ndarray of nonnegative integers</code> <p>hospital compartment for age-risk groups (holds current_val of Compartment \"H\").</p> <code>R</code> <code>np.ndarray of nonnegative integers</code> <p>recovered compartment for age-risk groups (holds current_val of Compartment \"R\").</p> <code>D</code> <code>np.ndarray of nonnegative integers</code> <p>dead compartment for age-risk groups (holds current_val of Compartment \"D\").</p> <code>M</code> <code>np.ndarray of nonnegative floats</code> <p>infection-induced population-level immunity for age-risk groups (holds current_val of EpiMetric \"M\").</p> <code>MV</code> <code>np.ndarray of nonnegative floats</code> <p>vaccine-induced population-level immunity for age-risk groups (holds current_val of EpiMetric \"MV\").</p> <code>absolute_humidity</code> <code>positive float</code> <p>grams of water vapor per cubic meter g/m^3, used as seasonality parameter that influences transmission rate beta_baseline.</p> <code>flu_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x A array, where A is the number of age groups -- element (a, a') corresponds to the number of contacts that a person in age group a has with people in age-risk group a'.</p> <code>beta_reduce</code> <code>float in [0, 1]</code> <p>starting value of DynamicVal \"beta_reduce\" on starting day of simulation -- this DynamicVal emulates a simple staged-alert policy</p> <code>daily_vaccines</code> <code>np.ndarray of positive ints</code> <p>holds current value of DailyVaccines instance, corresponding number of individuals who received influenza vaccine on that day, for given age-risk group (generally derived from historical data)</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluSubpopState(clt.SubpopState):\n    \"\"\"\n    Data container for pre-specified and fixed set of\n    Compartment initial values and EpiMetric initial values\n    for `FluSubpopModel`.\n\n    Each field below should be A x R np.ndarray, where\n    A is the number of age groups and R is the number of risk groups.\n    Note: this means all arrays should be 2D. Even if there is\n    1 age group and 1 risk group (no group stratification),\n    each array should be 1x1, which is two-dimensional.\n    For example, np.array([[100]]) is correct --\n    np.array([100]) is wrong.\n\n    Attributes:\n        S (np.ndarray of nonnegative integers):\n            susceptible compartment for age-risk groups --\n            (holds current_val of Compartment \"S\").\n        E (np.ndarray of nonnegative integers):\n            exposed compartment for age-risk groups --\n            (holds current_val of Compartment \"E\").\n        IP (np.ndarray of nonnegative integers):\n            infected pre-symptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IP\").\n        IS (np.ndarray of nonnegative integers):\n            infected symptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IS\").\n        IA (np.ndarray of nonnegative integers):\n            infected asymptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IA\").\n        H (np.ndarray of nonnegative integers):\n            hospital compartment for age-risk groups\n            (holds current_val of Compartment \"H\").\n        R (np.ndarray of nonnegative integers):\n            recovered compartment for age-risk groups\n            (holds current_val of Compartment \"R\").\n        D (np.ndarray of nonnegative integers):\n            dead compartment for age-risk groups\n            (holds current_val of Compartment \"D\").\n        M (np.ndarray of nonnegative floats):\n            infection-induced population-level immunity\n            for age-risk groups (holds current_val\n            of EpiMetric \"M\").\n        MV (np.ndarray of nonnegative floats):\n            vaccine-induced population-level immunity\n            for age-risk groups (holds current_val\n            of EpiMetric \"MV\").\n        absolute_humidity (positive float):\n            grams of water vapor per cubic meter g/m^3,\n            used as seasonality parameter that influences\n            transmission rate beta_baseline.\n        flu_contact_matrix (np.ndarray of positive floats):\n            A x A array, where A is the number of age\n            groups -- element (a, a') corresponds to the number\n            of contacts that a person in age group a\n            has with people in age-risk group a'.\n        beta_reduce (float in [0,1]):\n            starting value of DynamicVal \"beta_reduce\" on\n            starting day of simulation -- this DynamicVal\n            emulates a simple staged-alert policy\n        daily_vaccines (np.ndarray of positive ints):\n            holds current value of DailyVaccines instance,\n            corresponding number of individuals who received influenza\n            vaccine on that day, for given age-risk group\n            (generally derived from historical data)\n    \"\"\"\n\n    S: Optional[np.ndarray] = None\n    E: Optional[np.ndarray] = None\n    IP: Optional[np.ndarray] = None\n    IS: Optional[np.ndarray] = None\n    IA: Optional[np.ndarray] = None\n    H: Optional[np.ndarray] = None\n    R: Optional[np.ndarray] = None\n    D: Optional[np.ndarray] = None\n\n    M: Optional[np.ndarray] = None\n    MV: Optional[np.ndarray] = None\n\n    absolute_humidity: Optional[float] = None\n    flu_contact_matrix: Optional[np.ndarray] = None\n    beta_reduce: Optional[float] = 0.0\n\n    daily_vaccines: Optional[np.ndarray] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluTravelParamsTensors","title":"<code>FluTravelParamsTensors</code>  <code>dataclass</code>","text":"<p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from parameters on each location/subpopulation model, as well as from the metapopulation's associated <code>FluMixingParams</code> instance). Note that not all fields in <code>FluSubpopParams</code> are included -- we only include parameters needed for the travel model computation, for efficiency.</p> <p>Attributes:</p> Name Type Description <code>num_locations</code> <code>(Tensor, 0 - dimensional)</code> <p>number of locations (subpopulations) in the metapopulation model and therefore the travel model.</p> <code>travel_proportions</code> <code>Tensor</code> <p>L x L array, where L is the number of locations or subpopulations, where element i,j corresponds to the proportion of the population in location i who travels to location j (on average).</p> <p>See <code>FluSubpopParams</code> docstring for other attributes.</p> <p>Fields are analogous -- but (most) are size (L, A, R) for location-age-risk or size 0 tensors. Exceptions are <code>travel_proportions</code>, which is size (L, L), and any of the contact matrices, which are size (L, A, A).</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluTravelParamsTensors:\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays\n    that contain data across all subpopulations (collected from parameters\n    on each location/subpopulation model, as well as from the\n    metapopulation's associated `FluMixingParams` instance).\n    Note that not all fields in `FluSubpopParams` are included\n    -- we only include parameters needed for the travel model\n    computation, for efficiency.\n\n    Attributes:\n        num_locations (torch.Tensor, 0-dimensional):\n            number of locations (subpopulations) in the\n            metapopulation model and therefore the travel\n            model.\n        travel_proportions (torch.Tensor):\n            L x L array, where L is the number of locations\n            or subpopulations, where element i,j corresponds\n            to the proportion of the population in location i\n            who travels to location j (on average).\n\n    See `FluSubpopParams` docstring for other attributes.\n\n    Fields are analogous -- but (most) are size (L, A, R) for\n    location-age-risk or size 0 tensors. Exceptions are\n    `travel_proportions`, which is size (L, L),\n    and any of the contact matrices, which are size (L, A, A).\n    \"\"\"\n\n    num_locations: Optional[torch.tensor] = None\n    num_age_groups: Optional[torch.tensor] = None\n    num_risk_groups: Optional[torch.tensor] = None\n\n    travel_proportions: torch.Tensor = None\n\n    IP_relative_inf: torch.Tensor = None\n    IA_relative_inf: torch.Tensor = None\n\n    relative_suscept: torch.Tensor = None\n    mobility_modifier: torch.Tensor = None\n\n    total_contact_matrix: Optional[torch.Tensor] = None\n    school_contact_matrix: Optional[torch.Tensor] = None\n    work_contact_matrix: Optional[torch.Tensor] = None\n\n    def standardize_shapes(self) -&gt; None:\n        \"\"\"\n        If field is size (L, A, R) for location-age-risk or size 0 tensors,\n            or is not a special variable isted below, then apply dimension\n            expansion so that fields are size (L, A, R) tensors for tensor multiplication.\n\n        Exceptions are `travel_proportions`, which is size (L, L),\n        and any of the contact matrices, which are size (L, A, A).\n\n        Not all dimension combinations are considered not all make sense --\n        we assume that we only have risk IF we have age, for example.\n        \"\"\"\n\n        L = int(self.num_locations.item())\n        A = int(self.num_age_groups.item())\n        R = int(self.num_risk_groups.item())\n\n        error_str = \"Each SubpopParams field must have size (L, A, R) \" \\\n                    \"(for location-age-risk groups) or size 0 -- please check files \" \\\n                    \"and inputs, then try again.\"\n\n        for name, value in vars(self).items():\n\n            # Ignore the field that corresponds to a dictionary\n            if name == \"init_vals\":\n                continue\n\n            elif name == \"travel_proportions\":\n                if value.size() != torch.Size([L, L]):\n                    raise Exception(str(name) + error_str)\n\n            # `total_contact_matrix`, `school_contact_matrix`, `work_contact_matrix`\n            elif \"contact_matrix\" in name:\n                if value.size() == torch.Size([L, A, A]):\n                    continue\n                elif value.size() != torch.Size([A, A]):\n                    raise Exception(str(name) + error_str)\n                else:\n                    setattr(self, name, value.view(1, A, A).expand(L, A, A))\n\n            # If scalar or already L x A x R, do not need to adjust\n            #   dimensions\n            elif value.size() == torch.Size([]):\n                continue\n\n            elif value.size() == torch.Size([L, A, R]):\n                continue\n\n            elif value.size() == torch.Size([L]):\n                setattr(self, name, value.view(L, 1, 1).expand(L, A, R))\n\n            elif value.size() == torch.Size([A, R]):\n                setattr(self, name, value.view(1, A, R).expand(L, A, R))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluTravelParamsTensors.standardize_shapes","title":"<code>standardize_shapes() -&gt; None</code>","text":"<p>If field is size (L, A, R) for location-age-risk or size 0 tensors,     or is not a special variable isted below, then apply dimension     expansion so that fields are size (L, A, R) tensors for tensor multiplication.</p> <p>Exceptions are <code>travel_proportions</code>, which is size (L, L), and any of the contact matrices, which are size (L, A, A).</p> <p>Not all dimension combinations are considered not all make sense -- we assume that we only have risk IF we have age, for example.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>def standardize_shapes(self) -&gt; None:\n    \"\"\"\n    If field is size (L, A, R) for location-age-risk or size 0 tensors,\n        or is not a special variable isted below, then apply dimension\n        expansion so that fields are size (L, A, R) tensors for tensor multiplication.\n\n    Exceptions are `travel_proportions`, which is size (L, L),\n    and any of the contact matrices, which are size (L, A, A).\n\n    Not all dimension combinations are considered not all make sense --\n    we assume that we only have risk IF we have age, for example.\n    \"\"\"\n\n    L = int(self.num_locations.item())\n    A = int(self.num_age_groups.item())\n    R = int(self.num_risk_groups.item())\n\n    error_str = \"Each SubpopParams field must have size (L, A, R) \" \\\n                \"(for location-age-risk groups) or size 0 -- please check files \" \\\n                \"and inputs, then try again.\"\n\n    for name, value in vars(self).items():\n\n        # Ignore the field that corresponds to a dictionary\n        if name == \"init_vals\":\n            continue\n\n        elif name == \"travel_proportions\":\n            if value.size() != torch.Size([L, L]):\n                raise Exception(str(name) + error_str)\n\n        # `total_contact_matrix`, `school_contact_matrix`, `work_contact_matrix`\n        elif \"contact_matrix\" in name:\n            if value.size() == torch.Size([L, A, A]):\n                continue\n            elif value.size() != torch.Size([A, A]):\n                raise Exception(str(name) + error_str)\n            else:\n                setattr(self, name, value.view(1, A, A).expand(L, A, A))\n\n        # If scalar or already L x A x R, do not need to adjust\n        #   dimensions\n        elif value.size() == torch.Size([]):\n            continue\n\n        elif value.size() == torch.Size([L, A, R]):\n            continue\n\n        elif value.size() == torch.Size([L]):\n            setattr(self, name, value.view(L, 1, 1).expand(L, A, R))\n\n        elif value.size() == torch.Size([A, R]):\n            setattr(self, name, value.view(1, A, R).expand(L, A, R))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.FluTravelStateTensors","title":"<code>FluTravelStateTensors</code>  <code>dataclass</code>","text":"<p>Data container for tensors for <code>FluMetapopModel</code> -- used to store arrays that contain data across all subpopulations (collected from each location/subpopulation model). Note that not all fields in <code>FluSubpopState</code> are included -- we only include compartments needed for the travel model computation, for efficiency.</p> <p>Attributes:</p> Name Type Description <code>IP</code> <code>torch.Tensor of nonnegative integers</code> <p>presymptomatic infected compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"IP\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>IS</code> <code>torch.Tensor of nonnegative integers</code> <p>symptomatic infected compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"IS\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>IA</code> <code>torch.Tensor of nonnegative integers</code> <p>asymptomatic infected compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"IA\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>H</code> <code>torch.Tensor of nonnegative integers</code> <p>hospital compartment for location-age-risk groups -- the lth element holds current_val of Compartment \"H\" on the lth location / subpopulation on the associated <code>MetapopModel</code>.</p> <code>flu_contact_matrix</code> <code>torch.Tensor of nonnegative integers</code> <p>contact matrix for location-age-risk groups -- the lth element holds current_val of <code>FluContactMatrix</code> <code>Schedule</code> for subpopulation l -- this value is a combination of the total contact matrix, the work contact matrix, and the school contact matrix (and the value is adjusted depending on whether the date is a work or school day)</p> <code>init_vals</code> <code>dict</code> <p>dictionary of torch.Tensor instances, where keys correspond to \"IP\", \"IS\", \"IA\", and \"H\", and values correspond to their initial values for location-age-risk groups.</p> Source code in <code>CLT_BaseModel/flu_core/flu_data_structures.py</code> <pre><code>@dataclass\nclass FluTravelStateTensors:\n    \"\"\"\n    Data container for tensors for `FluMetapopModel` -- used to store arrays\n    that contain data across all subpopulations (collected from each\n    location/subpopulation model). Note that not all fields in\n    `FluSubpopState` are included -- we only include compartments\n    needed for the travel model computation, for efficiency.\n\n    Attributes:\n        IP (torch.Tensor of nonnegative integers):\n            presymptomatic infected compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"IP\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        IS (torch.Tensor of nonnegative integers):\n            symptomatic infected compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"IS\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        IA (torch.Tensor of nonnegative integers):\n            asymptomatic infected compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"IA\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        H (torch.Tensor of nonnegative integers):\n            hospital compartment for location-age-risk\n            groups -- the lth element holds current_val of\n            Compartment \"H\" on the lth location / subpopulation\n            on the associated `MetapopModel`.\n        flu_contact_matrix (torch.Tensor of nonnegative integers):\n            contact matrix for location-age-risk groups -- the\n            lth element holds current_val of `FluContactMatrix`\n            `Schedule` for subpopulation l -- this value is a\n            combination of the total contact matrix, the\n            work contact matrix, and the school contact matrix\n            (and the value is adjusted depending on whether\n            the date is a work or school day)\n        init_vals (dict):\n            dictionary of torch.Tensor instances, where keys\n            correspond to \"IP\", \"IS\", \"IA\", and \"H\", and values\n            correspond to their initial values for location-age-risk\n            groups.\n    \"\"\"\n\n    IP: torch.Tensor = None\n    IS: torch.Tensor = None\n    IA: torch.Tensor = None\n    H: torch.Tensor = None\n\n    flu_contact_matrix: torch.Tensor = None\n\n    init_vals: dict = field(default_factory=dict)\n\n    # Note: `init_vals: dict = {}` does NOT work --\n    #   gives \"mutable default\" argument\n\n    def save_current_vals_as_init_vals(self):\n\n        for field in fields(self):\n            if field.name == \"init_vals\":\n                continue\n            self.init_vals[field.name] = getattr(self, field.name).clone()\n\n    def reset_to_init_vals(self):\n\n        for name, val in self.init_vals.items():\n            setattr(self, name, val.clone())\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospToDead","title":"<code>HospToDead</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"H\" to \"D\" compartment. The functional form is the same across subpopulations.</p> <p>Each HospToDead instance forms a TransitionVariableGroup with a corresponding HospToRecovered instance (these two transition variables are jointly distributed).</p> <p>The rate of HospToDead decreases as population-level immunity against hospitalization increases.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class HospToDead(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"H\" to \"D\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each HospToDead instance forms a TransitionVariableGroup with\n    a corresponding HospToRecovered instance (these two\n    transition variables are jointly distributed).\n\n    The rate of HospToDead decreases as population-level immunity\n    against hospitalization increases.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n        vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n        inf_induced_proportional_risk_reduce = \\\n            inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n        vax_induced_proportional_risk_reduce = \\\n            vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.asarray(params.H_to_D_adjusted_prop * params.H_to_D_rate / immunity_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.HospToRecovered","title":"<code>HospToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"H\" to \"R\" compartment. The functional form is the same across subpopulations.</p> <p>Each HospToRecovered instance forms a TransitionVariableGroup with a corresponding HospToDead instance (these two transition variables are jointly distributed).</p> <p>Returns:</p> Type Description <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class HospToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"H\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each HospToRecovered instance forms a TransitionVariableGroup with\n    a corresponding HospToDead instance (these two\n    transition variables are jointly distributed).\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n        vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n        inf_induced_proportional_risk_reduce = \\\n            inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n        vax_induced_proportional_risk_reduce = \\\n            vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       (1 - params.H_to_D_adjusted_prop / immunity_force) * params.H_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.InfInducedImmunity","title":"<code>InfInducedImmunity</code>","text":"<p>               Bases: <code>EpiMetric</code></p> <p>EpiMetric-derived class for infection-induced population-level immunity.</p> <p>Population-level immunity increases as people move from \"R\" to \"S\" -- this is a design choice intended to avoid \"double-counting.\" People in \"R\" cannot be infected at all. People who move from \"R\" to \"S\" are susceptible again, but these recently-recovered people should have partial immunity. To handle this phenomenon, this epi metric increases as people move from \"R\" to \"S.\"</p> <p>Parameters:</p> Name Type Description Default <code>R_to_S</code> <code>RecoveredToSusceptible</code> <p>RecoveredToSusceptible TransitionVariable in the SubpopModel -- it is an attribute because the population-level immunity increases as people move from \"R\" to \"S\".</p> required <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class InfInducedImmunity(clt.EpiMetric):\n    \"\"\"\n    EpiMetric-derived class for infection-induced\n    population-level immunity.\n\n    Population-level immunity increases as people move\n    from \"R\" to \"S\" -- this is a design choice intended\n    to avoid \"double-counting.\" People in \"R\" cannot be\n    infected at all. People who move from \"R\" to \"S\"\n    are susceptible again, but these recently-recovered people\n    should have partial immunity. To handle this phenomenon,\n    this epi metric increases as people move from \"R\" to \"S.\"\n\n    Params:\n        R_to_S (RecoveredToSusceptible):\n            RecoveredToSusceptible TransitionVariable\n            in the SubpopModel -- it is an attribute\n            because the population-level immunity\n            increases as people move from \"R\" to \"S\".\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self, init_val, R_to_S):\n        super().__init__(init_val)\n        self.R_to_S = R_to_S\n\n    def get_change_in_current_val(self,\n                                  state: FluSubpopState,\n                                  params: FluSubpopParams,\n                                  num_timesteps: int):\n        # Note: the current values of transition variables already include\n        #   discretization (division by the number of timesteps) -- therefore,\n        #   we do not divide the first part of this equation by the number of\n        #   timesteps -- see `TransitionVariable` class's methods for getting\n        #   various realizations for more information\n\n        return (self.R_to_S.current_val / params.total_pop_age_risk) * \\\n               (1 - params.inf_induced_saturation * state.M - params.vax_induced_saturation * state.MV) - \\\n               params.inf_induced_immune_wane * state.M / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.PresympToSymp","title":"<code>PresympToSymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IP\" to \"IS\" compartment. The functional form is the same across subpopulations.</p> <p>Returns:</p> Type Description <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class PresympToSymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IP\" to \"IS\" compartment. The functional form is the same across\n    subpopulations.\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.IP_to_IS_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.RecoveredToSusceptible","title":"<code>RecoveredToSusceptible</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"R\" to \"S\" compartment. The functional form is the same across subpopulations.</p> <p>Returns:</p> Type Description <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class RecoveredToSusceptible(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"R\" to \"S\" compartment. The functional form is the same across\n    subpopulations.\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.R_to_S_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SusceptibleToExposed","title":"<code>SusceptibleToExposed</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"S\" to \"E\" compartment. The functional form is the same across subpopulations.</p> <p>The rate depends on the corresponding subpopulation's contact matrix, transmission rate beta, number infected (symptomatic, asymptomatic, and pre-symptomatic), and population-level immunity against infection, among other parameters.</p> <p>This is the most complicated transition variable in the flu model. If using metapopulation model (travel model), then the rate depends on the <code>total_mixing_exposure</code> attribute, which is a function of other subpopulations' states and parameters, and travel between subpopulations.</p> <p>If there is no metapopulation model, the rate is much simpler.</p> <p>Attributes:</p> Name Type Description <code>total_mixing_exposure</code> <code>np.ndarray of positive floats</code> <p>weighted infectious count (exposure) from movement within home location, travel to other locations, and visitors from other locations</p> <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SusceptibleToExposed(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"S\" to \"E\" compartment. The functional form is the same across\n    subpopulations.\n\n    The rate depends on the corresponding subpopulation's\n    contact matrix, transmission rate beta, number\n    infected (symptomatic, asymptomatic, and pre-symptomatic),\n    and population-level immunity against infection,\n    among other parameters.\n\n    This is the most complicated transition variable in the\n    flu model. If using metapopulation model (travel model), then\n    the rate depends on the `total_mixing_exposure` attribute,\n    which is a function of other subpopulations' states and\n    parameters, and travel between subpopulations.\n\n    If there is no metapopulation model, the rate\n    is much simpler.\n\n    Attributes:\n        total_mixing_exposure (np.ndarray of positive floats):\n            weighted infectious count (exposure) from movement\n            within home location, travel to other locations,\n            and visitors from other locations\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin: clt.Compartment,\n                 destination: clt.Compartment,\n                 transition_type: clt.TransitionTypes,\n                 is_jointly_distributed: str = False):\n\n        super().__init__(origin,\n                         destination,\n                         transition_type,\n                         is_jointly_distributed)\n\n        self.total_mixing_exposure = None\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray of shape (A, R)\n        \"\"\"\n\n        # If `total_mixing_exposure` has not been updated,\n        #   then there is no travel model -- so, simulate\n        #   this subpopulation entirely independently and\n        #   use the simplified transition rate that does not\n        #   depend on travel dynamics\n\n        beta_adjusted = compute_beta_adjusted(state, params)\n\n        inf_induced_inf_risk_reduce = params.inf_induced_inf_risk_reduce\n        inf_induced_proportional_risk_reduce = inf_induced_inf_risk_reduce / (1 - inf_induced_inf_risk_reduce)\n\n        vax_induced_inf_risk_reduce = params.vax_induced_inf_risk_reduce\n        vax_induced_proportional_risk_reduce = vax_induced_inf_risk_reduce / (1 - vax_induced_inf_risk_reduce)\n\n        immune_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                        vax_induced_proportional_risk_reduce * state.MV)\n\n        if self.total_mixing_exposure is not None:\n\n            # Note here `self.total_mixing_exposure` includes\n            #   `suscept_by_age` -- see `compute_total_mixing_exposure_prop`\n            #   in `flu_travel_functions`\n\n            # Need to convert tensor into array because combining np.ndarrays and\n            #   tensors doesn't work, and everything else is an array\n            return np.asarray(beta_adjusted * self.total_mixing_exposure / immune_force)\n\n        else:\n            wtd_presymp_asymp_by_age = compute_wtd_presymp_asymp_by_age(state, params)\n\n            # Super confusing syntax... but this is the pain of having A x R,\n            #   but having the contact matrix (contact patterns) be for\n            #   ONLY age groups\n            wtd_infectious_prop = np.divide(np.sum(state.IS, axis=1, keepdims=True) + wtd_presymp_asymp_by_age,\n                                            compute_pop_by_age(params))\n\n            raw_total_exposure = np.matmul(state.flu_contact_matrix, wtd_infectious_prop)\n\n            # The total rate is only age-dependent -- it's the same rate across age groups\n            return params.relative_suscept * (beta_adjusted * raw_total_exposure / immune_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SusceptibleToExposed.get_current_rate","title":"<code>get_current_rate(state: FluSubpopState, params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def get_current_rate(self,\n                     state: FluSubpopState,\n                     params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # If `total_mixing_exposure` has not been updated,\n    #   then there is no travel model -- so, simulate\n    #   this subpopulation entirely independently and\n    #   use the simplified transition rate that does not\n    #   depend on travel dynamics\n\n    beta_adjusted = compute_beta_adjusted(state, params)\n\n    inf_induced_inf_risk_reduce = params.inf_induced_inf_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_inf_risk_reduce / (1 - inf_induced_inf_risk_reduce)\n\n    vax_induced_inf_risk_reduce = params.vax_induced_inf_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_inf_risk_reduce / (1 - vax_induced_inf_risk_reduce)\n\n    immune_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                    vax_induced_proportional_risk_reduce * state.MV)\n\n    if self.total_mixing_exposure is not None:\n\n        # Note here `self.total_mixing_exposure` includes\n        #   `suscept_by_age` -- see `compute_total_mixing_exposure_prop`\n        #   in `flu_travel_functions`\n\n        # Need to convert tensor into array because combining np.ndarrays and\n        #   tensors doesn't work, and everything else is an array\n        return np.asarray(beta_adjusted * self.total_mixing_exposure / immune_force)\n\n    else:\n        wtd_presymp_asymp_by_age = compute_wtd_presymp_asymp_by_age(state, params)\n\n        # Super confusing syntax... but this is the pain of having A x R,\n        #   but having the contact matrix (contact patterns) be for\n        #   ONLY age groups\n        wtd_infectious_prop = np.divide(np.sum(state.IS, axis=1, keepdims=True) + wtd_presymp_asymp_by_age,\n                                        compute_pop_by_age(params))\n\n        raw_total_exposure = np.matmul(state.flu_contact_matrix, wtd_infectious_prop)\n\n        # The total rate is only age-dependent -- it's the same rate across age groups\n        return params.relative_suscept * (beta_adjusted * raw_total_exposure / immune_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympToHosp","title":"<code>SympToHosp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IS\" to \"H\" compartment. The functional form is the same across subpopulations.</p> <p>Each SympToHosp instance forms a TransitionVariableGroup with a corresponding SympToRecovered instance (these two transition variables are jointly distributed).</p> <p>The rate of SympToHosp decreases as population-level immunity against hospitalization increases.</p> <p>Returns:</p> Type Description <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SympToHosp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IS\" to \"H\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each SympToHosp instance forms a TransitionVariableGroup with\n    a corresponding SympToRecovered instance (these two\n    transition variables are jointly distributed).\n\n    The rate of SympToHosp decreases as population-level immunity\n    against hospitalization increases.\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n        inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n        vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n        vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.asarray(params.IS_to_H_rate * params.IS_to_H_adjusted_prop / immunity_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.SympToRecovered","title":"<code>SympToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IS\" to \"R\" compartment. The functional form is the same across subpopulations.</p> <p>Each SympToRecovered instance forms a TransitionVariableGroup with a corresponding SympToHosp instance (these two transition variables are jointly distributed).</p> <p>Returns:</p> Type Description <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class SympToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IS\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each SympToRecovered instance forms a TransitionVariableGroup with\n    a corresponding SympToHosp instance (these two\n    transition variables are jointly distributed).\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n        inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n        vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n        vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n        immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                          vax_induced_proportional_risk_reduce * state.MV)\n\n        return np.asarray((1 - params.IS_to_H_adjusted_prop / immunity_force) * params.IS_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.VaxInducedImmunity","title":"<code>VaxInducedImmunity</code>","text":"<p>               Bases: <code>EpiMetric</code></p> <p>EpiMetric-derived class for vaccine-induced population-level immunity.</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>class VaxInducedImmunity(clt.EpiMetric):\n    \"\"\"\n    EpiMetric-derived class for vaccine-induced\n    population-level immunity.\n    \"\"\"\n\n    def __init__(self, init_val):\n        super().__init__(init_val)\n\n    def get_change_in_current_val(self,\n                                  state: FluSubpopState,\n                                  params: FluSubpopParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        # Note: `state.daily_vaccines` (based on the value of the `DailyVaccines`\n        #   `Schedule` is NOT divided by the number of timesteps -- so we need to\n        #   do this division in the equation here.\n\n        return state.daily_vaccines / (params.total_pop_age_risk * num_timesteps) - \\\n               params.vax_induced_immune_wane * state.MV / num_timesteps\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.advance_timestep","title":"<code>advance_timestep(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float, save_calibration_targets: bool = False, save_tvar_history: bool = False) -&gt; Tuple[FluFullMetapopStateTensors, dict, dict]</code>","text":"<p>Advance the simulation one timestep, with length <code>dt</code>. Updates state corresponding to compartments and epidemiological metrics after computing transition variables and metric changes.</p> <p>Note that in this torch \"mean\" deterministic implementation... - We compute rates in the same way as the     <code>get_binom_deterministic_no_round</code>     transition type in the OOP code -- see     <code>TransitionVariables</code> class in     <code>clt_toolkit / base_components</code> for more details. - We also implement a \"mean\" deterministic analog     of the multinomial distribution to handle     multiple outflows from the same compartment - We do not round the transition variables - We also use <code>softplus</code>, a smooth approximation to the     ReLU function, to ensure that compartments are     nonnegative (which is not guaranteed using     the mean of a binomial/multinomial random variable     rather than sampling from those distributions).</p> <p>Returns:</p> Type Description <code>Tuple[FluFullMetapopStateTensors, dict, dict]</code> <p>New <code>FluFullMetapopStateTensors</code> with updated state, <code>dict</code> of calibration targets corresponding to state values or transition variable values used for calibration, and <code>dict</code> of transition variable values to save this history. If <code>save_calibration_targets</code> is <code>False</code>, then the corresponding <code>dict</code> is empty, and similarly with <code>save_tvar_history</code>.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def advance_timestep(state: FluFullMetapopStateTensors,\n                     params: FluFullMetapopParamsTensors,\n                     precomputed: FluPrecomputedTensors,\n                     dt: float,\n                     save_calibration_targets: bool=False,\n                     save_tvar_history: bool=False) -&gt; Tuple[FluFullMetapopStateTensors, dict, dict]:\n    \"\"\"\n    Advance the simulation one timestep, with length `dt`.\n    Updates state corresponding to compartments and\n    epidemiological metrics after computing transition variables\n    and metric changes.\n\n    Note that in this torch \"mean\" deterministic implementation...\n    - We compute rates in the same way as the\n        `get_binom_deterministic_no_round`\n        transition type in the OOP code -- see\n        `TransitionVariables` class in\n        `clt_toolkit / base_components` for more details.\n    - We also implement a \"mean\" deterministic analog\n        of the multinomial distribution to handle\n        multiple outflows from the same compartment\n    - We do not round the transition variables\n    - We also use `softplus`, a smooth approximation to the\n        ReLU function, to ensure that compartments are\n        nonnegative (which is not guaranteed using\n        the mean of a binomial/multinomial random variable\n        rather than sampling from those distributions).\n\n    Returns:\n        (Tuple[FluFullMetapopStateTensors, dict, dict]):\n            New `FluFullMetapopStateTensors` with updated state,\n            `dict` of calibration targets corresponding to state\n            values or transition variable values used for calibration,\n            and `dict` of transition variable values to save this\n            history. If `save_calibration_targets` is `False`,\n            then the corresponding `dict` is empty, and similarly with\n            `save_tvar_history`.\n    \"\"\"\n\n    S_to_E = compute_S_to_E(state, params, precomputed, dt)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    E_to_IP_rate = compute_E_to_IP_rate(params)\n    E_to_IA_rate = compute_E_to_IA_rate(params)\n    E_outgoing_total_rate = E_to_IP_rate + E_to_IA_rate\n    E_to_IA = state.E * (E_to_IA_rate / E_outgoing_total_rate) * \\\n              torch_approx_binom_probability_from_rate(E_outgoing_total_rate, dt)\n    E_to_IP = state.E * (E_to_IP_rate / E_outgoing_total_rate) * \\\n              torch_approx_binom_probability_from_rate(E_outgoing_total_rate, dt)\n\n    IA_to_R = compute_IA_to_R(state, params, dt)\n\n    IP_to_IS = compute_IP_to_IS(state, params, dt)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    IS_to_R_rate = compute_IS_to_R_rate(state, params)\n    IS_to_H_rate = compute_IS_to_H_rate(state, params)\n    IS_outgoing_total_rate = IS_to_R_rate + IS_to_H_rate\n    IS_to_R = state.IS * (IS_to_R_rate / IS_outgoing_total_rate) * \\\n              torch_approx_binom_probability_from_rate(IS_outgoing_total_rate, dt)\n    IS_to_H = state.IS * (IS_to_H_rate / IS_outgoing_total_rate) * \\\n              torch_approx_binom_probability_from_rate(IS_outgoing_total_rate, dt)\n\n    # Deterministic multinomial implementation to match\n    #   object-oriented version\n    H_to_R_rate = compute_H_to_R_rate(state, params)\n    H_to_D_rate = compute_H_to_D_rate(state, params)\n    H_outgoing_total_rate = H_to_R_rate + H_to_D_rate\n    H_to_R = state.H * (H_to_R_rate / H_outgoing_total_rate) * torch_approx_binom_probability_from_rate(\n        H_outgoing_total_rate, dt)\n    H_to_D = state.H * (H_to_D_rate / H_outgoing_total_rate) * torch_approx_binom_probability_from_rate(\n        H_outgoing_total_rate, dt)\n\n    R_to_S = compute_R_to_S(state, params, dt)\n\n    # Make sure compartments are nonnegative\n    S_new = torch.nn.functional.softplus(state.S + R_to_S - S_to_E)\n    E_new = torch.nn.functional.softplus(state.E + S_to_E - E_to_IP - E_to_IA)\n    IP_new = torch.nn.functional.softplus(state.IP + E_to_IP - IP_to_IS)\n    IS_new = torch.nn.functional.softplus(state.IS + IP_to_IS - IS_to_R - IS_to_H)\n    IA_new = torch.nn.functional.softplus(state.IA + E_to_IA - IA_to_R)\n    H_new = torch.nn.functional.softplus(state.H + IS_to_H - H_to_R - H_to_D)\n    R_new = torch.nn.functional.softplus(state.R + IS_to_R + IA_to_R + H_to_R - R_to_S)\n    D_new = torch.nn.functional.softplus(state.D + H_to_D)\n\n    # Update immunity variables\n    M_change = compute_M_change(state, params, precomputed, dt)\n    MV_change = compute_MV_change(state, params, precomputed, dt)\n    M_new = state.M + M_change\n    MV_new = state.MV + MV_change\n\n    state_new = FluFullMetapopStateTensors(S=S_new,\n                                           E=E_new,\n                                           IP=IP_new,\n                                           IS=IS_new,\n                                           IA=IA_new,\n                                           H=H_new,\n                                           R=R_new,\n                                           D=D_new,\n                                           M=M_new,\n                                           MV=MV_new,\n                                           absolute_humidity=state.absolute_humidity,\n                                           daily_vaccines=state.daily_vaccines,\n                                           flu_contact_matrix=state.flu_contact_matrix)\n\n    calibration_targets = {}\n    if save_calibration_targets:\n        calibration_targets[\"IS_to_H\"] = IS_to_H\n\n    transition_variables = {}\n    if save_tvar_history:\n        transition_variables[\"S_to_E\"] = S_to_E\n        transition_variables[\"E_to_IP\"] = E_to_IP\n        transition_variables[\"E_to_IA\"] = E_to_IA\n        transition_variables[\"IA_to_R\"] = IA_to_R\n        transition_variables[\"IP_to_IS\"] = IP_to_IS\n        transition_variables[\"IS_to_R\"] = IS_to_R\n        transition_variables[\"IS_to_H\"] = IS_to_H\n        transition_variables[\"H_to_R\"] = H_to_R\n        transition_variables[\"H_to_D\"] = H_to_D\n        transition_variables[\"R_to_S\"] = R_to_S\n        transition_variables[\"M_change\"] = M_change\n        transition_variables[\"MV_change\"] = MV_change\n\n    return state_new, calibration_targets, transition_variables\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_E_to_IA_rate","title":"<code>compute_E_to_IA_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_E_to_IA_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    return params.E_to_I_rate * params.E_to_IA_prop\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_E_to_IP_rate","title":"<code>compute_E_to_IP_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_E_to_IP_rate(params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    return params.E_to_I_rate * (1 - params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_H_to_D_rate","title":"<code>compute_H_to_D_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_H_to_D_rate(state: FluFullMetapopStateTensors,\n                        params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.H_to_D_rate * params.H_to_D_adjusted_prop / immunity_force\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_H_to_R_rate","title":"<code>compute_H_to_R_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_H_to_R_rate(state: FluFullMetapopStateTensors,\n                        params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_death_risk_reduce = params.inf_induced_death_risk_reduce\n    vax_induced_death_risk_reduce = params.vax_induced_death_risk_reduce\n\n    inf_induced_proportional_risk_reduce = \\\n        inf_induced_death_risk_reduce / (1 - inf_induced_death_risk_reduce)\n\n    vax_induced_proportional_risk_reduce = \\\n        vax_induced_death_risk_reduce / (1 - vax_induced_death_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.H_to_R_rate * (1 - params.H_to_D_adjusted_prop / immunity_force)\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IA_to_R","title":"<code>compute_IA_to_R(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IA_to_R(state: FluFullMetapopStateTensors,\n                    params: FluFullMetapopParamsTensors,\n                    dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.IA_to_R_rate\n\n    IA_to_R = state.IA * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return IA_to_R\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IP_to_IS","title":"<code>compute_IP_to_IS(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IP_to_IS(state: FluFullMetapopStateTensors,\n                     params: FluFullMetapopParamsTensors,\n                     dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.IP_to_IS_rate\n\n    IP_to_IS = state.IP * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return IP_to_IS\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IS_to_H_rate","title":"<code>compute_IS_to_H_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IS_to_H_rate(state: FluFullMetapopStateTensors,\n                         params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.IS_to_H_rate * params.IS_to_H_adjusted_prop / immunity_force\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_IS_to_R_rate","title":"<code>compute_IS_to_R_rate(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_IS_to_R_rate(state: FluFullMetapopStateTensors,\n                         params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    inf_induced_hosp_risk_reduce = params.inf_induced_hosp_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_hosp_risk_reduce / (1 - inf_induced_hosp_risk_reduce)\n\n    vax_induced_hosp_risk_reduce = params.vax_induced_hosp_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_hosp_risk_reduce / (1 - vax_induced_hosp_risk_reduce)\n\n    immunity_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                      vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = params.IS_to_R_rate * (1 - params.IS_to_H_adjusted_prop / immunity_force)\n\n    return rate\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_MV_change","title":"<code>compute_MV_change(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_MV_change(state: FluFullMetapopStateTensors,\n                      params: FluFullMetapopParamsTensors,\n                      precomputed: FluPrecomputedTensors,\n                      dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    MV_change = state.daily_vaccines / precomputed.total_pop_LAR_tensor - \\\n                params.vax_induced_immune_wane * state.MV\n\n    return MV_change * dt\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_M_change","title":"<code>compute_M_change(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_M_change(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors,\n                     precomputed: FluPrecomputedTensors,\n                     dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    # Note: already includes dt\n    R_to_S = state.R * torch_approx_binom_probability_from_rate(params.R_to_S_rate, dt)\n\n    M_change = (R_to_S / precomputed.total_pop_LAR_tensor) * \\\n               (1 - params.inf_induced_saturation * state.M - params.vax_induced_saturation * state.MV) - \\\n               params.inf_induced_immune_wane * state.M * dt\n\n    # Because R_to_S includes dt already, we do not return M_change * dt -- we only multiply\n    #   the last term in the expression above by dt\n    return M_change\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_R_to_S","title":"<code>compute_R_to_S(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_R_to_S(state: FluFullMetapopStateTensors,\n                   params: FluFullMetapopParamsTensors,\n                   dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    rate = params.R_to_S_rate\n\n    R_to_S = state.R * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return R_to_S\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_S_to_E","title":"<code>compute_S_to_E(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, dt: float) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_S_to_E(state: FluFullMetapopStateTensors,\n                   params: FluFullMetapopParamsTensors,\n                   precomputed: FluPrecomputedTensors,\n                   dt: float) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    # Needs flu_contact_matrix to be in state for this\n    total_mixing_exposure = compute_total_mixing_exposure(state, params, precomputed)\n\n    if total_mixing_exposure.size() != torch.Size([precomputed.L,\n                                                   precomputed.A,\n                                                   precomputed.R]):\n        raise Exception(\"force_of_infection must be L x A x R corresponding \\n\"\n                        \"to number of locations (subpopulations), age groups, \\n\"\n                        \"and risk groups.\")\n\n    beta_adjusted = compute_beta_adjusted(state, params)\n\n    inf_induced_inf_risk_reduce = params.inf_induced_inf_risk_reduce\n    inf_induced_proportional_risk_reduce = inf_induced_inf_risk_reduce / (1 - inf_induced_inf_risk_reduce)\n\n    vax_induced_inf_risk_reduce = params.vax_induced_inf_risk_reduce\n    vax_induced_proportional_risk_reduce = vax_induced_inf_risk_reduce / (1 - vax_induced_inf_risk_reduce)\n\n    immune_force = (1 + inf_induced_proportional_risk_reduce * state.M +\n                    vax_induced_proportional_risk_reduce * state.MV)\n\n    rate = beta_adjusted * total_mixing_exposure / immune_force\n\n    S_to_E = state.S * torch_approx_binom_probability_from_rate(rate, dt)\n\n    return S_to_E\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_active_pop_LAR","title":"<code>compute_active_pop_LAR(state: FluTravelStateTensors, _params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Compute the active population for location-age-risk (l, a, r) as a tensor. Used to compute the effective population in the travel model, which is the population size adjusted for incoming visitors, residents traveling, and assuming hospitalized individuals are not mobile enough to infect others.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A, R): Active population: those who are not hospitalized (i.e. those who are not too sick to move and travel regularly)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_active_pop_LAR(state: FluTravelStateTensors,\n                           _params: FluTravelParamsTensors,\n                           precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Compute the active population for location-age-risk\n    (l, a, r) as a tensor. Used to compute the\n    effective population in the travel model, which is\n    the population size adjusted for incoming visitors,\n    residents traveling, and assuming hospitalized\n    individuals are not mobile enough to infect others.\n\n    Returns:\n        torch.Tensor of size (L, A, R):\n            Active population: those who are not\n            hospitalized (i.e. those who are not too sick\n            to move and travel regularly)\n    \"\"\"\n\n    # _params is not used now -- but this is included for\n    #   function signature consistency with other\n    #   similar computation functions\n\n    return precomputed.total_pop_LAR_tensor - state.H\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_beta_adjusted","title":"<code>compute_beta_adjusted(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Computes beta-adjusted humidity.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, R))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_beta_adjusted(state: FluFullMetapopStateTensors,\n                          params: FluFullMetapopParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Computes beta-adjusted humidity.\n\n    Returns:\n        (torch.Tensor of size (L, A, R))\n    \"\"\"\n\n    absolute_humidity = state.absolute_humidity\n    beta_adjusted = params.beta_baseline * (1 + params.humidity_impact * np.exp(-180 * absolute_humidity))\n\n    return beta_adjusted\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_effective_pop_LA","title":"<code>compute_effective_pop_LA(state: FluTravelStateTensors, params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A): Effective population, summed over risk groups. See <code>compute_active_pop_LAR</code> docstring for more information.</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_effective_pop_LA(state: FluTravelStateTensors,\n                             params: FluTravelParamsTensors,\n                             precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor of size (L, A):\n            Effective population, summed over risk groups.\n            See `compute_active_pop_LAR` docstring for more\n            information.\n    \"\"\"\n\n    active_pop_LAR = compute_active_pop_LAR(state, params, precomputed)\n\n    # Nonlocal travel proportions is L x L\n    # Active population LAR is L x A x R\n    outside_visitors_LAR = torch.einsum(\"kl,kar-&gt;lar\",\n                                        precomputed.nonlocal_travel_prop,\n                                        active_pop_LAR)\n\n    # This is correct -- Dave checked in meeting -- we don't need Einstein\n    #   notation here!\n    # In computation, broadcast sum_residents_nonlocal_travel_prop to be L x 1 x 1\n    traveling_residents_LAR = precomputed.sum_residents_nonlocal_travel_prop[:, None, None] * \\\n                              active_pop_LAR\n\n    mobility_modifier = params.mobility_modifier[0, :, 0]\n\n    effective_pop_LA = precomputed.total_pop_LA + mobility_modifier * \\\n                       torch.sum(outside_visitors_LAR + traveling_residents_LAR, dim=2)\n\n    return effective_pop_LA\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_flu_contact_matrix","title":"<code>compute_flu_contact_matrix(params: FluFullMetapopParamsTensors, schedules: FluFullMetapopScheduleTensors, day_counter: int) -&gt; torch.Tensor</code>","text":"<p>Computes flu model contact matrix in tensor format -- makes adjustments based on whether day is school day or work day.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>(torch.Tensor of size (L, A, A))</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def compute_flu_contact_matrix(params: FluFullMetapopParamsTensors,\n                               schedules: FluFullMetapopScheduleTensors,\n                               day_counter: int) -&gt; torch.Tensor:\n    \"\"\"\n    Computes flu model contact matrix in tensor format -- makes\n    adjustments based on whether day is school day or work day.\n\n    Returns:\n        (torch.Tensor of size (L, A, A))\n    \"\"\"\n\n    # Here, using schedules.is_school_day[day_counter][:,:,0] and similarly for\n    #   is_work_day because each contact matrix (as a metapop tensor) is L x A x A --\n    #   we don't use risk -- assume here that we do not have a different school/work-day\n    #   schedule based on risk, so just grab the first risk group\n    # But then we have to take (1 - schedules.is_school_day[day_counter][:, :, 0]), which is\n    #   L x A, and then make it L x A x 1 (unsqueeze the last dimension) to make the\n    #   broadcasting work (because this gets element-wise multiplied by params.school_contact_matrix)\n    flu_contact_matrix = \\\n        params.total_contact_matrix - \\\n        params.school_contact_matrix * (1 - schedules.is_school_day[day_counter][:, :, 0]).unsqueeze(dim=2) - \\\n        params.work_contact_matrix * (1 - schedules.is_work_day[day_counter][:, :, 0]).unsqueeze(dim=2)\n\n    return flu_contact_matrix\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_local_to_local_exposure","title":"<code>compute_local_to_local_exposure(flu_contact_matrix: torch.Tensor, mobility_modifier: torch.Tensor, sum_residents_nonlocal_travel_prop: torch.Tensor, wtd_infectious_ratio_LLA: torch.Tensor, location_ix: int) -&gt; torch.Tensor</code>","text":"<p>Raw means that this is unnormalized by <code>relative_suscept</code>. Excludes beta and population-level immunity adjustments -- those are factored in later.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (A): For a given location (specified by <code>location_ix</code>), compute local transmission caused by residents traveling within their home location, summed over risk groups.</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_local_to_local_exposure(flu_contact_matrix: torch.Tensor,\n                                    mobility_modifier: torch.Tensor,\n                                    sum_residents_nonlocal_travel_prop: torch.Tensor,\n                                    wtd_infectious_ratio_LLA: torch.Tensor,\n                                    location_ix: int) -&gt; torch.Tensor:\n    \"\"\"\n    Raw means that this is unnormalized by `relative_suscept`.\n    Excludes beta and population-level immunity adjustments --\n    those are factored in later.\n\n    Returns:\n        torch.Tensor of size (A):\n            For a given location (specified by `location_ix`), compute\n            local transmission caused by residents traveling within their\n            home location, summed over risk groups.\n    \"\"\"\n\n    # WARNING: we assume `mobility_modifier` is input as (A, 1) --\n    # if this changes, we have to change the implementation.\n    # The risk dimension does not have unique values, so we just\n    # grab the first element of the risk dimension.\n    mobility_modifier = mobility_modifier[location_ix, :, 0]\n\n    result = (1 - mobility_modifier * sum_residents_nonlocal_travel_prop[location_ix]) * \\\n             torch.matmul(flu_contact_matrix[location_ix, :, :],\n                          wtd_infectious_ratio_LLA[location_ix, location_ix, :])\n\n    return result\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_outside_visitors_exposure","title":"<code>compute_outside_visitors_exposure(flu_contact_matrix: torch.Tensor, mobility_modifier: torch.Tensor, travel_proportions: torch.Tensor, wtd_infectious_ratio_LLA: torch.Tensor, local_ix: int, visitors_ix: int) -&gt; torch.Tensor</code>","text":"<p>Computes raw (unnormalized by <code>relative_suscept</code>) transmission to <code>local_ix</code> due to outside visitors from <code>visitors_ix</code>. Excludes beta and population-level immunity adjustments -- those are factored in later.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (A)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_outside_visitors_exposure(flu_contact_matrix: torch.Tensor,\n                                      mobility_modifier: torch.Tensor,\n                                      travel_proportions: torch.Tensor,\n                                      wtd_infectious_ratio_LLA: torch.Tensor,\n                                      local_ix: int,\n                                      visitors_ix: int) -&gt; torch.Tensor:\n    \"\"\"\n    Computes raw (unnormalized by `relative_suscept`) transmission\n    to `local_ix` due to outside visitors from `visitors_ix`.\n    Excludes beta and population-level immunity adjustments --\n    those are factored in later.\n\n    Returns:\n        torch.Tensor of size (A)\n    \"\"\"\n\n    # In location `local_ix`, we are looking at the visitors from\n    #   `visitors_ix` who come to `local_ix` (and infect folks in `local_ix`)\n\n    # See WARNING in `compute_local_to_local_exposure()`\n    mobility_modifier = mobility_modifier[visitors_ix, :, 0]\n\n    result = travel_proportions[visitors_ix, local_ix] * \\\n             torch.matmul(mobility_modifier * flu_contact_matrix[local_ix, :, :],\n                          wtd_infectious_ratio_LLA[visitors_ix, local_ix, :])\n\n    return result\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_pop_by_age","title":"<code>compute_pop_by_age(subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A x 1 array -- where A is the number of age groups -- where ith element corresponds to total population (across all compartments, including \"D\", and across all risk groups) in age group i</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def compute_pop_by_age(subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray:\n            A x 1 array -- where A is the number of age groups --\n            where ith element corresponds to total population\n            (across all compartments, including \"D\", and across all risk groups)\n            in age group i\n    \"\"\"\n\n    return np.sum(subpop_params.total_pop_age_risk, axis=1, keepdims=True)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_residents_traveling_exposure","title":"<code>compute_residents_traveling_exposure(flu_contact_matrix: torch.Tensor, mobility_modifier: torch.Tensor, travel_proportions: torch.Tensor, wtd_infectious_ratio_LLA: torch.Tensor, local_ix: int, dest_ix: int) -&gt; torch.Tensor</code>","text":"<p>Computes raw (unnormalized by <code>relative_suscept</code>) transmission to <code>local_ix</code>, due to residents of <code>local_ix</code> traveling to <code>dest_ix</code> and getting infected in <code>dest_ix</code>. Excludes beta and population-level immunity adjustments -- those are factored in later.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (A)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_residents_traveling_exposure(flu_contact_matrix: torch.Tensor,\n                                         mobility_modifier: torch.Tensor,\n                                         travel_proportions: torch.Tensor,\n                                         wtd_infectious_ratio_LLA: torch.Tensor,\n                                         local_ix: int,\n                                         dest_ix: int) -&gt; torch.Tensor:\n    \"\"\"\n    Computes raw (unnormalized by `relative_suscept`) transmission\n    to `local_ix`, due to residents of `local_ix` traveling to `dest_ix`\n    and getting infected in `dest_ix`. Excludes beta and population-level\n    immunity adjustments -- those are factored in later.\n\n    Returns:\n        torch.Tensor of size (A)\n    \"\"\"\n\n    # See WARNING in `compute_local_to_local_exposure()`\n    mobility_modifier = mobility_modifier[local_ix, :, 0]\n\n    result = mobility_modifier * travel_proportions[local_ix, dest_ix] * \\\n             torch.matmul(flu_contact_matrix[local_ix, :, :],\n                          wtd_infectious_ratio_LLA[dest_ix, dest_ix, :])\n\n    return result\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_total_mixing_exposure","title":"<code>compute_total_mixing_exposure(state: FluTravelStateTensors, params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Computes \"total mixing exposure\" for location-age-risk (l, a, r) -- the rate of exposure to infectious individuals, accounting for both local transmission, incoming visitors, and residents traveling. Normalized by <code>relative_suscept</code>!</p> <p>Combines subroutines <code>compute_local_to_local_exposure()</code>, <code>compute_outside_visitors_exposure()</code>, and <code>compute_residents_traveling_exposure()</code>. Note that these subroutines do not include relative susceptibility -- but this function includes relative susceptibility -- this is to avoid unnecessary repeated multiplication by relative susceptible in each subroutine.</p> <p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_total_mixing_exposure(state: FluTravelStateTensors,\n                                  params: FluTravelParamsTensors,\n                                  precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Computes \"total mixing exposure\" for location-age-risk\n    (l, a, r) -- the rate of exposure to infectious individuals,\n    accounting for both local transmission, incoming visitors, and\n    residents traveling. **Normalized by `relative_suscept`!**\n\n    Combines subroutines `compute_local_to_local_exposure()`,\n    `compute_outside_visitors_exposure()`, and `compute_residents_traveling_exposure()`.\n    Note that these subroutines do not include relative susceptibility --\n    but this function includes relative susceptibility -- this is to avoid\n    unnecessary repeated multiplication by relative susceptible in each subroutine.\n\n    Returns:\n        torch.Tensor of size (L, A, R)\n    \"\"\"\n\n    L, A, R = precomputed.L, precomputed.A, precomputed.R\n\n    mobility_modifier = params.mobility_modifier\n    flu_contact_matrix = state.flu_contact_matrix\n    travel_proportions = params.travel_proportions\n    sum_residents_nonlocal_travel_prop = precomputed.sum_residents_nonlocal_travel_prop\n    wtd_infectious_ratio_LLA = compute_wtd_infectious_ratio_LLA(state, params, precomputed)\n\n    relative_suscept = params.relative_suscept[0, :, 0]\n\n    total_mixing_exposure = torch.tensor(np.zeros((L, A, R)))\n\n    # Couldn't figure out how to do this without two for-loops ;)\n    # Welcoming any efficiency improvements!\n    for l in np.arange(L):\n\n        raw_total_mixing_exposure = torch.tensor(np.zeros(A))\n\n        raw_total_mixing_exposure = raw_total_mixing_exposure + \\\n                                    compute_local_to_local_exposure(flu_contact_matrix,\n                                                                    mobility_modifier,\n                                                                    sum_residents_nonlocal_travel_prop,\n                                                                    wtd_infectious_ratio_LLA,\n                                                                    l)\n\n        for k in np.arange(L):\n            raw_total_mixing_exposure = raw_total_mixing_exposure + \\\n                                        compute_outside_visitors_exposure(\n                                            flu_contact_matrix,\n                                            mobility_modifier,\n                                            travel_proportions,\n                                            wtd_infectious_ratio_LLA,\n                                            l,\n                                            k)\n\n            raw_total_mixing_exposure = raw_total_mixing_exposure + \\\n                                        compute_residents_traveling_exposure(\n                                            flu_contact_matrix,\n                                            mobility_modifier,\n                                            travel_proportions,\n                                            wtd_infectious_ratio_LLA,\n                                            l,\n                                            k)\n\n        normalized_total_mixing_exposure = relative_suscept * raw_total_mixing_exposure\n\n        total_mixing_exposure[l, :, :] = normalized_total_mixing_exposure.view(A, 1).expand((A, R))\n\n    return total_mixing_exposure\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_wtd_infectious_LA","title":"<code>compute_wtd_infectious_LA(state: FluTravelStateTensors, params: FluTravelParamsTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, A): Weighted infectious, summed over risk groups: includes presymptomatic, asymptomatic, and symptomatic, weighted by relative infectiousness</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_wtd_infectious_LA(state: FluTravelStateTensors,\n                              params: FluTravelParamsTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor of size (L, A):\n            Weighted infectious, summed over risk groups:\n            includes presymptomatic, asymptomatic, and symptomatic,\n            weighted by relative infectiousness\n    \"\"\"\n\n    # Einstein notation here means sum over risk groups\n    IS = torch.einsum(\"lar-&gt;la\", state.IS)\n    wtd_IP = \\\n        params.IP_relative_inf * torch.einsum(\"lar-&gt;la\", state.IP)\n    wtd_IA = \\\n        params.IA_relative_inf * torch.einsum(\"lar-&gt;la\", state.IA)\n\n    return IS + wtd_IP + wtd_IA\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_wtd_infectious_ratio_LLA","title":"<code>compute_wtd_infectious_ratio_LLA(state: FluTravelStateTensors, params: FluTravelParamsTensors, precomputed: FluPrecomputedTensors) -&gt; torch.Tensor</code>","text":"<p>Returns:</p> Type Description <code>Tensor</code> <p>torch.Tensor of size (L, L, A): Element i,j,a corresponds to ratio of weighted infectious people in location i, age group a (summed over risk groups) to the effective population in location j (summed over risk groups)</p> Source code in <code>CLT_BaseModel/flu_core/flu_travel_functions.py</code> <pre><code>def compute_wtd_infectious_ratio_LLA(state: FluTravelStateTensors,\n                                     params: FluTravelParamsTensors,\n                                     precomputed: FluPrecomputedTensors) -&gt; torch.Tensor:\n    \"\"\"\n    Returns:\n        torch.Tensor of size (L, L, A):\n            Element i,j,a corresponds to ratio of weighted infectious people\n            in location i, age group a (summed over risk groups) to the effective\n            population in location j (summed over risk groups)\n    \"\"\"\n\n    wtd_infectious_LA = compute_wtd_infectious_LA(state, params)\n\n    effective_pop_LA = compute_effective_pop_LA(state, params, precomputed)\n\n    prop_wtd_infectious = torch.einsum(\"ka,la-&gt;kla\",\n                                       wtd_infectious_LA,\n                                       1 / effective_pop_LA)\n\n    return prop_wtd_infectious\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.compute_wtd_presymp_asymp_by_age","title":"<code>compute_wtd_presymp_asymp_by_age(subpop_state: FluSubpopState, subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns weighted sum of IP and IA compartment for     subpopulation with given state and parameters.     IP and IA are weighted by their relative infectiousness     respectively, and then summed over risk groups.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray of shape (A, R)</p> Source code in <code>CLT_BaseModel/flu_core/flu_components.py</code> <pre><code>def compute_wtd_presymp_asymp_by_age(subpop_state: FluSubpopState,\n                                     subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns weighted sum of IP and IA compartment for\n        subpopulation with given state and parameters.\n        IP and IA are weighted by their relative infectiousness\n        respectively, and then summed over risk groups.\n\n    Returns:\n        np.ndarray of shape (A, R)\n    \"\"\"\n\n    # sum over risk groups\n    wtd_IP = \\\n        subpop_params.IP_relative_inf * np.sum(subpop_state.IP, axis=1, keepdims=True)\n    wtd_IA = \\\n        subpop_params.IA_relative_inf * np.sum(subpop_state.IA, axis=1, keepdims=True)\n\n    return wtd_IP + wtd_IA\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.create_dict_of_tensors","title":"<code>create_dict_of_tensors(d: dict, requires_grad: bool = True) -&gt; dict</code>","text":"<p>Converts dictionary entries to <code>tensor</code> (of type <code>torch.float32</code>) and if <code>requires_grad</code> is <code>True</code>, turns on gradient tracking for each entry -- returns new dictionary.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def create_dict_of_tensors(d: dict,\n                           requires_grad: bool = True) -&gt; dict:\n    \"\"\"\n    Converts dictionary entries to `tensor` (of type `torch.float32`)\n    and if `requires_grad` is `True`, turns on gradient tracking for\n    each entry -- returns new dictionary.\n    \"\"\"\n\n    def to_tensor(k, v):\n        if v is None:\n            return None\n        else:\n            return torch.tensor(v, dtype=torch.float32, requires_grad=requires_grad)\n\n    return {k: to_tensor(k, v) for k, v in d.items()}\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.torch_approx_binom_probability_from_rate","title":"<code>torch_approx_binom_probability_from_rate(rate, dt)</code>","text":"<p>Torch-compatible implementation of converting a rate into a probability. See analogous numpy implementation <code>base_components/approx_binom_probability_from_rate()</code> docstring for details.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def torch_approx_binom_probability_from_rate(rate, dt):\n    \"\"\"\n    Torch-compatible implementation of converting a\n    rate into a probability. See analogous numpy implementation\n    `base_components/approx_binom_probability_from_rate()` docstring\n    for details.\n    \"\"\"\n\n    return 1 - torch.exp(-rate * dt)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.torch_simulate_full_history","title":"<code>torch_simulate_full_history(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, schedules: FluFullMetapopScheduleTensors, num_days: int, timesteps_per_day: int) -&gt; Tuple[dict, dict]</code>","text":"<p>Simulates the flu model with a differentiable torch implementation that carries out <code>binom_deterministic_no_round</code> transition types -- returns hospital admits for calibration use.</p> <p>See subroutine <code>advance_timestep</code> for additional details.</p> <p>Returns:</p> Type Description <code>Tuple[dict, dict]</code> <p>Returns hospital admits (the IS to H transition variable value) for day, location, age, risk, in tensor format.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def torch_simulate_full_history(state: FluFullMetapopStateTensors,\n                                params: FluFullMetapopParamsTensors,\n                                precomputed: FluPrecomputedTensors,\n                                schedules: FluFullMetapopScheduleTensors,\n                                num_days: int,\n                                timesteps_per_day: int) -&gt; Tuple[dict, dict]:\n    \"\"\"\n    Simulates the flu model with a differentiable torch implementation\n    that carries out `binom_deterministic_no_round` transition types --\n    returns hospital admits for calibration use.\n\n    See subroutine `advance_timestep` for additional details.\n\n    Returns:\n        (Tuple[dict, dict]):\n            Returns hospital admits (the IS to H transition variable value)\n            for day, location, age, risk, in tensor format.\n    \"\"\"\n\n    dt = 1 / float(timesteps_per_day)\n\n    state_history_dict = defaultdict(list)\n    tvar_history_dict = defaultdict(list)\n\n    # This could probably be written better so we don't have\n    #   unused variables \"_\" that grab `advance_timestep` output?\n\n    for day in range(num_days):\n        state = update_state_with_schedules(state, params, schedules, day)\n\n        for timestep in range(timesteps_per_day):\n            if timestep == timesteps_per_day-1:\n                state, _, tvar_history = \\\n                    advance_timestep(state, params, precomputed, dt, save_tvar_history=True)\n                for key in tvar_history:\n                    tvar_history_dict[key].append(tvar_history[key])\n            else:\n                state, _, _ = \\\n                    advance_timestep(state, params, precomputed, dt, save_tvar_history=False)\n\n        for field in fields(state):\n            if field.name == \"init_vals\":\n                continue\n            state_history_dict[str(field.name)].append(getattr(state, field.name).clone())\n\n    return state_history_dict, tvar_history_dict\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.torch_simulation_hospital_admits","title":"<code>torch_simulation_hospital_admits(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, precomputed: FluPrecomputedTensors, schedules: FluFullMetapopScheduleTensors, num_days: int, timesteps_per_day: int) -&gt; torch.Tensor</code>","text":"<p>Analogous to <code>torch_simulate_full_history</code> but only saves and returns hospital admits for calibration use.</p> <p>Returns:</p> Type Description <code>torch.Tensor of size (num_days, L, A, R)</code> <p>Returns hospital admits (the IS to H transition variable value) for day, location, age, risk, in tensor format.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def torch_simulation_hospital_admits(state: FluFullMetapopStateTensors,\n                                     params: FluFullMetapopParamsTensors,\n                                     precomputed: FluPrecomputedTensors,\n                                     schedules: FluFullMetapopScheduleTensors,\n                                     num_days: int,\n                                     timesteps_per_day: int) -&gt; torch.Tensor:\n    \"\"\"\n    Analogous to `torch_simulate_full_history` but only saves and\n    returns hospital admits for calibration use.\n\n    Returns:\n        (torch.Tensor of size (num_days, L, A, R)):\n            Returns hospital admits (the IS to H transition variable value)\n            for day, location, age, risk, in tensor format.\n    \"\"\"\n\n    hospital_admits_history = []\n\n    dt = 1 / float(timesteps_per_day)\n\n    for day in range(num_days):\n        state = update_state_with_schedules(state, params, schedules, day)\n        for timestep in range(timesteps_per_day):\n            state, calibration_targets, _ = advance_timestep(state, params, precomputed, day, dt)\n        hospital_admits_history.append(calibration_targets[\"IS_to_H\"].clone())\n\n    return torch.stack(hospital_admits_history)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_core.update_state_with_schedules","title":"<code>update_state_with_schedules(state: FluFullMetapopStateTensors, params: FluFullMetapopParamsTensors, schedules: FluFullMetapopScheduleTensors, day_counter: int) -&gt; FluFullMetapopStateTensors</code>","text":"<p>Returns new dataclass formed by copying the current <code>state</code> and updating specific values according to <code>schedules</code> and the simulation's current <code>day_counter</code>.</p> <p>Returns:</p> Type Description <code>FluFullMetapopStateTensors</code> <p>New state with updated schedule-related values:   - <code>flu_contact_matrix</code>   - <code>absolute_humidity</code>   - <code>daily_vaccines</code> All other fields remain unchanged from the input <code>state</code>.</p> Source code in <code>CLT_BaseModel/flu_core/flu_torch_det_components.py</code> <pre><code>def update_state_with_schedules(state: FluFullMetapopStateTensors,\n                                params: FluFullMetapopParamsTensors,\n                                schedules: FluFullMetapopScheduleTensors,\n                                day_counter: int) -&gt; FluFullMetapopStateTensors:\n    \"\"\"\n    Returns new dataclass formed by copying the current `state`\n    and updating specific values according to `schedules` and\n    the simulation's current `day_counter`.\n\n    Returns:\n        (FluFullMetapopStateTensors):\n            New state with updated schedule-related values:\n              - `flu_contact_matrix`\n              - `absolute_humidity`\n              - `daily_vaccines`\n            All other fields remain unchanged from the input `state`.\n    \"\"\"\n\n    flu_contact_matrix = compute_flu_contact_matrix(params, schedules, day_counter)\n    absolute_humidity = schedules.absolute_humidity[day_counter]\n    daily_vaccines = schedules.daily_vaccines[day_counter]\n\n    state_new = FluFullMetapopStateTensors(\n        S=state.S,\n        E=state.E,\n        IP=state.IP,\n        IS=state.IS,\n        IA=state.IA,\n        H=state.H,\n        R=state.R,\n        D=state.D,\n        M=state.M,\n        MV=state.MV,\n        absolute_humidity=absolute_humidity,\n        daily_vaccines=daily_vaccines,\n        flu_contact_matrix=flu_contact_matrix\n    )\n\n    return state_new\n</code></pre>"},{"location":"flu_components_walkthrough/","title":"Flu Model Creation Walkthrough","text":"<p>This page is getting updated, please check back soon!</p>"},{"location":"flu_input_requirements/","title":"Math-to-Code Input Mappings","text":"<p> \\(\\def\\rateRtoS{\\sigma^{R\\rightarrow S}}\\) \\(\\def\\rateEtoI{\\sigma^{E \\rightarrow [IP, IA]}}\\) \\(\\def\\rateIPtoIS{\\sigma^{IP \\rightarrow IS}}\\) \\(\\def\\rateIStoH{\\sigma^{IS\\rightarrow H}}\\) \\(\\def\\rateHtoD{\\sigma^{H\\rightarrow D}}\\) \\(\\def\\rateIAtoR{\\gamma^{IA\\rightarrow R}}\\) \\(\\def\\rateHtoR{\\gamma^{H\\rightarrow R}}\\) \\(\\def\\rateIStoR{\\gamma^{IS\\rightarrow R}}\\) \\(\\def\\totalforceofinfection{\\lambda^{(\\ell), \\text{total}}_{a,r}(t)}\\) \\(\\def\\propIA{\\pi^{IA}}\\) \\(\\def\\propH{\\pi^H}\\) \\(\\def\\propD{\\pi^D}\\) \\(\\def\\adjustedpropH{\\tilde{\\pi}^H}\\) \\(\\def\\adjustedpropD{\\tilde{\\pi}^D}\\) </p> <p>Here, we provide mappings between the mathematical variables in the mathematical formulation and input variable names in the code. For users to customize the values (not the structure) of the flu model given in <code>flu_components.py</code>, they must abide by certain input specifications.</p> <p>Recall that the class <code>FluSubpopModel</code> simulates the flu model given by this mathematical formulation for a specific subpopulation. Multiple <code>FluSubpopModel</code> instances can be combined as input into a <code>FluMetapopModel</code> instance to simulate multiple subpopulations and travel between these subpopulations. To implement a concrete <code>FluSubpopModel</code> instance requires user-specified inputs, including demographics, epidemiological parameters, and simulation settings.</p>"},{"location":"flu_input_requirements/#flusubpopstate","title":"<code>FluSubpopState</code>","text":"<p>Note that there is one <code>FluSubpopState</code> for each <code>SubpopModel</code> instance. The following matrices are for a specific subpopulation. But here we remove the superscript \\((\\ell)\\) for subpopulation \\(\\ell\\) for readability ease. </p> Dataclass Field Name Math Variable Dimension <code>S</code> \\(\\boldsymbol{S}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>E</code> \\(\\boldsymbol{E}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IP</code> \\(\\boldsymbol{IP}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IS</code> \\(\\boldsymbol{IS}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IA</code> \\(\\boldsymbol{IA}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>H</code> \\(\\boldsymbol{H}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>R</code> \\(\\boldsymbol{R}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>D</code> \\(\\boldsymbol{D}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>M</code> \\(\\boldsymbol{M}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>MV</code> \\(\\boldsymbol{MV}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\)"},{"location":"flu_input_requirements/#flusubpopparams","title":"<code>FluSubpopParams</code>","text":"<p>This dataclass specifies the subpopulation's epidemiological parameters -- it specifies values such as transition rates as well as number of age groups and risk groups. We assume that these values do not change throughout the course of the simulation.  </p> <p>The following variables are for a specific subpopulation, although many of these variables will be the same across subpopulations in practice. Here in the table below we remove the superscript \\((\\ell)\\) for subpopulation \\(\\ell\\) for readability ease. Variables that are positive floats can be generalized to be age-risk dependent.</p> Dataclass Field Name Math Variable Dimension <code>num_age_groups</code> \\(\\lvert \\mathcal A \\rvert\\) positive <code>int</code> <code>num_risk_groups</code> \\(\\lvert \\mathcal R \\rvert\\) positive <code>int</code> <code>beta_baseline</code> \\(\\beta_0\\) positive <code>float</code> <code>total_pop_age_risk</code> \\(\\boldsymbol{N}\\) \\(\\lvert \\mathcal A \\rvert \\times  \\lvert \\mathcal R \\rvert\\) <code>humidity_impact</code> \\(\\xi\\) <code>float</code> <code>inf_induced_saturation</code> \\(o\\) nonnegative <code>float</code> <code>vax_induced_saturation</code> \\(o_v\\) nonnegative <code>float</code> <code>inf_induced_immune_wane</code> \\(w\\) nonnegative <code>float</code> <code>vax_induced_immune_wane</code> \\(w_v\\) nonnegative <code>float</code> <code>inf_induced_inf_risk_reduce</code> \\(k^I\\) <code>float</code> in \\([0,1)\\) <code>inf_induced_hosp_risk_reduce</code> \\(k^H\\) <code>float</code> in \\([0,1)\\) <code>inf_induced_death_risk_reduce</code> \\(k^D\\) <code>float</code> in \\([0,1)\\) <code>vax_induced_inf_risk_reduce</code> \\(k^I_v\\) <code>float</code> in \\([0,1)\\) <code>vax_induced_hosp_risk_reduce</code> \\(k^H_v\\) <code>float</code> in \\([0,1)\\) <code>vax_induced_death_risk_reduce</code> \\(k^D_v\\) <code>float</code> in \\([0,1)\\) <code>R_to_S_rate</code> \\(\\rateRtoS\\) positive <code>float</code> <code>E_to_I_rate</code> \\(\\rateEtoI\\) positive <code>float</code> <code>IP_to_IS_rate</code> \\(\\rateIPtoIS\\) positive <code>float</code> <code>IS_to_R_rate</code> \\(\\rateIStoR\\) positive <code>float</code> <code>IA_to_R_rate</code> \\(\\rateIAtoR\\) positive <code>float</code> <code>IS_to_H_rate</code> \\(\\rateIStoH\\) positive <code>float</code> <code>H_to_R_rate</code> \\(\\rateHtoR\\) positive <code>float</code> <code>H_to_D_rate</code> \\(\\rateHtoD\\) positive <code>float</code> <code>E_to_IA_prop</code> \\(\\propIA\\) <code>float</code> in \\([0,1]\\) <code>H_to_D_adjusted_prop</code> \\(\\boldsymbol{\\adjustedpropD}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IS_to_H_adjusted_prop</code> \\(\\boldsymbol{\\adjustedpropH}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IP_relative_inf</code> \\(r_{IP}\\) positive <code>float</code> <code>IA_relative_inf</code> \\(r_{IA}\\) positive <code>float</code> <code>relative_suscept</code> \\(\\psi\\) \\(\\lvert \\mathcal A \\rvert \\times 1\\) <code>mobility_modifier</code> \\(m\\) \\(\\lvert \\mathcal A \\rvert \\times 1\\) <code>total_contact_matrix</code> \\(\\phi^{(\\ell), \\text{total}}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <code>school_contact_matrix</code> \\(\\phi^{(\\ell), \\text{work}}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <code>work_contact_matrix</code> \\(\\phi^{(\\ell), \\text{school}}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <p>See the next section on <code>FluSubpopSchedules</code> for how \\(d_{\\text{work}}(t)\\) and \\(d_{\\text{school}}(t)\\) are defined.</p>"},{"location":"flu_input_requirements/#flusubpopschedules","title":"<code>FluSubpopSchedules</code>","text":"Dataclass Field Name Column Name Math Variable Dimension <code>absolute_humidity</code> <code>absolute_humidity</code> \\(h(t)\\) positive <code>float</code> <code>flu_contact_matrix</code> <code>is_school_day</code> \\(d_{\\text{work}}(t)\\) <code>bool</code> <code>flu_contact_matrix</code> <code>is_work_day</code> \\(d_{\\text{school}}(t)\\) <code>bool</code> <code>daily_vaccines</code> <code>daily_vaccines</code> \\(V^{(\\ell)}_{a, r}(t)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\)"},{"location":"flu_input_requirements/#flumixingparams","title":"<code>FluMixingParams</code>","text":"Dataclass Field Name Math Variable Dimension <code>num_locations</code> \\(\\lvert \\mathcal A \\rvert\\) positive <code>int</code> <code>travel_proportions</code> \\(p^{\\ell \\rightarrow k}\\) \\(\\lvert \\mathcal L \\rvert \\times \\lvert \\mathcal L \\rvert\\)"},{"location":"flu_input_requirements/#simulationsettings","title":"<code>SimulationSettings</code>","text":"<p>Updated 08/15/2025. Written by LP, edited by Susan Ptak.</p>"},{"location":"flu_model_demo/","title":"Flu Model Demo","text":"<p>This page is getting updated, please check back soon!</p>"},{"location":"math_flu_components/","title":"MetroFluSim Mathematical Formulation","text":"<p> \\(\\def\\rateRtoS{\\sigma^{R\\rightarrow S}}\\) \\(\\def\\rateEtoI{\\sigma^{E \\rightarrow [IP, IA]}}\\) \\(\\def\\rateIPtoIS{\\sigma^{IP \\rightarrow IS}}\\) \\(\\def\\rateIStoH{\\sigma^{IS\\rightarrow H}}\\) \\(\\def\\rateHtoD{\\sigma^{H\\rightarrow D}}\\) \\(\\def\\rateIAtoR{\\gamma^{IA\\rightarrow R}}\\) \\(\\def\\rateHtoR{\\gamma^{H\\rightarrow R}}\\) \\(\\def\\rateIStoR{\\gamma^{IS\\rightarrow R}}\\) \\(\\def\\totalforceofinfection{\\lambda^{(\\ell), \\text{total}}_{a}(t)}\\) \\(\\def\\propIA{\\pi^{IA}}\\) \\(\\def\\propH{\\pi^H}\\) \\(\\def\\propD{\\pi^D}\\) \\(\\def\\adjustedpropH{\\tilde{\\pi}^H}\\) \\(\\def\\adjustedpropD{\\tilde{\\pi}^D}\\) \\(\\def\\proptravelelltok{p^{\\ell \\rightarrow k}}\\) \\(\\def\\propdaytravelktoell{p^{k \\rightarrow \\ell}}\\) \\(\\def\\LambdaIlocagerisktime{\\Lambda^{(\\ell), I}_{a,r}(t)}\\) \\(\\def\\LambdaHlocagerisktime{\\Lambda^{(\\ell), H}_{a,r}(t)}\\) \\(\\def\\LambdaDlocagerisktime{\\Lambda^{(\\ell), D}_{a,r}(t)}\\) \\(\\def\\locationell{^{(\\ell)}}\\) \\(\\def\\locationk{^{(k)}}\\) \\(\\def\\locagerisk{\\locationell_{a, r}}\\) \\(\\def\\locagerisktime{\\locagerisk(t)}\\) \\(\\def\\agetime{_a(t)}\\) \\(\\def\\agerisk{_{a, r}}\\) \\(\\def\\agerisktime{_{a, r}(t)}\\) \\(\\def\\ageprimeriskprime{_{a^\\prime, r^\\prime}}\\) \\(\\def\\locageprimeriskprime{\\locationell_{a^\\prime, r^\\prime}}\\) \\(\\def\\Nlocagerisk{N\\locationell_{a,r}}\\) \\(\\def\\effectiveNlocagerisktime{\\tilde{N}\\locationell_{a,r}(t)}\\) \\(\\def\\effectiveNlocageprimeriskprimetime{\\tilde{N}\\locationell_{a^\\prime,r^\\prime}(t)}\\) \\(\\def\\multipliersymptom{h_{\\text{symp}}}\\) \\(\\def\\tvarloc{y^{(\\ell)}}\\) \\(\\def\\jointtvarloc{y^{(\\ell) *}}\\) \\(\\def\\simstate{\\boldsymbol{\\Xi}_t}\\) \\(\\def\\agegroups{\\mathcal A}\\) \\(\\def\\riskgroups{\\mathcal R}\\) \\(\\def\\numagegroups{\\lvert \\agegroups \\rvert}\\) \\(\\def\\numriskgroups{\\lvert \\riskgroups \\rvert}\\) \\(\\def\\poik{\\text{POI}(k)}\\) \\(\\def\\poiell{\\text{POI}(\\ell)}\\) </p> <p>The mathematical framework is inspired by the immunoSEIRS model of the Meyers Lab (see Bi and Bandekar et al. 2023, Bi et al. 2022 and Bouchnita et al. 2021 for some related recent publications).</p> <p>Please note that the MetroFluSim model requires extensive notation -- please review the entirety of each section for provided definitions.</p>"},{"location":"math_flu_components/#flu-model-diagram","title":"Flu model: diagram","text":""},{"location":"math_flu_components/#flu-model-deterministic-differential-equations","title":"Flu model: deterministic differential equations","text":"<p>We start off with common indices and arguments: - \\(t \\in \\mathbb N\\): current simulation day - \\(\\ell\\): location, i.e. subpopulation, \\(\\mathcal L\\): set of all locations/subpopulations - \\(a\\): age group, \\(\\agegroups\\): set of all age groups - \\(r\\): risk group, \\(\\riskgroups\\): set of all risk groups - \\(i\\): type of immunity-inducing event, \\(\\mathcal{I} := \\left\\{\\text{infection}, \\text{vaccine}\\right\\}\\): the set of all types of immunity-inducing events: infection and vaccination, respectively.</p>"},{"location":"math_flu_components/#population-level-immunity","title":"Population-level immunity","text":"<p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\):</p> \\[\\begin{align*} \\frac{dM\\locationell\\agerisktime}{dt} &amp;= \\frac{\\rateRtoS(t) R\\locagerisktime}{N\\locationell_{a, r}} \\cdot (1 - oM\\locationell\\agerisktime - o_v MV\\locationell\\agerisktime) - wM\\locationell\\agerisktime \\tag{M1} \\\\ \\frac{dMV\\locationell\\agerisktime}{dt} &amp;= \\frac{V\\locationell\\agerisk(t - \\delta)}{N\\locationell\\agerisk} - w_v MV\\locationell\\agerisktime \\tag{M2} \\end{align*}\\] <p>where</p> <ul> <li>\\(\\rateRtoS\\): rate at which recovered individuals become susceptible, so that \\(1/\\rateRtoS\\) is the average number of days a person is totally immune from reinfection until being susceptible again.</li> <li>\\(V\\locationell\\agerisktime\\): number of vaccine doses administered at time \\(t\\) to individuals residing in location \\(\\ell \\in \\mathcal L\\) in age-risk group \\(a\\), \\(r\\).</li> <li>\\(o\\), \\(o_v\\): positive constants modeling the saturation of antibody production in individuals who have infection-induced immunity and vaccination-induced immunity, respectively.</li> <li>\\(\\delta\\): number of days after dose for vaccine to become effective.</li> <li>\\(w\\): rate at which infection-induced immunity wanes.</li> <li>\\(w_V\\): rate at which vaccine-induced immunity wanes.</li> </ul>"},{"location":"math_flu_components/#compartment-equations","title":"Compartment equations","text":"<p>Note that the following are all \\(\\numagegroups \\times \\numriskgroups \\times \\lvert \\mathcal I \\rvert\\) matrices:</p> <ul> <li>\\(\\boldsymbol{K}^I = [\\boldsymbol{K}^I, \\boldsymbol{K}^I_{V}]\\): reduction in infection risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^{H} = [\\boldsymbol{K}^H, \\boldsymbol{K}^H_{V}]\\): reduction in hospitalization risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^D = [\\boldsymbol{K}^D, \\boldsymbol{K}^D_{V}]\\): reduction in death risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{M}\\locationell = \\boldsymbol{M}\\locationell(t) = [\\boldsymbol{M}\\locationell(t), \\boldsymbol{M}\\locationell_{V}(t)]\\): location \\(\\ell \\in \\mathcal L\\) population-level immunity.  </li> </ul> <p>To simplify notation, we have the following terms that characterize the effect of population-level immunities for a given subpopulation \\(\\ell\\), age \\(a\\), and risk \\(r\\):</p> \\[\\begin{align*} \\LambdaIlocagerisktime &amp;= \\left[\\frac{\\boldsymbol{K_{a,r}^{I}}}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1} - \\boldsymbol{K_{a,r}^{I}}}\\right]^T \\boldsymbol{M_{a,r}\\locationell(t)} \\tag{I1} \\\\ \\LambdaHlocagerisktime &amp;= \\left[\\frac{\\boldsymbol{K_{a,r}^{H}}}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1} - \\boldsymbol{K_{a,r}^{H}}}\\right]^T \\boldsymbol{M_{a,r}\\locationell(t)} \\tag{I2} \\\\ \\LambdaDlocagerisktime &amp;= \\left[\\frac{\\boldsymbol{K_{a,r}^{D}}}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1} - \\boldsymbol{K_{a,r}^{D}}}\\right]^T \\boldsymbol{M_{a,r}\\locationell(t)} \\tag{I3} \\end{align*}\\] <p>where \\(\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times 1}\\) is an \\(\\lvert \\mathcal L \\rvert \\times 1\\) vector of \\(1\\)'s and the fraction notation indicates element-wise division. </p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\), we have the following equations that characterize transitions between compartments:</p> \\[\\begin{align} \\frac{dS\\locagerisktime}{dt} &amp;= \\underbrace{\\rateRtoS R\\locagerisktime}_{\\text{$R$ to $S$}}  -\\underbrace{S\\locagerisktime \\frac{\\beta\\locationell(t) \\cdot \\totalforceofinfection}{\\left(1 + \\LambdaIlocagerisktime\\right)}}_{\\text{$S$ to $E$}} \\tag{C1} \\\\[1.5em] \\frac{dE\\locagerisktime}{dt} &amp;= \\underbrace{S\\locagerisktime \\frac{\\beta\\locationell(t) \\cdot \\totalforceofinfection}{\\left(1 + \\LambdaIlocagerisktime\\right)}}_{\\text{$S$ to $E$}} - \\underbrace{\\rateEtoI (1-\\propIA) E\\locagerisktime}_{\\text{$E$ to $IP$}} - \\underbrace{\\rateEtoI \\propIA E\\locagerisktime}_{\\text{$E$ to $IA$}} \\tag{C2} \\\\[1.5em] \\frac{dIP\\locagerisktime}{dt} &amp;= \\underbrace{\\rateEtoI (1-\\propIA) E\\locagerisktime}_{\\text{$E$ to $IP$}} - \\underbrace{\\rateIPtoIS IP\\locagerisktime}_{\\text{$IP$ to $IS$}} \\tag{C3} \\\\[1.5em] \\frac{dIS\\locagerisktime}{dt} &amp;= \\underbrace{\\rateIPtoIS IP\\locagerisktime}_{\\text{$IP$ to $IS$}}  - \\underbrace{\\left(1-\\frac{\\adjustedpropH_{a, r}}{1 + \\LambdaHlocagerisktime}\\right)\\rateIStoR IS\\locagerisktime}_{\\text{$IS$ to $R$}} - \\underbrace{\\frac{\\rateIStoH \\adjustedpropH_{a, r} IS\\locagerisktime}{1 + \\LambdaHlocagerisktime}}_{\\text{$IS$ to $H$}} \\tag{C4} \\\\[1.5em] \\frac{dIA\\locagerisktime}{dt} &amp;= \\underbrace{\\rateEtoI \\propIA E\\locagerisktime}_{\\text{$E$ to $IA$}}  - \\underbrace{\\rateIAtoR IA\\locagerisktime}_{\\text{$IA$ to $R$}} \\tag{C5} \\\\[1.5em] \\frac{dH\\locagerisktime}{dt} &amp;= \\underbrace{\\frac{\\rateIStoH \\adjustedpropH_{a, r} IS\\locagerisktime}{1 + \\LambdaHlocagerisktime}}_{\\text{$IS$ to $H$}} - \\underbrace{\\left(1-\\frac{\\adjustedpropD_{a, r}}{1 + \\LambdaDlocagerisktime}\\right)\\rateHtoR H\\locagerisktime}_{\\text{$H$ to $R$}}  - \\underbrace{\\frac{\\rateHtoD \\adjustedpropD_{a, r} H\\locagerisktime}{1 + \\LambdaDlocagerisktime}}_{\\text{$H$ to $D$}} \\tag{C6} \\\\[1.5em] \\frac{dR\\locagerisktime}{dt} &amp;= \\underbrace{\\left(1-\\frac{\\adjustedpropH_{a, r}}{1 + \\LambdaHlocagerisktime}\\right) \\rateIStoR IS\\locagerisktime}_{\\text{$IS$ to $R$}} + \\underbrace{\\rateIAtoR IA\\locagerisktime}_{\\text{$IA$ to $R$}}  \\\\[1em] &amp;\\quad\\quad\\quad + \\underbrace{\\left(1-\\frac{\\adjustedpropD_{a, r}}{1 + \\LambdaDlocagerisktime}\\right)\\rateHtoR H\\locagerisktime}_{\\text{$H$ to $R$}}  - \\underbrace{\\rateRtoS R\\locagerisktime}_{\\text{$R$ to $S$}} \\tag{C7} \\\\[1.5em] \\frac{dD\\locagerisktime}{dt} &amp;= \\underbrace{\\frac{\\rateHtoD \\adjustedpropD_{a, r} H\\locagerisktime}{1 + \\LambdaDlocagerisktime}}_{\\text{$H$ to $D$}}. \\tag{C8} \\end{align}\\] <p>where</p> <ul> <li>The \\(\\lambda\\)-terms are location/subpopulation mixing terms that we define in the next section on the travel model. </li> <li>\\(\\boldsymbol{N}\\locationell\\): \\(\\numagegroups \\times \\numriskgroups\\) matrix corresponding to total population in location \\(\\ell \\in \\mathcal L\\), where element \\(N\\locagerisk\\) is the total population of age group \\(a\\) and risk group \\(\\ell\\) in location \\(\\ell\\).</li> <li>\\(\\beta\\locationell(t) = \\beta\\locationell_0 (1 + q(t))\\): time-dependent transmission rate per day for individuals residing in location \\(\\ell \\in \\mathcal L\\). </li> <li>\\(q(t) = \\xi \\cdot \\exp^{-180 * h(t)}\\): humidity adjustment, where \\(\\xi\\) is the humidity impact factor and \\(h(t)\\) is absolute humidity. This formula is taken from this paper.</li> <li>\\(\\propIA\\): proportion exposed who are completely asymptomatic when infectious.</li> <li>\\(r_{IP}\\), \\(r_{IA}\\): relative infectiousness (compared to infected symptomatic people) of infected presymptomatic and infected asymptomatic people respectively. </li> <li>\\(\\rateIStoR, \\rateHtoR, \\rateIAtoR\\): recovery rates for infected symptomatic (\\(IS\\)),  hospital (\\(H\\)), and infected asymptomatic (\\(IA\\)) compartments respectively, so that \\(1/\\gamma\\) is the average number of days it takes for an infected person not in the hospital to recover, and \\(1/\\rateHtoR\\) is analogous, but for an infected person in the hospital. </li> <li>\\(\\rateEtoI\\): infection rate (both exposed to infected presymptomatic transition rate and exposed to infected asymptomatic transition rate), so that \\(1/\\rateEtoI\\) is the average number of days after exposure before a person becomes infectious.</li> <li>\\(\\rateIPtoIS\\): infected presymptomatic to infected symptomatic transition rate, so that \\(1/\\rateIPtoIS\\) is the average number of days that an infected person is presymptomatic before becoming symptomatic. </li> <li>\\(\\rateIStoH\\): hospitalization rate (infected to hospital transition rate), so that \\(1/\\rateIStoH\\) is the average number of days a person is infected before going to the hospital.</li> <li>\\(\\rateHtoD\\): death rate from hospital, so that \\(1/\\rateHtoD\\) is the average number of days a person spends in the hospital before dying.</li> <li>\\(\\boldsymbol{\\adjustedpropH}\\), where \\(\\adjustedpropH_{a, r} = \\frac{\\propH_{a, r}\\rateIStoR}{\\rateIStoH - \\propH_{a, r}(\\rateIStoH-\\rateIStoR)}\\): adjusted proportion hospitalized based on age-risk group \\(a, r\\) group actually used in model -- this adjustment is necessary to ensure actual proportion hospitalized recapitulates \\([\\propH_{a, r}]\\).</li> <li>\\(\\boldsymbol{\\propH}\\): \\(\\numagegroups \\times \\numriskgroups\\) proportion hospitalized based on age-risk group \\(a, r\\).</li> <li>\\(\\boldsymbol{\\adjustedpropD}\\), where \\(\\adjustedpropD_{a, r} = \\frac{\\propD_{a, r} \\rateHtoR}{\\rateHtoD - \\propD_{a, r} (\\rateHtoD-\\rateHtoR)}\\): adjusted in-hospital mortality rate (as in, proportion who die in the hospital based on age group) actually used in model -- this adjustment is necessary to ensure actual proportion who die in the hospital recapitulates \\([\\propD_{a, r} ]\\).</li> <li>\\(\\boldsymbol{\\propD}\\): \\(\\numagegroups \\times \\numriskgroups\\) in-hospital mortality rate (proportion who die based on age-risk group \\(a, r\\)).</li> </ul>"},{"location":"math_flu_components/#flu-model-travel-model","title":"Flu model: travel model","text":""},{"location":"math_flu_components/#exposure-intensity","title":"Exposure intensity","text":"<p>For each \\(\\ell \\in \\mathcal L\\), \\(k \\in \\mathcal L \\setminus \\{\\ell\\}\\), \\(a \\in \\agegroups\\), we have</p> \\[ \\totalforceofinfection = \\lambda^{(\\ell), \\text{local}}\\agetime + \\lambda^{(\\ell), \\text{visitors}}\\agetime + \\lambda^{(\\ell), \\text{residents traveling}}\\agetime. \\tag{T1} \\] <p>This can loosely can be interpreted as exposure intensity: the (weighted) proportion of the population that interacts with \\(\\ell,a\\) individuals that are infectious. </p> <p>The decompositions model the following phenomenon:</p> <ul> <li>\\(\\lambda^{(\\ell), \\text{local}}\\agetime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(\\ell\\) (this contact occurs in location \\(\\ell\\)).</li> <li>\\(\\lambda^{(\\ell), \\text{visitors from } k}\\agetime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(k\\) but travel to location \\(\\ell\\) (this contact occurs in location \\(\\ell\\)).</li> <li>\\(\\lambda^{(\\ell), \\text{residents traveling to } k}\\agetime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(k\\), due to individuals who live in location \\(\\ell\\) traveling to location \\(k\\) (this contact occurs in location \\(k\\)).</li> </ul> <p>Note that we assume this exposure intensity is the same for a given age group regardless of risk group, so we do not have the \\(r\\)-subscript here.</p> <p>Specifically, we have</p> \\[\\begin{align*} \\lambda^{(\\ell), \\text{local}}\\agetime &amp;= \\psi_a \\left(1 - m_a \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\proptravelelltok \\right) \\cdot \\sum \\limits_{a^\\prime \\in \\agegroups} \\phi\\locationell_{a,a^\\prime}(t) \\frac{\\texttt{I_weighted}\\locationell_{a^\\prime}(t)}{\\sum_{r^\\prime \\in \\riskgroups} \\effectiveNlocageprimeriskprimetime} \\tag{T2} \\\\[1.5em] \\lambda^{(\\ell), \\text{visitors}}\\agetime &amp;= \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\underbrace{\\left(\\psi_a \\cdot \\propdaytravelktoell \\cdot \\sum\\limits_{a^\\prime \\in \\agegroups} m_{a^\\prime}(t) \\cdot \\phi\\locationell_{a, a^\\prime}(t) \\frac{\\texttt{I_weighted}\\locationk_{a^\\prime}(t)}{\\sum_{r^\\prime \\in \\riskgroups} \\effectiveNlocageprimeriskprimetime}\\right)}_{\\text{Each summand: } \\lambda^{(\\ell), \\text{visitors from } k}\\agetime} \\tag{T3} \\\\[1.5em] \\lambda_{a,r}^{(\\ell), \\text{residents traveling}}(t) &amp;= \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}}  \\underbrace{\\left(\\psi_a \\cdot \\proptravelelltok  \\cdot m_a \\cdot \\sum\\limits_{a^\\prime \\in \\agegroups} \\phi\\locationell_{a, a^\\prime}(t) \\frac{\\texttt{I_weighted}\\locationk_{a^\\prime}(t)}{\\sum_{r^\\prime \\in \\riskgroups} \\tilde{N}^{(k)}_{a^\\prime, r^\\prime} (t)}\\right)}_{\\text{Each summand: } \\lambda\\agerisk^{(\\ell), \\text{residents traveling to } k}(t)} \\tag{T4} \\end{align*}\\] <p>where</p> \\[ \\texttt{I_weighted}\\locationell_{a^\\prime}(t) := \\sum_{r^\\prime \\in \\riskgroups} \\left[IS\\locationell\\ageprimeriskprime(t) + r_{IP} IP\\locationell\\ageprimeriskprime(t) + r_{IA} IA\\locationell\\ageprimeriskprime(t)\\right] \\tag{T5} \\] <p>and where</p> \\[\\begin{align*} \\effectiveNlocagerisktime &amp;= \\Nlocagerisk + m_a \\cdot \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\propdaytravelktoell \\cdot (N^{(k)}_{a, r} - H^{(k)}_{a,r}(t)) \\\\ &amp;\\quad\\quad\\quad - m_a \\cdot \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\proptravelelltok  \\cdot (N\\locagerisk - H\\locationell_{a,r}(t)) \\tag{T6} \\end{align*}\\] <p>is the effective population in location \\(\\ell \\in \\mathcal L\\) and age-risk group \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\) at time \\(t\\).</p>"},{"location":"math_flu_components/#contact-matrix","title":"Contact matrix","text":"<p>The contact matrix is defined as</p> <ul> <li>\\(\\phi_{a, a^\\prime}\\locationell(t)\\): the number of contacts that individuals in age group \\(a \\in \\agegroups\\) residing in location \\(\\ell \\in \\mathcal L\\) have with other individuals (regardless of location) in age group \\(a^\\prime \\in \\agegroups\\) on day \\(t\\).</li> </ul> <p>Let \\(\\phi^{(\\ell), \\text{total}}\\), \\(\\phi^{(\\ell), \\text{work}}\\), and \\(\\phi^{(\\ell), \\text{school}}\\) represent the total contact matrix, school contact matrix, and work contact matrix, respectively for subpopulation \\(\\ell\\).</p> <p>Then the contact matrix for the subpopulation at time \\(t\\) is $$ \\phi^{(\\ell)}(t) := \\phi^{(\\ell), \\text{total}} - (1 - d_{\\text{work}}(t)) \\phi^{(\\ell), \\text{work}} - (1 - d_{\\text{school}}(t)) \\phi^{(\\ell), \\text{school}} $$ where \\(d_{\\text{work}}(t)\\) is \\(1\\) if the real-world date corresponding to simulation time \\(t\\) is a work day and \\(0\\) otherwise, and \\(d_{\\text{school}}(t)\\) is defined analogously, but for school days.</p>"},{"location":"math_flu_components/#other-travel-parameters","title":"Other travel parameters","text":"<p>We have</p> <ul> <li>\\(\\psi_a \\in [0, 1]\\): relative susceptibility of individuals in age group \\(a \\in \\agegroups\\).</li> <li>\\(m_a\\): a positive scalar modifying travel intensity depending on age \\(a\\).</li> <li>\\(\\propdaytravelktoell\\): (on average) proportion of the day that a resident of \\(k\\) spends traveling to location \\(\\ell \\in \\mathcal L\\).</li> </ul> <p>Note that the arrows in \\(\\propdaytravelktoell\\) correspond to direction of travel (e.g. \\(k \\rightarrow \\ell\\) represents residents of location \\(k\\) traveling to location \\(\\ell\\)). The \\(\\propdaytravelktoell\\) values are calculated from mobility data, corresponding to</p> \\[ \\propdaytravelktoell := \\sum_{\\poiell} c^{\\poiell} \\cdot v^{k \\rightarrow \\poiell} \\tag{T7} \\] <p>where</p> <ul> <li>\\(c^{\\poiell}\\): average proportion of a day spent at \\(\\poiell\\).</li> <li>\\(v^{k \\rightarrow \\poiell}\\): average number of visits per day per resident of \\(k\\) to \\(\\poiell\\).</li> </ul>"},{"location":"math_flu_components/#flu-model-discretized-stochastic-implementation","title":"Flu model: discretized stochastic implementation","text":"<p>To actually implement/simulate this compartmental model, we discretize the deterministic differential equations and treat transitions between compartments as stochastic to model uncertainty. We extend the notation from the deterministic differential equations to capture the stochastic elements.</p> <p>Let \\(\\boldsymbol{\\mathcal X}(t) = \\left\\{\\boldsymbol{S}(t), \\boldsymbol{E}(t), \\boldsymbol{IA}(t), \\boldsymbol{IP}(t), \\boldsymbol{IS}(t), \\boldsymbol{H}(t), \\boldsymbol{R}(t), \\boldsymbol{D}(t), \\boldsymbol{M}(t), \\boldsymbol{MV}(t), q(t), \\boldsymbol{\\phi}(t), V\\locationell(t)\\right\\}\\) be the \"simulation state\" at time \\(t\\). \\(\\boldsymbol{\\mathcal X}(t)\\) is a set of matrices. </p> <p>Let \\(\\boldsymbol{\\Theta}\\) be the set of fixed parameters. </p> <p>Then given initial state \\(\\boldsymbol{\\mathcal X}_0 = \\boldsymbol{\\mathcal X}(0)\\), we can formulate our discretized stochastic implementation as</p> \\[ \\boldsymbol{\\mathcal X}(t + \\Delta t) = \\boldsymbol{\\mathcal X}(t) + f\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega; \\boldsymbol{\\Theta}\\right) \\quad \\text{for} \\quad t \\ge 0, \\] <p>where \\(f\\) is parametrized by \\(\\boldsymbol{\\Theta}\\), and depends on the step size of discretization \\(\\Delta t\\) and a sample path \\(\\omega\\). We assume that each sample path \\(\\omega\\) is realized from a random process that does not depend on \\(\\boldsymbol{\\mathcal X}(t)\\) or \\(\\Delta t\\) for each \\(t\\). When we are discussing a single model with a fixed set of parameters \\(\\boldsymbol{\\Theta}\\), we drop the \\(\\boldsymbol{\\Theta}\\) notation for simplicity.  </p> <p>Now we formulate how we implement discretized stochastic transitions. We assume that \\(q(t)\\), \\(\\boldsymbol{\\phi}(t)\\), and \\(V\\locationell(t)\\)  are updated deterministically according to some \"schedule.\"  </p> <p>We model stochastic transitions between compartments using \"transition variables.\" Transition variables correspond to incoming and outgoing flows of epidemiological compartments (see the compartment equations above). </p> <p>Below we formulate the discretized stochastic transitions. Note that the population-level immunity variables behave as aggregate epidemiological metrics. They are deterministic functions of the simulation state and transitions between compartments.</p> <p>IMPORTANT NOTE_: all \\(y\\) and \\(y^*\\)-variables depend on \\(\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). For notation simplicity, we define \\(\\simstate := \\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and write \\(y\\) and \\(y^*\\)-variables as functions of \\(\\simstate\\).</p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), and \\(r \\in \\riskgroups\\):</p> \\[\\begin{align} M_{a, r}\\locationell(t + \\Delta t) &amp;= M\\locationell\\agerisktime + \\frac{dM\\locationell\\agerisktime}{dt} \\cdot \\Delta t \\\\ MV_{a,r}\\locationell(t + \\Delta t) &amp;= MV\\agerisktime\\locationell + \\frac{dMV\\agerisktime\\locationell}{dt} \\cdot \\Delta t \\\\ S\\locagerisk(t + \\Delta t) &amp;= S_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}_{\\text{$R$ to $S$}} - \\underbrace{\\tvarloc_{S\\rightarrow E, a, r}(\\Xi_t)}_{\\text{$S$ to $E$}} \\\\ E\\locagerisk(t + \\Delta t) &amp;= E_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{S\\rightarrow E, a, r}(\\Xi_t)}_{\\text{$S$ to $E$}} - \\underbrace{\\jointtvarloc_{E\\rightarrow IP, a, r}(\\Xi_t)}_{\\text{$E$ to $IP$}} - \\underbrace{\\jointtvarloc_{E\\rightarrow IA, a, r}(\\Xi_t)}_{\\text{$E$ to $IA$}} \\\\ IP\\locagerisk(t + \\Delta t) &amp;= IP\\locagerisktime + \\underbrace{\\jointtvarloc_{E\\rightarrow IP, a, r}(\\Xi_t)}_{\\text{$E$ to $IP$}} - \\underbrace{\\tvarloc_{IP \\rightarrow IS, a, r}(\\Xi_t)}_{\\text{$IP$ to $IS$}} \\\\ IA_{a, r}\\locationell(t + \\Delta t) &amp;= IA_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{E\\rightarrow IA, a, r}(\\Xi_t)}_{\\text{$E$ to $IA$}} - \\underbrace{\\tvarloc_{IA \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IA$ to $R$}} \\\\ IS\\locagerisk(t + \\Delta t) &amp;= IS_{a, r}\\locationell(t) + \\underbrace{\\tvarloc_{E \\rightarrow IS, a, r}(\\Xi_t)}_{\\text{$E$ to $IS$}} - \\underbrace{\\jointtvarloc_{IS \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IS$ to $R$}} - \\underbrace{\\jointtvarloc_{IS \\rightarrow H, a, r}(\\Xi_t)}_{\\text{$IS$ to $H$}} \\\\ H\\locagerisk(t + \\Delta t) &amp;= H_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{IS \\rightarrow H, a, r}(\\Xi_t)}_{\\text{$IS$ to $H$}} - \\underbrace{\\jointtvarloc_{H\\rightarrow R, a, r}(\\Xi_t)}_{\\text{$H$ to $R$}} - \\underbrace{\\jointtvarloc_{H\\rightarrow D, a, r}(\\Xi_t)}_{\\text{$H$ to $D$}} \\\\ R\\locagerisk(t + \\Delta t) &amp;= R_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{IA \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IA$ to $R$}} + \\underbrace{\\jointtvarloc_{IS \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IS$ to $R$}} + \\underbrace{\\jointtvarloc_{H\\rightarrow R, a, r}(\\Xi_t)}_{\\text{$H$ to $R$}} - \\underbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}_{\\text{$R$ to $S$}} \\\\ D\\locagerisk(t + \\Delta t) &amp;= D_{a, r}\\locationell(t) + \\underbrace{\\jointtvarloc_{H\\rightarrow D, a, r}(\\Xi_t)}_{\\text{$H$ to $D$}}.  \\end{align}\\] <p>IMPORTANT NOTE: the \"\\(*\\)\" superscript indicates that the transition variable has a joint distribution with another transition variable. In general, if a compartment has more than one outgoing transition variable, these transition variables must be modeled jointly. </p> <p>Consider the two transitions out of the infected symptomatic compartment, for example. Given that a patient is infected and symptomatic, exactly one outcome occurs: they recover (from home) or they go to the hospital. Since one and only one of these outcomes must occur, we must model these two transition variables jointly. Joint distribution derivation details are provided in the next section on transition types.</p> <p>Each transition variable depends on a \"base count\" and a \"rate\" (which both depend on the current state of the system). This decomposition is displayed in the table below. Note that these transitions are for a given location \\(\\ell \\in \\mathcal L\\).</p> Transition Transition variable Base count Rate \\(R\\) to \\(S\\) \\(\\tvarloc_{R \\rightarrow S, a, r}(\\simstate)\\) \\(R_{a, r}\\locationell(t)\\) \\(\\rateRtoS\\) \\(S\\) to \\(E\\) \\(\\tvarloc_{S \\rightarrow E, a, r}(\\simstate)\\) \\(S_{a, r}\\locationell(t)\\) \\(\\frac{\\beta(t) \\totalforceofinfection}{1 + \\LambdaIlocagerisktime}\\) \\(E\\) to \\(IP\\) \\(\\jointtvarloc_{E \\rightarrow IP, a, r}(\\simstate)\\) \\(E_{a, r}\\locationell(t)\\) \\(\\rateEtoI (1 - \\propIA)\\) \\(E\\) to \\(IA\\) \\(\\jointtvarloc_{E \\rightarrow IA, a, r}(\\simstate)\\) \\(E_{a, r}\\locationell(t)\\) \\(\\rateEtoI \\propIA\\) \\(IP\\) to \\(IS\\) \\(\\tvarloc_{IP \\rightarrow IS, a, r}(\\simstate)\\) \\(IP_{a, r}\\locationell(t)\\) \\(\\rateIPtoIS\\) \\(IS\\) to \\(R\\) \\(\\jointtvarloc_{IS \\rightarrow R, a, r}(\\simstate)\\) \\(IS_{a, r}\\locationell(t)\\) \\(\\left(1-\\frac{\\adjustedpropH_{a,r}}{1 + \\LambdaHlocagerisktime}\\right)\\gamma^{IS\\rightarrow R}\\) \\(IS\\) to \\(H\\) \\(\\jointtvarloc_{IS \\rightarrow H, a, r}(\\simstate)\\) \\(IS_{a, r}\\locationell(t)\\) \\(\\frac{\\rateIStoH \\adjustedpropH_{a,r}}{1 + \\LambdaHlocagerisktime}\\) \\(IA\\) to \\(R\\) \\(\\tvarloc_{IA \\rightarrow R, a, r}(\\simstate)\\) \\(IA_{a, r}\\locationell(t)\\) \\(\\rateIAtoR\\) \\(H\\) to \\(R\\) \\(\\jointtvarloc_{H \\rightarrow R, a, r}(\\simstate)\\) \\(H_{a, r}\\locationell(t)\\) \\(\\left(1-\\frac{\\adjustedpropD_{a,r}}{1 + \\LambdaDlocagerisktime}\\right)\\rateHtoR\\) \\(H\\) to \\(D\\) \\(\\jointtvarloc_{H \\rightarrow D, a, r}(\\simstate)\\) \\(H_{a, r}\\locationell(t)\\) \\(\\frac{\\rateHtoD \\adjustedpropD_{a,r}}{1 + \\LambdaHlocagerisktime}\\) <p>The base count and rate of a transition variable parameterize the distribution that defines its realization. </p> <p>See this page for mathematical formulations of marginal and joint stochastic transitions between compartments. </p>"},{"location":"math_flu_components/#general-model-discretized-stochastic-implementation","title":"General model: discretized stochastic implementation","text":"<p>We make the important note that the flu model's discretized stochastic implementation can be generalized to models with different structures. More broadly, we let \\(\\boldsymbol{\\mathcal C}(t)\\) be a model's set of epidemiological compartments, \\(\\boldsymbol{\\mathcal M}(t)\\) its set of aggregate epidemiological metrics, and \\(\\boldsymbol{S (t)}\\) its set of schedule-dependent (time-dependent) deterministic values. Then the above formulation still holds.</p> <p>In fact, in our code, we model \\(\\boldsymbol{\\mathcal C(t)}\\) using an <code>Compartment</code> class, \\(\\boldsymbol{\\mathcal M}(t)\\) using an <code>EpiMetric</code> class, and \\(\\boldsymbol{\\mathcal S(t)}\\) using a <code>Schedule</code> class. We handle stochastic transitions using <code>TransitionVariable</code> and <code>TransitionVariableGroup</code> classes. These classes form some of the building blocks of the base model code. </p> <p>Updated 08/15/2025. Documentation written by LP, mathematical notation by LP (advised by Lauren Meyers and Dave Morton, edited by Susan Ptak, Meyers Lab, and Shiyuan Liang), travel model conceptualized by R\u00e9my Pasco and Susan Ptak, immunity formulation by Anass Bouchnita.</p>"},{"location":"math_transitions/","title":"Stochastic Transitions","text":"<p>Written by LP, updated 01/30/2025 </p>"},{"location":"math_transitions/#marginal-transition-types","title":"Marginal transition types","text":"<p>Our codebase currently implements six types of transitions: three stochastic transitions and three deterministic counterparts.</p> <p>First we consider marginal (not joint) transition variables. For the following table, consider \\(y_{\\texttt{C}\\rightarrow\\texttt{C}^\\prime, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) from compartment \\(\\texttt{C}\\) to \\(\\texttt{C}^\\prime\\). Let \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t)\\) be its current value of its base count and \\(\\texttt{r} = \\texttt{r}_{a, \\ell}(t)\\) be its current value of its rate. Then depending on its transition type, its distribution (or deterministic value) is given below.</p> <p>Note that \\(\\alpha\\) is a function that converts a \"rate\" into a probability. It is given by: $$ \\alpha(\\texttt{r}, \\Delta t) = 1 - \\exp(-\\texttt{r} \\cdot \\Delta t) $$ and corresponds to the probability that a Poisson process with rate \\(\\texttt{r}\\) produces at least one event in an interval of length \\(\\Delta t\\). </p> <p>The following table provides the mathematical distribution or deterministic output for each transition type. </p> Output Binomial \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\alpha(\\texttt{r}, \\Delta t)\\right)\\) Binomial  Taylor Approx \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\texttt{r} \\cdot \\Delta t\\right)\\) Poisson \\(\\sim \\text{Poisson}\\left(\\lambda = \\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\right)\\) Binomial Deterministic \\(\\texttt{b} \\cdot \\alpha(\\texttt{r}, \\Delta t)\\) Binomial Taylor Approx Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\) Poisson Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\)"},{"location":"math_transitions/#joint-transition-types","title":"Joint transition types","text":"<p>Here we describe joint transition variables. For the following table, consider a compartment \\(\\texttt{C}_0\\) with two outgoing compartments, \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). We describe \\(2\\) transition variables: \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). They respectively correspond to the number of people that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_1\\) and the number that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_2\\) at a given simulate state. Let their rates be \\(\\texttt{r}_1\\) and \\(\\texttt{r}_2\\) respectively.  </p> <p>We can also write the number that remain in \\(\\texttt{C}_0\\) explicitly as  \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) = \\texttt{C}_{0, a, \\ell}(t) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). Note that this quantity is purely for parametrizing multinomial distributions (which needs to have its probability parameters sum to \\(1\\)) and does not need to be literally modeled as a transition variable either mathematically or in code. </p> <p>Let \\(\\alpha\\) be defined as in the previous section on marginal transition types.</p> <p>The following table gives the parameters for multinomial transitions when \\(\\texttt{C}_0\\) has two outgoing compartments \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). The values \\([y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)]\\) are sampled jointly, using \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t) = \\texttt{C}_{0, a, \\ell}(t)\\) as the \"number of trials\" parameter \\(n\\) in a multinomial distribution.</p> Transition  Variable Group (Jointly Sampled) Multinomial Probability Parameter Multinomial with Taylor Approx Probability Parameter \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_1}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_1 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_2}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_2 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(1 - \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(1 - (\\texttt{r}_1 + \\texttt{r}_2) \\Delta t\\)"},{"location":"math_transitions/#important-notes","title":"Important notes","text":"<ul> <li> <p>The transition variable group table formulas generalize to an arbitrary number of outgoing compartments -- however, this is not shown here.</p> </li> <li> <p>Note that Poisson is not included in the above table. Recall the splitting property of Poisson processes. If the total outflow (going to either compartment, \\(\\texttt{C}_1\\) or \\(\\texttt{C}_2\\)) is Poisson, we can split the process into two independent Poisson processes. So joint sampling is not actually needed. </p> </li> <li> <p>In contrast, the binomial distribution does not have such a splitting property. If the total outflow is binomial with parameters \\(n\\) and \\(p\\), then we cannot use a similar Poisson splitting technique to create two independent binomial random variables with the same number of trial parameters \\(n\\). Thus, joint sampling is needed. </p> </li> <li> <p>An advantage of binomial/multinomial transition variables (with joint sampling when there are multiple outflows from a compartment) is that we cannot have more people leaving the origin compartment than are actually in the compartment. We set the \"number of trials\" parameter in the multinomial distribution to be the current number of people in the compartment. This is NOT the case for Poisson transition variables, which are unbounded! Thus, we recommend using binomial/multinomial transition types.</p> </li> <li> <p>See <code>update_compartments</code> method in <code>clt_toolkit / base_components.py / MetapopModel</code> for details on how we adjust compartment values for deterministic implementations. Note that the stochastic transitions have realizations that are always integer, and due to multinomial sampling (see previous point), the compartments are always nonnegative. With any of our deterministic transitions, our transitions are not guaranteed to be integer, and our compartments are not guaranteed to be nonnegative. With deterministic transitions, we apply a \"softplus\" function (a smooth approximation to the ReLU function) to all compartment values of all compartments. This makes compartments nonnegative. </p> </li> <li> <p>For the binomial/multinomial Taylor approximation transition type, if the simulation discretization parameter \\(\\Delta t\\) is too large, then it is possible for the \"probability parameter\" to be nonsensical. For example, in the table above, it is possible for \\(r_1 \\Delta t &gt; 1\\) or \\(r_2 \\Delta t &gt; 1\\) if \\(\\Delta t\\) is not sufficiently small. Similarly, it is possible for \\(1 - (r_1 + r_2) \\Delta t &lt; 0\\) if \\(\\Delta t\\) is not sufficiently small. Thus, we cannot use these values as probabilities input for the binomial distribution. As a result, we recommend using the binomial transition type with no Taylor approximation. This transition type converts rates into probabilities that are always between \\([0,1]\\) and thus always well-defined to be input as a probability parameter in a binomial distribution.</p> </li> </ul>"},{"location":"old/","title":"Old","text":"<p>In this section, we provide an explanation of how the flu model (in <code>flu_components.py</code>) is created from the base model components (in <code>base_components.py</code>). In doing so, we also demonstrate how to create other customized models from the base model components. We also provide justification for design choices, in a way intended to educate users on some of the implementation and computation challenges in writing scalable and adaptable compartmental models. </p> <p>Writing code to create a customized compartmental model requires correct use of inheritance, composition, and abstract base classes. We strongly recommend reading this tutorial for a good primer on those subjects. We also recommend learning about the <code>dataclass</code> decorator in Python (see this blogpost, for example).</p>"},{"location":"old/#creating-a-model-from-base-components-details","title":"Creating a model from base components: details","text":"<p>Creating a compartment model requires the following steps.</p> <ol> <li> <p>Formulate the compartment model mathematically, and write down all <code>EpiCompartment</code>, <code>TransitionVariable</code>, <code>TransitionVariableGroup</code> (jointly sampled sets of transition variables), and <code>StateVariable</code> objects needed for the model. </p> </li> <li> <p>Create a new file that imports the <code>base_components</code> module. We import this module as <code>base</code>. </p> </li> <li> <p>Create two <code>JSON</code> files: one for fixed parameters and one for initial values of state variables. </p> <p>a. For the fixed parameters <code>JSON</code> file, required fields are <code>\"num_age_groups\"</code>, <code>\"num_risk_groups\"</code>, and <code>\"total_population_val\"</code>. All other fields must correspond to fixed parameters in the model -- these are used throughout model computation.</p> <ul> <li>See <code>flu_demo_input_files / fixed_params.json</code>.</li> </ul> <p>b. For the initial values of state variables <code>JSON</code> file, there must be a field for each <code>StateVariable</code> object used in the model. These values correspond to the initial values of these state variables. For example, this file contains initial populations of each <code>EpiCompartment</code>, expressed as a list of lists corresponding to age groups and risk groups. Similarly, this file contains starting values for each <code>EpiMetric</code>. We also need fields for all <code>DynamicVal</code> and <code>Schedule</code> objects in the model, although their values can be set to <code>null</code> since their initial state will be updated automatically (either according to a deterministic calendar or a simulate state trigger). We just need to include their names for bookkeeping purposes. </p> <ul> <li>See <code>flu_demo_input_files / state_variables_init_vals.json</code>.</li> </ul> </li> <li> <p>Create subclasses to hold data. </p> <p>a. Create a subclass of <code>base.FixedParams</code> to hold the model's fixed parameters. For each name in the fixed parameters <code>JSON</code> file, there should be a corresponding attribute (with the same name) in this subclass.</p> <ul> <li>See <code>FluFixedParams</code> in <code>flu_components.py</code>.</li> </ul> <p>b. Create a subclass of <code>base.SimState</code> to hold the model's simulation state. For each name in the initial values of state variables <code>JSON</code> file, there should be a corresponding attribute (with the same name) in this subclass. </p> <ul> <li>See <code>FluSimState</code> in <code>flu_components.py</code>.</li> </ul> </li> <li> <p>For each transition in the model, create a subclass of <code>base.TransitionVariable</code> and provide a concrete implementation of the abstract method <code>get_current_rate</code>. The function <code>get_current_rate</code> returns the value of the current rate, and is a function of a <code>FluSimState</code> instance and a <code>FluFixedParams</code> instance. These arguments allow us to access various values needed for the computation. </p> <ul> <li>See <code>SusceptibleToExposed</code> subclass in <code>flu_components.py</code>. The function <code>get_current_rate</code> implements the formula for computing the current rate that people transition from the susceptible to exposed compartment. For example, <code>get_current_rate</code> grabs <code>sim_state.IS</code>, <code>sim_state.IP</code>, and <code>sim_state.IA</code>, because the current values of the symptomatic, pre-symptomatic, and asymptomatic infectious compartments are needed for the rate computation.</li> </ul> </li> <li> <p>For each dynamic value in the model, create a subclass of <code>base.DynamicVal</code> and provide a concrete implementation of the abstract method <code>update_current_val</code>. The function <code>update_current_val</code> also takes a <code>FluSimState</code> instances and <code>FluFixedParams</code> instance as arguments, analogously to <code>TransitionVariable</code> subclasses. It updates the <code>current_val</code> attribute in-place.</p> <ul> <li>See <code>BetaReduct</code> in <code>flu_components.py</code>. Note here we have also customized the <code>_init_</code> method and added an attribute <code>permanent_lockdown</code>, to accommodate additional functionality. </li> </ul> </li> <li> <p>For each schedule in the model, create a subclass of <code>base.Schedule</code> and provide a concrete implementation of the abstract method <code>update_current_val</code>, which should be a function of the current date (a <code>datetime.date</code> instance). This function updates the <code>current_val</code> attribute in place.  </p> <ul> <li>See <code>AbsoluteHumidity</code> in <code>flu_components.py</code>. Note we update the current value using the helper function <code>absolute_humidity_func</code>.   </li> </ul> </li> <li> <p>Create a subclass of <code>base.ModelConstructor</code>. Customize the <code>_init_</code> function and provide concrete implementations for the six abstract methods (listed below). </p> <ul> <li>See <code>FluModelConstructor</code> in <code>flu_components.py</code>.</li> </ul> <p>a. Customize the <code>_init_</code> function.</p> <ul> <li>See <code>_init_</code> in <code>FluModelConstructor</code>. This method first calls <code>super()._init_()</code>, which runs the initialization method of the parent class. Importantly, the parent class initialization creates dictionaries that hold our objects (for example, it creates the attribute <code>compartment_lookup</code>). Then we assign the <code>config</code>, <code>fixed_params</code>, and <code>sim_state</code> attributes according to the contents of user-specified <code>JSON</code> files.</li> </ul> <p>b. Provide a concrete implementation of <code>setup_epi_compartments</code>. Specifically, for every compartment, create an entry in <code>compartment_lookup</code>, with the name as the key and the value as the corresponding <code>EpiCompartment</code> instance. Names should match the compartment names in the initial values of state variables <code>JSON</code>.</p> <p>c. Provide a concrete implementation of <code>setup_dynamic_vals</code>. Specifically, for every dynamic value, create an entry in <code>dynamic_val_lookup</code>, with the name as the key and the value as the corresponding <code>DynamicVal</code> instance. Names should match the dynamic value names in the initial values of state variables <code>JSON</code>.</p> <ul> <li>In <code>FluModelConstructor</code>, we create an entry in <code>dynamic_val_lookup</code> with the key of <code>\"beta_reduct\"</code> and the value of a properly initialized <code>BetaReduct</code> instance. Note that <code>BetaReduct</code> is a <code>DynamicVal</code>, but we cannot use <code>DynamicVal</code> directly, as it is an abstract class. We have to use the relevant concretely implemented subclass.</li> </ul> <p>d. Provide a concrete implementation of <code>setup_schedules</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).</p> <p>e. Provide a concrete implementation of <code>setup_transition_variables</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).</p> <p>f. Provide a concrete implementation of <code>setup_transition_variable_groups</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).      </p> <p>g. Provide a concrete implementation of <code>setup_epi_metrics</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).  </p> </li> </ol>"},{"location":"old/#creating-a-model-from-base-components-checklist","title":"Creating a model from base components: checklist","text":"<p>Here we provide a brief outline of steps for creating a compartment model, intended as a reminder checklist. Please see the previous section for explanatory details. </p> <ol> <li> <p>Formulate the compartment model.</p> </li> <li> <p>Create a new file that imports the <code>base_components</code> module. We import this module as <code>base</code>. </p> </li> <li> <p>Create two <code>JSON</code> files: one for fixed parameters and one for initial values of state variables. </p> <ul> <li>Initial values for schedules and dynamic values can be left as <code>null</code>, but they still must have a field in the <code>JSON</code> file. </li> </ul> </li> <li> <p>Create subclasses to hold data: a subclass of <code>base.FixedParams</code> and a subclass of <code>base.SimState</code>. </p> <ul> <li>Note that there should be a one-to-one mapping between the fixed parameters <code>JSON</code> file and the attributes of <code>base.FixedParams</code>, and similarly for the initial values of state variables <code>JSON</code> and the attributes of <code>base.SimState</code>. </li> </ul> </li> <li> <p>For each transition variable in the model, create a unique subclass of <code>base.TransitionVariable</code> corresponding to that transition and provide a concrete implementation of <code>get_current_rate</code>.</p> </li> <li> <p>For each dynamic value in the model, create a subclass of <code>base.DynamicVal</code> and provide a concrete implementation of <code>update_current_val</code>.</p> </li> <li> <p>For each schedule in the model, create a subclass of <code>base.Schedule</code> and provide a concrete implementation of <code>update_current_val</code>.</p> </li> <li> <p>Create a subclass of <code>base.ModelConstructor</code>. Customize the <code>_init_</code> function, making sure to assign the <code>config</code>, <code>fixed_params</code>, and <code>sim_state</code> attributes to instances of <code>base.Config</code>, <code>base.FixedParams</code>, and <code>base.SimState</code>. Provide concrete implementations of <code>setup_epi_compartments</code>, <code>setup_dynamic_vals</code>, <code>setup_schedules</code>, <code>setup_transition_variables</code>, <code>setup_transition_variable_groups</code>, and <code>setup_epi_metrics</code>. </p> </li> </ol> <p>Note: figures below were generated with older flu model version without presymptomatic and asymptomatic infected compartments -- figures generated with updated code will look slightly different. </p> <p>Here we provide a quickstart tutorial to help users immediately start playing with the flu model in <code>flu_components.py</code> with \"toy\" inputs given by <code>JSON</code> files in <code>flu_demo_input_files</code>. Recall that the structure (functional form) of the flu model is specified in <code>flu_components.py</code>, and the input files simply specify fixed parameter values and initial values for state variables.  See this page for the mathematical formulation of the flu model. For creating their own custom input files, users should refer to tables on this page that map code variable names to their respective math variables and specify variable dimensions. </p> <p>The code snippet below is from <code>flu_demo.py</code>. The script can be run directly from the terminal using </p> <pre><code>python flu_demo.py\n</code></pre> <p>Here\u2019s the basic procedure to populate the flu model using input files:</p> <ol> <li> <p>Create a <code>FluModelConstructor</code> instance that takes three file paths as input: the configuration file path, fixed parameter values file path, and initial values file path (all in <code>JSON</code> format).</p> </li> <li> <p>Use this constructor to create a <code>TransmissionModel</code> instance whose functional form is specified by <code>flu_components.py</code> and whose fixed parameter values and initial values are specified in the three aforementioend files.</p> </li> </ol> <p>After this, we can simulate the model and plot its behavior. Below, we simulate 300 days. </p> <pre><code>import numpy as np\nfrom pathlib import Path\n\nfrom flu_components import FluModelConstructor\nfrom plotting import create_basic_compartment_history_plot\n\n# Obtain path to folder with JSON input files\nbase_path = Path(__file__).parent / \"flu_demo_input_files\"\n\n# Get filepaths for configuration, fixed parameter values, and\n#   initial values of state variables\nconfig_filepath = base_path / \"config.json\"\nfixed_params_filepath = base_path / \"fixed_params.json\"\nstate_vars_init_vals_filepath = base_path / \"state_variables_init_vals.json\"\n\n# Create a constructor using these filepaths\nflu_demo_constructor = \\\n    FluModelConstructor(config_filepath,\n                        fixed_params_filepath,\n                        state_vars_init_vals_filepath)\n\n# Create TransmissionModel instance from the constructor,\n#   using a random number generator with starting seed 888888\n#   to generate random variables\nflu_demo_model = flu_demo_constructor.create_transmission_model(888888)\n\n# Simulate 300 days\nflu_demo_model.simulate_until_time_period(300)\n\n# Plot\ncreate_basic_compartment_history_plot(flu_demo_model,\n                                      \"flu_demo_model.png\")\n</code></pre> <p></p> <p>The following code snippets and outputs below replicate the experience of working in a Python interactive console.</p> <p>After simulating 300 days, the <code>current_simulation_day</code> counter indeed is 300, and the attribute <code>current_real_date</code> gives us the corresponding real-world date associated with the simulation day counter.</p> <pre><code>flu_demo_model.current_simulation_day\n# 300\n\nflu_demo_model.current_real_date\n# datetime.date(2023, 6, 4)\n</code></pre> <p>Note that subsequent <code>simulate_until_time_period</code> calls will start from where the simulation last ended, and its argument <code>last_simulation_day</code> must be greater than the model's <code>current_simulation_day</code>. For example, after running <code>flu_demo_model.simulate_until_time_period(300)</code>, a command like <code>flu_demo_model.simulate_until_time_period(100)</code> is invalid (we cannot simulate backwards in time), but <code>flu_demo_model.simulate_until_timeperiod(305)</code> starts from day 300 and continues.</p> <p><code>TransmissionModel</code> instances have a <code>StateVariableManager</code> that manages and holds StateVariables (EpiCompartments, EpiMetrics, DynamicVals, and Schedules). Using the command below, we can access the state of the simulation after we simulated the model for 300 days. </p> <pre><code>flu_demo_model.sim_state\n# FluSimState(S=array([[306539.],\n#       [261363.]]), E=array([[31501.],\n#       [36027.]]), I=array([[105991.],\n#       [114542.]]), H=array([[ 98354.],\n#       [104663.]]), R=array([[175885.],\n#       [186626.]]), D=array([[281730.],\n#       [296779.]]), population_immunity_hosp=array([[0.11555325],\n#       [0.12078151]]), population_immunity_inf=array([[0.11555325],\n#       [0.12078151]]), absolute_humidity=12.31748, \n#       flu_contact_matrix=array([[[[2.], [0.5]]], [[[1.95], [1.4]]]]))\n</code></pre> <p>We can also use our model's built-in dictionary to look up simulation objects (any StateVariable, as well as any TransitionVariable and TransitionVariableGroup) by name. Here, <code>S</code> is an <code>EpiCompartment</code> instance, and we can see its current value at the current day of the simulation. </p> <pre><code>flu_demo_model.lookup_by_name[\"S\"]\n# &lt;base_components.EpiCompartment object at 0x174a79750&gt;\n\nflu_demo_model.lookup_by_name[\"S\"].current_val\n# array([[306539.],\n#        [261363.]])\n</code></pre> <p>We can also access a StateVariable's history with the attribute <code>history_vals_list</code>. For example, <code>flu_demo_model.lookup_by_name[\"S\"].history_vals_list</code> gives a list of all the previous current values of the \"Susceptible\" compartment. The \\(i\\)th element in the list holds the compartment's value at the end of simulation day \\(i\\). </p> <p>Next, we look at the current value (most recent realization) of the TransitionVariable <code>new_dead.</code> We also look at its <code>current_rate</code> attribute, which is the rate that generated the most recent realization. </p> <pre><code>flu_demo_model.lookup_by_name[\"new_dead\"].current_val\n# array([[406.],\n#        [435.]])\n\nflu_demo_model.lookup_by_name[\"new_dead\"].current_rate\n# array([[0.00823744],\n#        [0.00820603]])\n</code></pre> <p>We can reset the simulation to restart the simulation or clear the simulation's state and history to run a new replication on the same model, with the same initial conditions. Important note: resetting the simulation does NOT reset the random number generator -- random numbers will continue where the generator last left off. <pre><code>flu_demo_model.reset_simulation()\n</code></pre></p> <p>Notice that the current simulation day has returned to 0 and the simulation state has returned to its initial state. Each StateVariable's history has also been cleared. <pre><code>flu_demo_model.current_simulation_day\n# 0\n\nflu_demo_model.sim_state\n# FluSimState(S=array([[980000.],\n#       [980000.]]), E=array([[10000.],\n#       [10000.]]), I=array([[10000.],\n#       [10000.]]), H=array([[0.],\n#       [0.]]), R=array([[0.],\n#       [0.]]), D=array([[0.],\n#       [0.]]), population_immunity_hosp=array([[0.5],\n#       [0.5]]), population_immunity_inf=array([[0.5],\n#       [0.5]]), absolute_humidity=None, flu_contact_matrix=None)\n\nflu_demo_model.lookup_by_name[\"S\"].history_vals_list\n# []\n</code></pre></p> <p>To reset the random number generator, we must use the <code>modify_random_seed</code> method -- and pass the initial random seed. This resets the numpy RNG object to a state given by this seed. We can also use the <code>modify_random_seed</code> method to handle random number generation more broadly, and ensure that each simulation replication uses independent random numbers. To handle random number generation responsibly, refer to these two links here and here.</p> <p>Suppose that we want to modify configuration values, values of fixed parameters, or initial values. We can modify these values on our model constructor, and then create a new model instance. For example, below we change the transition type to \"binomial_deterministic\" and the beta baseline value to be \\(0\\). By changing <code>beta_baseline</code> to \\(0\\), no transmission occurs, and the plot verifies this. </p> <pre><code>flu_demo_constructor.config.transition_type = \"binomial_deterministic\"\nflu_demo_constructor.fixed_params.beta_baseline = 0\n\nflu_demo_model_beta_baseline_zero = \\\n    flu_demo_constructor.create_transmission_model(999999)\n\ncreate_basic_compartment_history_plot(flu_demo_model_beta_baseline_zero,\n                                      \"flu_demo_model_beta_baseline_zero.png\")\n</code></pre> <p></p>"},{"location":"python_resources/","title":"Python Resources for Modelers","text":"<p>Written by LP, updated 08/25/2025 (work in progress) </p> <p>Here we provide a list of fundamental concepts for epidemiologists to know to responsibly create, collaborate on, and interact with responsible and reproducible Python code. We have outlined this somewhat like a syllabus for self-directed learning, with links to resources to get started. The reader should make sure they understand all key concepts in the checklist, and read more otherwise. </p> <p>Note: we particularly like Real Python, which has many free and thorough tutorials on various Python subjects!</p>"},{"location":"python_resources/#coding-correctly","title":"Coding correctly","text":"<p>Clean code matters for academic research with high standards.</p> <p>Recommended textbooks (PDF links are unaffiliated with epi-ENGAGE):</p> <ul> <li>***MUST READ: \"The Art of Readable Code\" by Boswell &amp; Foucher</li> <li>\"A Philosophy of Software Design\" by Ousterhout</li> <li>\"Refactoring: Improving the Design of Existing Code\" by Fowler &amp; Beck</li> <li>\"Clean Code: A Handbook of Agile Software Craftsmanship\" by Martin</li> </ul> <p>Key concepts</p> <ul> <li>\"The Fundamental Theorem of Readability: Code should be written to minimize the time it would take for someone else to understand it.\" (Boswell &amp; Foucher)</li> <li>Function and variable names should be specific and precise -- ChatGPT is great at helping brainstorm names!</li> <li>DOT -- DO ONE THING -- \"Functions should do one thing. They should do it well. They should do it only.\" And \"functions should do something, or answer something, but not both.\" (Martin) -- nice articles here and here.</li> <li>DRY -- DON'T REPEAT YOURSELF (Hunt &amp; Thomas) -- example resources here and here.</li> <li>Tactical instead of strategic programming leads to technical debt -- \"Complexity comes from an accumulation of dependencies and obscurities. As complexity increases, it leads to change amplification, a high cognitive load, and unknown unknowns.\" (Ousterhout) </li> </ul> <p>Advanced concepts</p> <ul> <li>For classes -- \"Single Responsibility Principle\" (Martin) -- example resources here and here.</li> </ul>"},{"location":"python_resources/#test-test-test","title":"Test, test, test!","text":"<p>Key concepts</p> <ul> <li>Any time a user changes code or adds code, they should add new tests and also make sure that all the old tests still pass. </li> <li>Unit testing is critical to ensuring code behaves as intended and ensuring that changes/updates do not add new bugs or break existing functionality. If we haven't tested it, we shouldn't trust it. We should prove our code works! Check out this great MIT lecture on testing here.</li> <li>Testing should have good coverage and handle different edge cases -- bugs often occur \"on the boundaries\" of inputs. </li> <li>The CLT Base Model code uses <code>pytest</code> for easy management of unit testing -- here's an in-depth tutorial. </li> <li>We must also implement higher-level tests such as integration tests and acceptance tests, to make sure the whole shebang works.</li> <li>One crucial reason to write modular code (and functions that do one thing only) is to allow for testing of specific modules and functions (Boswell &amp; Foucher). If the code is not easy to test, we cannot easily guarantee its quality.</li> </ul> <p>Bonus articles on testing</p> <ul> <li>Check out these nice articles on unit testing here and here.  And here is a nice overview of TDD -- Test-Driven Development (Martin).</li> </ul>"},{"location":"python_resources/#python-modules-and-imports-ides-and-running-python-scripts","title":"Python modules and imports, IDEs, and running Python scripts","text":"<p>Key concepts</p> <ul> <li>Jupyter notebooks are for exploration, NOT for collaborative software development. Nature wrote a blog post warning about Jupyter notebooks: \"computational notebooks can also be confusing and foster poor coding practices. And they are difficult to share, collaborate on and reproduce. A 2019 study found that just 24% of 863,878 publicly available Jupyter notebooks on GitHub could be successfully re-executed, and only 4% produced the same results\" -- blog post link here and conference paper here. </li> <li>As programs grow in size, they should be split into smaller files and organized -- modules and importing are key here. Here's a quick tutorial and a more in-depth tutorial.</li> <li>Interactive Developer Environments (IDEs) are ideal for working with Python modules. We recommend Pycharm -- the community edition here is free to download.</li> <li>Python can be run in many different ways -- users should understand the difference between running a script in an IDE Console and from the command line -- here's a guide.</li> <li>We recommend pip or conda for Python package management. There can sometimes be some issues with mixing pip and conda, so it may be helpful to consistently only use one or the other. </li> <li>Users should be comfortable reading API documentation such as the CLT Base Model Code's references or numpy's references -- there is no need to try to memorize syntax. Users should be comfortable parsing the technical details of classes and methods, customizing default arguments, and playtesting parts of the package for themselves. </li> </ul> <p>More reading</p> <ul> <li>Jupyter notebooks have issues with hidden states -- read more here.</li> </ul>"},{"location":"python_resources/#documentation-and-version-control","title":"Documentation and version control","text":"<p>Key concepts</p> <ul> <li> <p>Users should be familiar with git. We strongly recommend this nice guide on github collaboration here.</p> <ul> <li>Specifically, users should know the following concepts in git: cloning a repo, local and remote repos, committing and pushing, pull requests, pulling, merging.</li> </ul> </li> <li> <p>Collaborators should never push to main -- they should create a pull request (after adding tests and checking all tests) to request the main branch incorporate any new changes.</p> </li> <li> <p>Users should STOP the common practice of saving versions like <code>simulation_v3.2_final_final_01302025</code> -- this is horrible for many reasons. Users should instead use git version control and intentional git commit messages to keep track of their code versions.</p> </li> <li> <p>Users should add <code>.txt</code> and <code>.md</code> files documenting any mathematical parameters to their repo and make this a part of their version control setup. This way, users can keep track of WHY and WHEN certain parameter values were changed. </p> </li> <li> <p>The CLT Base Model Code documentation on this website is generated using <code>mkdocs</code>, and automatically populates code references hosted on this website from the code. The code docstrings must follow a specific format, outlined here.</p> </li> <li>Users should always write proper function signatures in their code -- specifying data input and return types is very important. This article here is a starting point to learn more.  </li> </ul>"},{"location":"python_resources/#other-important-points","title":"Other important points...","text":"<p>Key concepts</p> <ul> <li>The CLT Base Model code uses object-oriented programming (OOP), which may be new to some modelers. The coding structure is similar to StarSim and TACC's Pandemic Simulator -- it is a tried and tested strategy. We strongly recommend this tutorial for those new to OOP.<ul> <li>Specifically, users should know the following concepts: inheritance, attributes, abstract base classes, abstract methods.</li> </ul> </li> <li>We need to be responsible with random number generation. Please, stop using <code>np.random.seed</code>! Use generators instead! Here is a superb article outlining some dangers with misusing <code>numpy</code> random number generation, with links to the relevant numpy documentation. </li> <li>For-loops are horrible for efficiency and vectorized operations are better. Often, when possible, mathematical computations should be written in matrix multiplication form instead of for-loops. Here is a tutorial on the essentials of <code>numpy</code> and vectorized operations on <code>numpy</code> arrays.</li> <li>The <code>dataclasses</code> module makes storing data very easy -- here's a quick tutorial.</li> <li>Users should understand interfaces and duck typing in Python -- here's a short overview.</li> </ul>"}]}