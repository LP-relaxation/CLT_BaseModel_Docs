{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"City-level Transmission (CLT) Base Model","text":"<p>The CLT base model is a mathematical framework and modular Python codebase for scalable compartmental models of respiratory virus transmission in a city. This model is written by the Meyers Lab and epiENGAGE center.</p> <p>Please visit this website for mathematical formulations, code documentation including tutorials, and code API references. </p> <p>The mathematical framework is inspired by the immunoSEIRS model of the Meyers Lab (see Bi and Bandekar et al. 2023, Bi et al. 2022 and Bouchnita et al. 2021 for some related recent publications).</p> <p>Documentation is created by Linda Pei (\"LP\"). Base model code is created by LP in collaboration with Shuotao \"Sonny\" Diao, Remy Pasco, and Emily Javan, and with supervision from Dave Morton and Lauren Meyers. Special thanks to Cary Murray for generous guidance on software engineering design. Special credit to Sonny for his ideas about updating compartments analogously to pushing flow on a graph and creating simulation logic that works for arbitrarily many compartments and transition variables. </p>"},{"location":"#setup","title":"Setup","text":"<p>The CLT base model code is written in Python 3.11.0.</p> <p>To download the latest code release, run the following in Terminal: <pre><code>git clone https://github.com/LP-relaxation/CLT_BaseModel.git\n</code></pre></p> <p>Packages used <pre><code>numpy==1.24.3\npandas==1.5.3\npytest==8.3.3\n</code></pre></p>"},{"location":"#codebase-overview","title":"Codebase Overview","text":"<p>Below is an overview of the files in the CLT base model code.</p> <pre><code>base_components.py      # Base classes used to create a compartmental model.\n\nflu_components.py       # A specific S-E-I-H-R-D model for influenza.\n\nflu_tests.py            # Suite of pytest tests for flu_components.py.\n\nflu_demo.py             # Demo implementation of flu_components.py\n                          flu model for tutorial and testing purposes.\n\nflu_demo_input_files    # Collection of .json and .csv files used as \n                          input values for flu_demo.py. These values are\n                          \"toy\" predefined values for demo purposes only. \n                          Realistic applications will use estimation \n                          and calibration from real-world data.\n</code></pre> <p>To execute the simple flu demo model, run the following in Terminal (on Mac): <pre><code>python flu_demo.py\n</code></pre></p> <p>To execute the flu model tests, run the following in Terminal (on Mac): <pre><code>pytest -v flu_tests.py\n</code></pre></p>"},{"location":"SIHR_components_walkthrough/","title":"A Simple Custom SIHR Model: Components Walkthrough","text":"<p>Written by LP, updated 02/27/2025 (work in progress) </p> <p>In this tutorial, we work through <code>SIHR_components.py</code> in the folder <code>SIHR_model</code> to demonstrate how to inherit from the <code>clt_base</code> package and create a customized model with a customized functional form. </p> <p>This code demonstrates how to inherit from clt_base to create a customized model for one subpopulation -- this is intended as an intermediate tutorial for code users (and as somewhat of an introductory tutorial to inheritance and abstract methods).</p> <p>The S-I-H-R model we demonstrate has the following structure:</p> <pre><code>#  S -&gt; I -&gt; H -&gt; R\n#       I ------&gt; R\n</code></pre> <p>So people in the I (infected) compartment either move to H or R (go to the hospital or recover).</p>"},{"location":"SIHR_components_walkthrough/#imports","title":"Imports","text":"<ul> <li><code>numpy</code> is our standard array manipulation package.</li> <li><code>sciris</code> is a nice package that StarSim uses -- we will use it for \"object dictionaries\" -- to access values in dictionaries using dot   notation, which is very convenient.</li> <li><code>dataclasses</code> provide favorable ways to store data.</li> <li><code>typing</code> (specifically Optional) gives us the ability to allow optional arguments for instantiating dataclasses.</li> <li>And finally, don't forget to import the <code>clt_base</code> package -- we'll need this to create our model!</li> </ul> <pre><code>import numpy as np\nimport sciris as sc\nfrom pathlib import Path\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\nimport clt_base as clt\n</code></pre>"},{"location":"SIHR_components_walkthrough/#required-subclasses","title":"Required Subclasses","text":"<p>When creating a custom model, we need to define the following subclasses:  </p> <ul> <li>Exactly 1 subclass of <code>clt.SubpopParams</code> -- holds the model's fixed parameters.  </li> <li>Exactly 1 subclass of <code>clt.SubpopState</code> -- holds the model's simulation state.  </li> <li>Potentially multiple subclasses of <code>clt.TransitionVariable</code> -- one for each type of transition variable, managing transitions between epidemiological compartments.  </li> <li> <p>Potentially 0 or multiple subclasses of <code>clt.StateVariable</code>, specifically:</p> <ul> <li><code>clt.EpiMetric</code>, <code>clt.DynamicVal</code>, and <code>clt.Schedule</code> for any epidemiological metrics, dynamic values, or schedules in the model.  </li> <li>Note: We generally do not need subclasses of <code>clt.Compartment</code> unless we require special compartments with advanced functionality beyond what <code>clt.Compartment</code> already provides.  </li> </ul> </li> <li> <p>Exactly 1 subclass of <code>clt.SubpopModel</code> -- wraps everything together in the simulation model.  </p> </li> </ul> <p>To keep this S-I-H-R model and demo simple, we do not include epidemiological metrics, dynamic values, or schedules, so we will not need to create associated subclasses.  </p>"},{"location":"SIHR_components_walkthrough/#step-zero-planning-the-model","title":"Step Zero: Planning the Model","text":"<p>Before coding, we must:  </p> <ol> <li>Write down the model structure and any mathematical formulas.  </li> <li>Define the names (as strings) for all key elements in the model.  </li> <li>Ensure our variable names in the code align with these planned names.  </li> </ol>"},{"location":"SIHR_components_walkthrough/#compartments","title":"Compartments","text":"<p>The model consists of 4 compartments: </p> <ul> <li><code>\"S\"</code> (Susceptible)  </li> <li><code>\"I\"</code> (Infected)  </li> <li><code>\"H\"</code> (Hospitalized)  </li> <li><code>\"R\"</code> (Recovered)  </li> </ul> <p>We will create four <code>clt.Compartment</code> instances with these names.  </p>"},{"location":"SIHR_components_walkthrough/#transition-variables","title":"Transition Variables","text":"<p>We will define 4 transition variables, each as a <code>clt.TransitionVariable</code> subclass:  </p> <ul> <li><code>\"SusceptibleToInfected\"</code> (for transitions from <code>\"S\"</code> to <code>\"I\"</code>)  </li> <li><code>\"InfectedToHospitalized\"</code> (for transitions from <code>\"I\"</code> to <code>\"H\"</code>)  </li> <li><code>\"HospitalizedToRecovered\"</code> (for transitions from <code>\"H\"</code> to <code>\"R\"</code>)  </li> <li><code>\"InfectedToRecovered\"</code> (for transitions from <code>\"I\"</code> to <code>\"R\"</code>)  </li> </ul>"},{"location":"SIHR_components_walkthrough/#fixedconstant-parameters","title":"Fixed/Constant Parameters","text":"<p>In addition to <code>\"num_age_groups\"</code> and <code>\"num_risk_groups\"</code>, our model includes the following parameters:  </p> <ul> <li><code>\"total_pop_age_risk\"</code> </li> <li><code>\"beta\"</code> </li> <li><code>\"I_to_H_rate\"</code> </li> <li><code>\"I_to_R_rate\"</code> </li> <li><code>\"H_to_R_rate\"</code> </li> <li><code>\"I_to_H_prop\"</code> </li> </ul>"},{"location":"SIHR_components_walkthrough/#mathematical-formulas-for-transitions","title":"Mathematical Formulas for Transitions","text":"<p>The transition rates are defined as follows:  </p> <ul> <li><code>\"S\"</code> to <code>\"I\"</code> transition rate:  </li> </ul> <p>$$ I \\times \\frac{\\beta}{\\text{total_pop_age_risk}} $$ - <code>\"I\"</code> to <code>\"H\"</code> transition rate:   $$ \\text{I_to_H_rate} \\times \\text{I_to_H_prop} $$ - <code>\"I\"</code> to <code>\"R\"</code> transition rate:   $$ \\text{I_to_R_rate} \\times \\text{(1 - I_to_H_prop)} $$ - <code>\"H\"</code> to <code>\"R\"</code> transition rate:   $$ \\text{H_to_R_rate} $$</p>"},{"location":"SIHR_components_walkthrough/#creating-a-subpopparams-subclass","title":"Creating a <code>SubpopParams</code> Subclass","text":"<p>First, we create our <code>clt.SubpopParams</code> subclass.  </p> <ul> <li>We use the <code>@dataclass</code> decorator to enable convenient data storage functionality.  </li> <li>Each field must have a unique and descriptive name for the fixed parameters in our model.  </li> <li>Including <code>\"num_age_groups\"</code> and <code>\"num_risk_groups\"</code> is recommended to simplify computations, as many arrays in the model will have a shape of (<code>num_age_groups</code> \u00d7 <code>num_risk_groups</code>).  </li> <li>Each field must have a specified data type.  </li> <li>The <code>Optional</code> type allows setting default values for parameters if they are not explicitly defined.  </li> </ul> <p>For more details on <code>dataclasses</code>, refer to the official Python documentation.  </p> <pre><code>@dataclass\nclass SIHRSubpopParams(clt.SubpopParams):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in SIHR model.\n\n    Each field of datatype np.ndarray must be A x L,\n    where A is the number of age groups and L is the number of\n    risk groups. Note: this means all arrays should be 2D.\n\n    Attributes:\n        num_age_groups (positive int):\n            number of age groups.\n        num_risk_groups (positive int):\n            number of risk groups.\n        total_pop_age_risk (np.ndarray of positive ints):\n            total number in population, summed across all\n            age-risk groups.\n        beta (positive float): transmission rate.\n        I_to_H_rate (positive float):\n            rate at which people in I move to H --\n            units of people per day.\n        I_to_R_rate (positive float):\n            rate at which people in I move to R --\n            units of people per day.\n        H_to_R_rate (positive float):\n            rate at which people in H move to R --\n            units of people per day.\n        I_to_H_prop (np.ndarray):\n            contains values in [0,1] corresponding to\n            probability of going to hospital given\n            infection, for a specific age-risk group\n            (age is given by row index, risk is\n            given by column index).\n    \"\"\"\n\n    num_age_groups: Optional[int] = None\n    num_risk_groups: Optional[int] = None\n    total_pop_age_risk: Optional[np.ndarray] = None\n    beta: Optional[float] = None\n    I_to_H_rate: Optional[float] = None\n    I_to_R_rate: Optional[float] = None\n    H_to_R_rate: Optional[float] = None\n    I_to_H_prop: Optional[np.ndarray] = None\n</code></pre>"},{"location":"SIHR_components_walkthrough/#creating-a-subpopstate-subclass","title":"Creating a <code>SubpopState</code> subclass","text":"<p>Next, we create our <code>clt.SubpopState</code> subclass. We also need the <code>@dataclass</code> decorator here and we also need to specify the datatype of each field.</p> <pre><code>@dataclass\nclass SIHRSubpopState(clt.SubpopState):\n    \"\"\"\n    Data container for pre-specified and fixed set of\n    Compartment initial values and EpiMetric initial values\n    in SIHR model.\n\n    Each field below should be A x L np.ndarray, where\n    A is the number of age groups and L is the number of risk groups.\n    Note: this means all arrays should be 2D. Even if there is\n    1 age group and 1 risk group (no group stratification),\n    each array should be 1x1, which is two-dimensional.\n    For example, np.array([[100]]) is correct --\n    np.array([100]) is wrong.\n\n    Attributes:\n        S (np.ndarray of positive floats):\n            susceptible compartment for age-risk groups --\n            (holds current_val of Compartment \"S\").\n        I (np.ndarray of positive floats):\n            infected for age-risk groups\n            (holds current_val of Compartment \"I\").\n        H (np.ndarray of positive floats):\n            hospitalized compartment for age-risk groups\n            (holds current_val of Compartment \"H\").\n        R (np.ndarray of positive floats):\n            recovered compartment for age-risk groups\n            (holds current_val of Compartment \"R\").\n    \"\"\"\n\n    S: Optional[np.ndarray] = None\n    I: Optional[np.ndarray] = None\n    H: Optional[np.ndarray] = None\n    R: Optional[np.ndarray] = None\n</code></pre>"},{"location":"SIHR_components_walkthrough/#creating-transitionvariable-subclasses","title":"Creating <code>TransitionVariable</code> Subclasses","text":"<p>For each transition variable, we create a subclass of <code>clt.TransitionVariable</code>.  </p> <p><code>clt.TransitionVariable</code> is an abstract base class and includes an abstract method <code>get_current_rate</code>, which we must implement in our subclass.  </p>"},{"location":"SIHR_components_walkthrough/#implementing-get_current_rate","title":"Implementing <code>get_current_rate</code>","text":"<ul> <li>The <code>get_current_rate</code> method takes in two arguments:  </li> <li><code>state</code>: An instance of <code>SubpopState</code> (specifically, <code>SIHRSubpopState</code>).  </li> <li><code>params</code>: An instance of <code>SubpopParams</code> (specifically, <code>SIHRSubpopParams</code>).  </li> <li>These arguments provide easy access to parameters and the simulation state.  </li> </ul> <p>For each transition variable subclass, we must implement <code>get_current_rate</code> to return the actual current rate, which depends on the parameters and simulation state. The implementation follows the mathematical formulas we previously defined.  </p> <pre><code>class SusceptibleToInfected(clt.TransitionVariable):\n\n    def get_current_rate(self,\n                         state: SIHRSubpopState,\n                         params: SIHRSubpopParams) -&gt; np.ndarray:\n\n        return state.I * params.beta / params.total_pop_age_risk\n\n\nclass InfectedToHospitalized(clt.TransitionVariable):\n\n    def get_current_rate(self,\n                         state: SIHRSubpopState,\n                         params: SIHRSubpopParams) -&gt; np.ndarray:\n        return params.I_to_H_rate * params.I_to_H_prop\n\n\nclass HospitalizedToRecovered(clt.TransitionVariable):\n\n    def get_current_rate(self,\n                         state: SIHRSubpopState,\n                         params: SIHRSubpopParams) -&gt; np.ndarray:\n        return params.H_to_R_rate\n\n\nclass InfectedToRecovered(clt.TransitionVariable):\n\n    def get_current_rate(self,\n                         state: SIHRSubpopState,\n                         params: SIHRSubpopParams) -&gt; np.ndarray:\n\n        return params.I_to_R_rate * (1 - params.I_to_H_prop)\n</code></pre>"},{"location":"SIHR_components_walkthrough/#creating-a-subpopmodel","title":"Creating a <code>SubpopModel</code>","text":"<p>Finally, we put everything together in a <code>SubpopModel</code> :)</p> <p>We create a subclass of <code>clt.SubpopModel</code> -- here we named our subclass <code>SIHRSubpopModel.</code> We will go through each function step-by-step.</p>"},{"location":"SIHR_components_walkthrough/#customizing-the-__init__-method-in-cltsubpopmodel","title":"Customizing the <code>__init__</code> Method in <code>clt.SubpopModel</code>","text":"<p>If we examine the <code>clt.SubpopModel</code> base class, we see that its <code>__init__</code> function requires the following arguments:  </p> <ul> <li><code>state</code>: A <code>SubpopState</code> instance  </li> <li><code>params</code>: A <code>SubpopParams</code> instance  </li> <li><code>config</code>: A <code>Config</code> instance  </li> <li><code>RNG</code>: An <code>np.random.Generator</code> instance  </li> </ul>"},{"location":"SIHR_components_walkthrough/#adding-custom-functionality","title":"Adding Custom Functionality","text":"<p>For our custom model, we extend <code>__init__</code> to allow users to specify dictionaries containing model information. These dictionaries are then used to generate the necessary <code>SubpopState</code>, <code>SubpopParams</code>, and <code>Config</code> instances.  </p>"},{"location":"SIHR_components_walkthrough/#is-customizing-__init__-required","title":"Is Customizing <code>__init__</code> Required?","text":"<p>Customizing <code>__init__</code> is completely optional! - If a subclass does not define its own <code>__init__</code>, it inherits the <code>__init__</code> from its parent class.  </p>"},{"location":"SIHR_components_walkthrough/#implementation-steps","title":"Implementation Steps","text":"<ol> <li>Define an <code>__init__</code> function in our subclass.  </li> <li>Use the helper function <code>clt.make_dataclass_from_dict</code> to convert dictionaries into actual base model objects.  </li> <li>Call <code>super().__init__</code> to execute the original initialization from the parent class.  </li> </ol> <p>This approach ensures all components are properly initialized and brought together into a functional model.  </p> <pre><code>class SIHRSubpopModel(clt.SubpopModel):\n\n    def __init__(self,\n                 compartments_epi_metrics_dict: dict,\n                 params_dict: dict,\n                 config_dict: dict,\n                 RNG: np.random.Generator,\n                 name: str = \"\",\n                 wastewater_enabled: bool = False):\n        \"\"\"\n        Args:\n            compartments_epi_metrics_dict (dict):\n                holds current simulation state information,\n                such as current values of epidemiological compartments\n                and epi metrics -- keys and values respectively\n                must match field names and format of FluSubpopState.\n            params_dict (dict):\n                holds epidemiological parameter values -- keys and\n                values respectively must match field names and\n                format of FluSubpopParams.\n            config_dict (dict):\n                holds configuration values -- keys and values\n                respectively must match field names and format of\n                Config.\n            RNG (np.random.Generator):\n                numpy random generator object used to obtain\n                random numbers.\n            name (str):\n                name.\n            wastewater_enabled (bool):\n                if True, includes \"wastewater\" EpiMetric. Otherwise,\n                excludes it.\n        \"\"\"\n\n        # Assign config, params, and state to model-specific\n        # types of dataclasses that have epidemiological parameter information\n        # and sim state information\n\n        self.wastewater_enabled = wastewater_enabled\n\n        state = clt.make_dataclass_from_dict(SIHRSubpopState, compartments_epi_metrics_dict)\n        params = clt.make_dataclass_from_dict(SIHRSubpopParams, params_dict)\n        config = clt.make_dataclass_from_dict(clt.Config, config_dict)\n\n        # IMPORTANT NOTE: as always, we must be careful with mutable objects\n        #   and generally use deep copies to avoid modification of the same\n        #   object. But in this function call, using deep copies is unnecessary\n        #   (redundant) because the parent class SubpopModel's __init__()\n        #   creates deep copies.\n        super().__init__(state, params, config, RNG, name)\n</code></pre> <p>Note: all following code snippets (unless stated otherwise) are continued from the <code>SIHRSubpopModel</code> class code.</p>"},{"location":"SIHR_components_walkthrough/#implementing-abstract-methods-in-cltsubpopmodel","title":"Implementing Abstract Methods in <code>clt.SubpopModel</code>","text":"<p><code>clt.SubpopModel</code> is an abstract base class and includes multiple abstract methods that we must implement in our subclass:  </p> <ul> <li><code>create_interaction_terms</code> </li> <li><code>create_dynamic_vals</code> </li> <li><code>create_schedules</code> </li> <li><code>create_epi_metrics</code> </li> <li><code>create_compartments</code> </li> <li><code>create_transition_variables</code> </li> <li><code>create_transition_variable_groups</code> </li> </ul>"},{"location":"SIHR_components_walkthrough/#handling-interactionterm-instances","title":"Handling <code>InteractionTerm</code> Instances","text":"<p>We do not use <code>InteractionTerm</code> instances because these are designed for <code>MetapopModel</code>s that consist of multiple <code>SubpopModel</code>s. However, we still need to implement <code>create_interaction_terms</code>. - Since our model does not require interaction terms, we return an empty <code>sc.objdict</code>.  </p>"},{"location":"SIHR_components_walkthrough/#handling-other-unused-methods","title":"Handling Other Unused Methods","text":"<p>Similarly, since our model does not include dynamic values, schedules, or epidemiological metrics, we return an empty <code>sc.objdict</code> for the following methods:  </p> <ul> <li><code>create_dynamic_vals</code> </li> <li><code>create_schedules</code> </li> <li><code>create_epi_metrics</code> </li> </ul> <p>By implementing these methods in this way, we satisfy the requirements of <code>clt.SubpopModel</code> while keeping our simple model clean and functional.  </p> <pre><code>    def create_interaction_terms(self) -&gt; sc.objdict[str, clt.InteractionTerm]:\n\n        return sc.objdict()\n\n    def create_dynamic_vals(self) -&gt; sc.objdict[str, clt.DynamicVal]:\n\n        dynamic_vals = sc.objdict()\n\n        return dynamic_vals\n\n    def create_schedules(self) -&gt; sc.objdict[str, clt.Schedule]:\n\n        schedules = sc.objdict()\n\n        return schedules\n\n    def create_epi_metrics(\n            self,\n            transition_variables: sc.objdict[str, clt.TransitionVariable]) \\\n            -&gt; sc.objdict[str, clt.EpiMetric]:\n\n        epi_metrics = sc.objdict()\n\n        return epi_metrics\n</code></pre> <p>Here we create a <code>Compartment</code> instance for each compartment (\"S\", \"I\", \"H\", \"R\"). Store each instance in an <code>sc.objdict</code>, where the keys are the names (strings) of each compartment, and the values are the compartment instances themselves. Return the dictionary.</p> <pre><code>    def create_compartments(self) -&gt; sc.objdict[str, clt.Compartment]:\n\n        compartments = sc.objdict()\n\n        for name in (\"S\", \"I\", \"H\", \"R\"):\n            compartments[name] = clt.Compartment(getattr(self.state, name))\n\n        return compartments\n</code></pre>"},{"location":"SIHR_components_walkthrough/#creating-transition-variable-instances","title":"Creating Transition Variable Instances","text":"<p>For each transition (we have 4 total), create an instance of the associated <code>clt.TransitionVariable</code> subclass. To initialize each <code>TransitionVariable</code>, we need to specify the origin <code>Compartment</code>, the destination <code>Compartment</code>, and the transition type.  </p> <p>For example, for the transition between the <code>\"S\"</code> and <code>\"I\"</code> compartments, create an instance of <code>SusceptibleToInfected</code> (which we created in the code above). We need to pass the corresponding <code>Compartment</code> instances to the <code>origin</code> and <code>destination</code> arguments, in addition to specifying the <code>transition_type</code>.  </p> <pre><code>    def create_transition_variables(\n            self,\n            compartments: sc.objdict[str, clt.Compartment] = None) -&gt; sc.objdict[str, clt.TransitionVariable]:\n\n        # Grab the `transition_type` specified in `Config`\n        type = self.config.transition_type\n\n        transition_variables = sc.objdict()\n\n        S = compartments.S\n        I = compartments.I\n        H = compartments.H\n        R = compartments.R\n\n        transition_variables.S_to_I = SusceptibleToInfected(origin=S, destination=I, transition_type=type)\n        transition_variables.I_to_R = InfectedToRecovered(origin=I, destination=R, transition_type=type)\n        transition_variables.I_to_H = InfectedToHospitalized(origin=I, destination=H, transition_type=type)\n        transition_variables.H_to_R = HospitalizedToRecovered(origin=H, destination=R, transition_type=type)\n\n        return transition_variables\n</code></pre>"},{"location":"SIHR_components_walkthrough/#creating-a-transitionvariablegroup","title":"Creating a <code>TransitionVariableGroup</code>","text":"<p>When there are multiple transitions out of a single compartment, we need a <code>TransitionVariableGroup</code> to handle the jointly distributed transition logic properly.  </p> <p>In our model, the <code>\"I\"</code> compartment has two outgoing arcs: one to <code>\"H\"</code> and one to <code>\"R\"</code>.  </p> <p>We create a <code>TransitionVariableGroup</code> saved as <code>\"I_out\"</code> in the transition variable group dictionary. We need to specify:  </p> <ul> <li>The <code>Compartment</code> instance corresponding to <code>origin</code> </li> <li>The <code>transition_type</code> </li> <li>A tuple (or list) of <code>TransitionVariable</code> instances that make up this joint distribution  </li> </ul> <pre><code>    def create_transition_variable_groups(\n            self,\n            compartments: sc.objdict[str, clt.Compartment] = None,\n            transition_variables: sc.objdict[str, clt.TransitionVariable] = None)\\\n            -&gt; sc.objdict[str, clt.TransitionVariableGroup]:\n\n        transition_type = self.config.transition_type\n\n        transition_variable_groups = sc.objdict()\n\n        transition_variable_groups.I_out = clt.TransitionVariableGroup(origin=compartments.I,\n                                                                       transition_type=transition_type,\n                                                                       transition_variables=\n                                                                       (transition_variables.I_to_R,\n                                                                        transition_variables.I_to_H))\n\n        return transition_variable_groups\n</code></pre> <p>We just created a customized model! Try running <code>SIHR_demo.py</code> and playing with the results.</p>"},{"location":"clt_base_package_reference/","title":"CLT Base Package Code API Reference","text":"<p>Docstrings and references for <code>clt_base</code> package.</p>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Compartment","title":"<code>Compartment</code>","text":"<p>               Bases: <code>StateVariable</code></p> <p>Class for epidemiological compartments (e.g. Susceptible,     Exposed, Infected, etc...).</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>Attributes:</p> Name Type Description <code>current_inflow</code> <code>ndarray</code> <p>same size as <code>self.current_val</code>, used to sum up all transition variable realizations incoming to this compartment for age-risk groups.</p> <code>current_outflow</code> <code>ndarray</code> <p>same size of <code>self.current_val</code>, used to sum up all transition variable realizations outgoing from this compartment for age-risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class Compartment(StateVariable):\n    \"\"\"\n    Class for epidemiological compartments (e.g. Susceptible,\n        Exposed, Infected, etc...).\n\n    Inherits attributes from `StateVariable`.\n\n    Attributes:\n        current_inflow (np.ndarray):\n            same size as `self.current_val`, used to sum up all\n            transition variable realizations incoming to this compartment\n            for age-risk groups.\n        current_outflow (np.ndarray):\n            same size of `self.current_val`, used to sum up all\n            transition variable realizations outgoing from this compartment\n            for age-risk groups.\n    \"\"\"\n\n    def __init__(self,\n                 init_val):\n        super().__init__(np.asarray(init_val, dtype=float))\n\n        self.current_inflow = np.zeros(np.shape(init_val))\n        self.current_outflow = np.zeros(np.shape(init_val))\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Updates `self.current_val` attribute in-place by adding\n            `self.current_inflow` (sum of all incoming transition variables'\n            realizations) and subtracting current outflow (sum of all\n            outgoing transition variables' realizations).\n        \"\"\"\n        self.current_val = self.current_val + self.current_inflow - self.current_outflow\n\n    def reset_inflow(self) -&gt; None:\n        \"\"\"\n        Resets `self.current_inflow` attribute to np.ndarray of zeros.\n        \"\"\"\n        self.current_inflow = np.zeros(np.shape(self.current_inflow))\n\n    def reset_outflow(self) -&gt; None:\n        \"\"\"\n        Resets `self.current_outflow` attribute to np.ndarray of zeros.\n        \"\"\"\n        self.current_outflow = np.zeros(np.shape(self.current_outflow))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Compartment.reset_inflow","title":"<code>reset_inflow() -&gt; None</code>","text":"<p>Resets <code>self.current_inflow</code> attribute to np.ndarray of zeros.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset_inflow(self) -&gt; None:\n    \"\"\"\n    Resets `self.current_inflow` attribute to np.ndarray of zeros.\n    \"\"\"\n    self.current_inflow = np.zeros(np.shape(self.current_inflow))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Compartment.reset_outflow","title":"<code>reset_outflow() -&gt; None</code>","text":"<p>Resets <code>self.current_outflow</code> attribute to np.ndarray of zeros.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset_outflow(self) -&gt; None:\n    \"\"\"\n    Resets `self.current_outflow` attribute to np.ndarray of zeros.\n    \"\"\"\n    self.current_outflow = np.zeros(np.shape(self.current_outflow))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Compartment.update_current_val","title":"<code>update_current_val() -&gt; None</code>","text":"<p>Updates <code>self.current_val</code> attribute in-place by adding     <code>self.current_inflow</code> (sum of all incoming transition variables'     realizations) and subtracting current outflow (sum of all     outgoing transition variables' realizations).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Updates `self.current_val` attribute in-place by adding\n        `self.current_inflow` (sum of all incoming transition variables'\n        realizations) and subtracting current outflow (sum of all\n        outgoing transition variables' realizations).\n    \"\"\"\n    self.current_val = self.current_val + self.current_inflow - self.current_outflow\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Config","title":"<code>Config</code>","text":"<p>Stores simulation configuration values.</p> <p>Attributes:</p> Name Type Description <code>timesteps_per_day</code> <code>int</code> <p>number of discretized timesteps within a simulation day -- more <code>timesteps_per_day</code> mean smaller discretization time intervals, which may cause the model to run slower.</p> <code>transition_type</code> <code>str</code> <p>valid value must be from <code>TransitionTypes</code>, specifying the probability distribution of transitions between compartments.</p> <code>start_real_date</code> <code>date</code> <p>actual date that aligns with the beginning of the simulation.</p> <code>save_daily_history</code> <code>bool</code> <p>set to <code>True</code> to save <code>StateVariable</code> state to history after each simulation day -- set to <code>False</code> if want speedier performance.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"\n    Stores simulation configuration values.\n\n    Attributes:\n        timesteps_per_day (int):\n            number of discretized timesteps within a simulation\n            day -- more `timesteps_per_day` mean smaller discretization\n            time intervals, which may cause the model to run slower.\n        transition_type (str):\n            valid value must be from `TransitionTypes`, specifying\n            the probability distribution of transitions between\n            compartments.\n        start_real_date (datetime.date):\n            actual date that aligns with the beginning of the simulation.\n        save_daily_history (bool):\n            set to `True` to save `StateVariable` state to history after each\n            simulation day -- set to `False` if want speedier performance.\n    \"\"\"\n\n    timesteps_per_day: int = 7\n    transition_type: str = TransitionTypes.BINOMIAL\n    start_real_date: datetime.time = datetime.datetime.strptime(\"2024-10-31\",\n                                                                \"%Y-%m-%d\").date()\n    save_daily_history: bool = True\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.DataClassProtocol","title":"<code>DataClassProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>class DataClassProtocol(Protocol):\n    __dataclass_fields__: dict\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.DynamicVal","title":"<code>DynamicVal</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that dynamically adjust their values based the current values of other <code>StateVariable</code> instances.</p> <p>This class should model social distancing (and more broadly, staged-alert policies). For example, if we consider a case where transmission rates decrease when number infected increase above a certain level, we can create a subclass of DynamicVal that models a coefficient that modifies transmission rates, depending on the epi compartments corresponding to infected people.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class DynamicVal(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that dynamically adjust\n    their values based the current values of other `StateVariable`\n    instances.\n\n    This class should model social distancing (and more broadly,\n    staged-alert policies). For example, if we consider a\n    case where transmission rates decrease when number infected\n    increase above a certain level, we can create a subclass of\n    DynamicVal that models a coefficient that modifies transmission\n    rates, depending on the epi compartments corresponding to\n    infected people.\n\n    Inherits attributes from `StateVariable`.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 is_enabled: Optional[bool] = False):\n        \"\"\"\n\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation.\n            is_enabled (Optional[bool]):\n                if `False`, this dynamic value does not get updated\n                during the simulation and defaults to its `self.init_val`.\n                This is designed to allow easy toggling of\n                simulations with or without staged alert policies\n                and other interventions.\n        \"\"\"\n\n        super().__init__(init_val)\n        self.is_enabled = is_enabled\n\n    @abstractmethod\n    def update_current_val(self,\n                           state: SubpopState,\n                           params: SubpopParams) -&gt; None:\n        \"\"\"\n        Args:\n            state (SubpopState):\n                holds subpopulation simulation state (current values of\n                `StateVariable` instances).\n            params (SubpopParams):\n                holds values of epidemiological parameters.\n        \"\"\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.DynamicVal.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, is_enabled: Optional[bool] = False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation.</p> <code>None</code> <code>is_enabled</code> <code>Optional[bool]</code> <p>if <code>False</code>, this dynamic value does not get updated during the simulation and defaults to its <code>self.init_val</code>. This is designed to allow easy toggling of simulations with or without staged alert policies and other interventions.</p> <code>False</code> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             is_enabled: Optional[bool] = False):\n    \"\"\"\n\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation.\n        is_enabled (Optional[bool]):\n            if `False`, this dynamic value does not get updated\n            during the simulation and defaults to its `self.init_val`.\n            This is designed to allow easy toggling of\n            simulations with or without staged alert policies\n            and other interventions.\n    \"\"\"\n\n    super().__init__(init_val)\n    self.is_enabled = is_enabled\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.DynamicVal.update_current_val","title":"<code>update_current_val(state: SubpopState, params: SubpopParams) -&gt; None</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds subpopulation simulation state (current values of <code>StateVariable</code> instances).</p> required <code>params</code> <code>SubpopParams</code> <p>holds values of epidemiological parameters.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self,\n                       state: SubpopState,\n                       params: SubpopParams) -&gt; None:\n    \"\"\"\n    Args:\n        state (SubpopState):\n            holds subpopulation simulation state (current values of\n            `StateVariable` instances).\n        params (SubpopParams):\n            holds values of epidemiological parameters.\n    \"\"\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.EpiMetric","title":"<code>EpiMetric</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for epi metrics in epidemiological model.</p> <p>This is intended for variables that are aggregate deterministic functions of the <code>SubpopState</code> (including <code>Compartment</code> <code>current_val</code>'s, other parameters, and time.)</p> <p>For example, population-level immunity variables should be modeled as a <code>EpiMetric</code> subclass, with a concrete implementation of the abstract method <code>self.get_change_in_current_val</code>.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>Attributes:</p> Name Type Description <code>current_val</code> <code>ndarray</code> <p>same size as init_val, holds current value of <code>StateVariable</code> for age-risk groups.</p> <code>change_in_current_val</code> <p>(np.ndarray): initialized to None, but during simulation holds change in current value of <code>EpiMetric</code> for age-risk groups (size |A| x |R|, where |A| is the number of risk groups and |R| is number of age groups).</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class EpiMetric(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for epi metrics in epidemiological model.\n\n    This is intended for variables that are aggregate deterministic functions of\n    the `SubpopState` (including `Compartment` `current_val`'s, other parameters,\n    and time.)\n\n    For example, population-level immunity variables should be\n    modeled as a `EpiMetric` subclass, with a concrete\n    implementation of the abstract method `self.get_change_in_current_val`.\n\n    Inherits attributes from `StateVariable`.\n\n    Attributes:\n        current_val (np.ndarray):\n            same size as init_val, holds current value of `StateVariable`\n            for age-risk groups.\n        change_in_current_val : (np.ndarray):\n            initialized to None, but during simulation holds change in\n            current value of `EpiMetric` for age-risk groups\n            (size |A| x |R|, where |A| is the number of risk groups and |R| is number\n            of age groups).\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val):\n        \"\"\"\n        Args:\n            init_val (np.ndarray):\n                2D array that contains nonnegative floats,\n                corresponding to initial value of dynamic val,\n                where i,jth entry corresponds to age group i and\n                risk group j.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.change_in_current_val = None\n\n    @abstractmethod\n    def get_change_in_current_val(self,\n                                  state: SubpopState,\n                                  params: SubpopParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns change in current value of dynamic val,\n        based on current state of the simulation and epidemiological parameters.\n\n        NOTE:\n            OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n\n        Output should be a numpy array of size |A| x |R|, where A\n        is number of age groups and |R| is number of risk groups.\n\n        Args:\n            state (SubpopState):\n                holds subpopulation simulation state (current values of\n                `StateVariable` instances).\n            params (SubpopParams):\n                holds values of epidemiological parameters.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size |A| x |R|, where |A| is the number of age groups and\n                |R| is number of risk groups.\n        \"\"\"\n        pass\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Adds `self.change_in_current_val` attribute to\n            `self.current_val` attribute in-place.\n        \"\"\"\n\n        self.current_val += self.change_in_current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.EpiMetric.__init__","title":"<code>__init__(init_val)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>ndarray</code> <p>2D array that contains nonnegative floats, corresponding to initial value of dynamic val, where i,jth entry corresponds to age group i and risk group j.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             init_val):\n    \"\"\"\n    Args:\n        init_val (np.ndarray):\n            2D array that contains nonnegative floats,\n            corresponding to initial value of dynamic val,\n            where i,jth entry corresponds to age group i and\n            risk group j.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.change_in_current_val = None\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.EpiMetric.get_change_in_current_val","title":"<code>get_change_in_current_val(state: SubpopState, params: SubpopParams, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Computes and returns change in current value of dynamic val, based on current state of the simulation and epidemiological parameters.</p> NOTE <p>OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.</p> <p>Output should be a numpy array of size |A| x |R|, where A is number of age groups and |R| is number of risk groups.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds subpopulation simulation state (current values of <code>StateVariable</code> instances).</p> required <code>params</code> <code>SubpopParams</code> <p>holds values of epidemiological parameters.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size |A| x |R|, where |A| is the number of age groups and |R| is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@abstractmethod\ndef get_change_in_current_val(self,\n                              state: SubpopState,\n                              params: SubpopParams,\n                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns change in current value of dynamic val,\n    based on current state of the simulation and epidemiological parameters.\n\n    NOTE:\n        OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n\n    Output should be a numpy array of size |A| x |R|, where A\n    is number of age groups and |R| is number of risk groups.\n\n    Args:\n        state (SubpopState):\n            holds subpopulation simulation state (current values of\n            `StateVariable` instances).\n        params (SubpopParams):\n            holds values of epidemiological parameters.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size |A| x |R|, where |A| is the number of age groups and\n            |R| is number of risk groups.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.EpiMetric.update_current_val","title":"<code>update_current_val() -&gt; None</code>","text":"<p>Adds <code>self.change_in_current_val</code> attribute to     <code>self.current_val</code> attribute in-place.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Adds `self.change_in_current_val` attribute to\n        `self.current_val` attribute in-place.\n    \"\"\"\n\n    self.current_val += self.change_in_current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment","title":"<code>Experiment</code>","text":"<p>Class to manage running multiple simulation replications on a <code>SubpopModel</code> or <code>MetapopModel</code> instance and query its results.</p> <p>Also allows running a batch of simulation replications on a deterministic sequence of values for a given input (for example, to see how output changes as a function of a given input).</p> <p>Also handles random sampling of inputs from a uniform distribution.</p> NOTE <p>If an input is an |A| x |R| array (for age-risk), the current functionality does not support sampling individual age-risk elements separately. Instead, a single scalar value is sampled at a time for the entire input. See <code>self.sample_random_inputs</code> method for more details.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_subpop_models</code> <code>tuple</code> <p>tuple of <code>SubpopModel</code> instances associated with the <code>Experiment</code>. If the <code>Experiment</code> is for a <code>MetapopModel</code>, then this tuple contains all the associated <code>SubpopModel</code> instances that comprise that <code>MetapopModel.</code> If the <code>Experiment</code> is for a <code>SubpopModel</code> only, then this tuple contains only that particular <code>SubpopModel</code>.</p> required <code>inputs_realizations</code> <code>dict</code> <p>dictionary of dictionaries that stores user-specified deterministic sequences for inputs or realizations of random input sampling -- keys are <code>SubpopModel</code> names, values are dictionaries. These second-layer dictionaries' keys are strings corresponding to input names (they must match names in each <code>SubpopModel</code>'s <code>SubpopParams</code> to be valid) and values are list-like, where the ith element corresponds to the ith random sample for that input.</p> required <code>results_df</code> <code>DataFrame</code> <p>DataFrame holding simulation results from each <code>simulation</code> replication</p> required <code>has_been_run</code> <code>bool</code> <p>indicates if <code>self.run_static_inputs</code>, <code>self.run_random_inputs</code>, or <code>self.run_sequences_of_inputs</code> has been executed.</p> required <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>class Experiment:\n    \"\"\"\n    Class to manage running multiple simulation replications\n    on a `SubpopModel` or `MetapopModel` instance and query its results.\n\n    Also allows running a batch of simulation replications on a\n    deterministic sequence of values for a given input\n    (for example, to see how output changes as a function of\n    a given input).\n\n    Also handles random sampling of inputs from a uniform\n    distribution.\n\n    NOTE:\n        If an input is an |A| x |R| array (for age-risk),\n        the current functionality does not support sampling individual\n        age-risk elements separately. Instead, a single scalar value\n        is sampled at a time for the entire input.\n        See `self.sample_random_inputs` method for more details.\n\n    Params:\n        experiment_subpop_models (tuple):\n            tuple of `SubpopModel` instances associated with the `Experiment`.\n            If the `Experiment` is for a `MetapopModel`, then this tuple\n            contains all the associated `SubpopModel` instances\n            that comprise that `MetapopModel.` If the `Experiment` is for\n            a `SubpopModel` only, then this tuple contains only that\n            particular `SubpopModel`.\n        inputs_realizations (dict):\n            dictionary of dictionaries that stores user-specified deterministic\n            sequences for inputs or realizations of random input sampling --\n            keys are `SubpopModel` names, values are dictionaries.\n            These second-layer dictionaries' keys are strings corresponding\n            to input names (they must match names in each `SubpopModel`'s\n            `SubpopParams` to be valid) and values are list-like, where the ith\n            element corresponds to the ith random sample for that input.\n        results_df (pd.DataFrame):\n            DataFrame holding simulation results from each\n            `simulation` replication\n        has_been_run (bool):\n            indicates if `self.run_static_inputs`, `self.run_random_inputs`,\n            or `self.run_sequences_of_inputs` has been executed.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 model: SubpopModel | MetapopModel,\n                 state_variables_to_record: list,\n                 database_filename: str):\n\n        \"\"\"\n        Params:\n            model (SubpopModel | MetapopModel):\n                SubpopModel or MetapopModel instance on which to\n                run multiple replications.\n            state_variables_to_record (list[str]):\n                list or list-like of strings corresponding to\n                state variables to record -- each string must match\n                a state variable name on each SubpopModel in\n                the MetapopModel.\n            database_filename (str):\n                must be valid filename with suffix \".db\" --\n                experiment results are saved to this SQL database\n        \"\"\"\n\n        self.model = model\n        self.state_variables_to_record = state_variables_to_record\n        self.database_filename = database_filename\n\n        self.has_been_run = False\n\n        # Create experiment_subpop_models tuple\n        # If model is MetapopModel instance, then this tuple is a list\n        #   of all associated SubpopModel instances\n        # If model is a SubpopModel instance, then this tuple\n        #   only contains that SubpopModel.\n        if isinstance(model, MetapopModel):\n            experiment_subpop_models = tuple(model.subpop_models.values())\n        elif isinstance(model, SubpopModel):\n            experiment_subpop_models = (model,)\n        else:\n            raise ExperimentError(\"\\\"model\\\" argument must be an instance of SubpopModel \"\n                                  \"or MetapopModel class.\")\n        self.experiment_subpop_models = experiment_subpop_models\n\n        # Initialize results_df attribute -- this will store\n        #   results of experiment run\n        self.results_df = None\n\n        # User-specified deterministic sequences for inputs or randomly\n        #   sampled inputs' realizations are stored in this dictionary\n        self.inputs_realizations = {}\n\n        for subpop_model in self.experiment_subpop_models:\n            self.inputs_realizations[subpop_model.name] = {}\n\n            # Make sure the state variables to record are valid -- the names\n            #   of the state variables to record must match actual state variables\n            #   on each SubpopModel\n            if not check_is_subset_list(state_variables_to_record,\n                                        subpop_model.all_state_variables.keys()):\n                raise ExperimentError(\n                    f\"\\\"state_variables_to_record\\\" list is not a subset \"\n                    \"of the state variables on SubpopModel \\\"{subpop_name}\\\" -- \"\n                    \"modify \\\"state_variables_to_record\\\" and re-initialize experiment.\")\n\n    def run_static_inputs(self,\n                          num_reps: int,\n                          simulation_end_day: int,\n                          days_between_save_history: int = 1,\n                          results_filename: str = None):\n        \"\"\"\n        Runs the associated `SubpopModel` or `MetapopModel` for a\n        given number of independent replications until `simulation_end_day`.\n        Parameter values and initial values are the same across\n        simulation replications. User can specify how often to save the\n        history and a CSV file in which to store this history.\n\n        Params:\n            num_reps (positive int):\n                number of independent simulation replications\n                to run in an experiment.\n            simulation_end_day (positive int):\n                stop simulation at simulation_end_day (i.e. exclusive,\n                simulate up to but not including simulation_end_day).\n            days_between_save_history (positive int):\n                indicates how often to save simulation results.\n            results_filename (str):\n                if specified, must be valid filename with suffix \".csv\" --\n                experiment results are saved to this CSV file.\n        \"\"\"\n\n        if self.has_been_run:\n            raise ExperimentError(\"Experiment has already been run. \"\n                                  \"Create a new Experiment instance to simulate \"\n                                  \"more replications.\")\n\n        else:\n            self.has_been_run = True\n\n            self.create_results_sql_table()\n\n            self.simulate_reps_and_save_results(reps=num_reps,\n                                                end_day=simulation_end_day,\n                                                days_per_save=days_between_save_history,\n                                                inputs_are_static=True,\n                                                filename=results_filename)\n\n    def run_random_inputs(self,\n                          num_reps: int,\n                          simulation_end_day: int,\n                          random_inputs_RNG: np.random.Generator,\n                          random_inputs_spec: dict,\n                          days_between_save_history: int = 1,\n                          results_filename: str = None,\n                          inputs_filename_suffix: str = None):\n        \"\"\"\n        Runs the associated `SubpopModel` or `MetapopModel` for a\n        given number of independent replications until `simulation_end_day`,\n        where certain parameter values or initial values are\n        independently randomly sampled for each replication.\n        Random sampling details (which inputs to sample and what\n        Uniform distribution lower and upper bounds to use for each input)\n        are specified in `random_inputs_spec`, and random sampling of inputs\n        uses `random_inputs_RNG`. User can specify how often to save the\n        history and a CSV file in which to store this history.\n        User can also specify a filename suffix to name CSV files\n        in which to store realizations of inputs.\n\n        Params:\n            num_reps (positive int):\n                number of independent simulation replications\n                to run in an experiment.\n            simulation_end_day (positive int):\n                stop simulation at simulation_end_day (i.e. exclusive,\n                simulate up to but not including simulation_end_day).\n            random_inputs_RNG (np.random.Generator):\n                random number generator used to sample random\n                inputs -- for reproducibility, it is recommended to\n                use a distinct RNG for sampling random inputs different\n                from the RNG for simulating the experiment/model.\n            random_inputs_spec (dict):\n                random inputs' specification -- stores details\n                for random input sampling -- keys are strings\n                corresponding to input names (they must match\n                names in each `SubpopModel`'s `SubpopParams` or associated\n                `EpiMetric` or `Compartment` instances to be valid)\n                and values are 2-tuples of nonnegative floats corresponding\n                to lower and upper bounds for sampling that input from a\n                uniform distribution.\n            days_between_save_history (positive int):\n                indicates how often to save simulation results.\n            results_filename (str):\n                if specified, must be valid filename with suffix \".csv\" --\n                experiment results are saved to this CSV file\n            inputs_filename_suffix (str):\n                if specified, must be a valid filename with suffix \".csv\" --\n                one inputs CSV is generated for each `SubpopModel` with the\n                filename \"{name}_{inputs_filename}\" where name is the name\n                of the `SubpopModel` -- saves the values of each parameter that\n                varies between replications\n        \"\"\"\n\n        if self.has_been_run:\n            raise ExperimentError(\"Experiment has already been run. \"\n                                  \"Create a new Experiment instance to simulate \"\n                                  \"more replications.\")\n\n        else:\n            self.has_been_run = True\n\n            self.sample_random_inputs(num_reps,\n                                      random_inputs_RNG,\n                                      random_inputs_spec)\n\n            self.create_results_sql_table()\n            self.create_inputs_realizations_sql_tables()\n\n            self.simulate_reps_and_save_results(reps=num_reps,\n                                                end_day=simulation_end_day,\n                                                days_per_save=days_between_save_history,\n                                                inputs_are_static=False,\n                                                filename=results_filename)\n\n            if inputs_filename_suffix:\n                self.write_inputs_csvs(inputs_filename_suffix)\n\n    def run_sequences_of_inputs(self,\n                                num_reps: int,\n                                simulation_end_day: int,\n                                sequences_of_inputs: dict,\n                                days_between_save_history: int = 1,\n                                results_filename: str = None,\n                                inputs_filename_suffix: str = None):\n        \"\"\"\n        Runs the associated `SubpopModel` or `MetapopModel` for a\n        given number of independent replications until `simulation_end_day`,\n        where certain parameter values or initial values deterministically\n        change between replications, according to `sequences_of_inputs`.\n        User can specify how often to save the history and a CSV file\n        in which to store this history. User can also specify a filename\n        suffix to name CSV files in which to store sequences of inputs.\n\n        Params:\n            num_reps (positive int):\n                number of independent simulation replications\n                to run in an experiment.\n            simulation_end_day (positive int):\n                stop simulation at `simulation_end_day` (i.e. exclusive,\n                simulate up to but not including `simulation_end_day`).\n            sequences_of_inputs (dict):\n                dictionary of dictionaries that stores user-specified deterministic\n                sequences for inputs -- must follow specific structure.\n                Keys are `SubpopModel` names, values are dictionaries.\n                These second-layer dictionaries' keys are strings corresponding\n                to input names (they must match names in each `SubpopModel`'s\n                `SubpopParams` to be valid) and values are list-like, where the ith\n                element corresponds to the ith random sample for that input.\n            days_between_save_history (positive int):\n                indicates how often to save simulation results.\n            results_filename (str):\n                if specified, must be valid filename with suffix \".csv\" --\n                experiment results are saved to this CSV file\n            inputs_filename_suffix (str):\n                if specified, must be a valid filename with suffix \".csv\" --\n                one inputs CSV is generated for each `SubpopModel` with the\n                filename \"{name}_{inputs_filename}\" where name is the name\n                of the `SubpopModel` -- saves the values of each parameter that\n                varies between replications\n        \"\"\"\n\n        if self.has_been_run:\n            raise ExperimentError(\"Experiment has already been run. \"\n                                  \"Create a new Experiment instance to simulate \"\n                                  \"more replications.\")\n\n        else:\n            self.has_been_run = True\n\n            self.inputs_realizations = sequences_of_inputs\n\n            self.create_results_sql_table()\n            self.create_inputs_realizations_sql_tables()\n\n            self.simulate_reps_and_save_results(reps=num_reps,\n                                                end_day=simulation_end_day,\n                                                days_per_save=days_between_save_history,\n                                                inputs_are_static=False,\n                                                filename=results_filename)\n\n            if inputs_filename_suffix:\n                self.write_inputs_csvs(inputs_filename_suffix)\n\n    def sample_random_inputs(self,\n                             total_reps: int,\n                             RNG: np.random.Generator,\n                             spec: dict):\n        \"\"\"\n        Randomly and independently samples inputs specified by keys of\n        `spec` according to uniform distribution with lower\n        and upper bounds specified by values of `spec`.\n        Stores random realizations in `self.inputs_realizations` attribute.\n        Uses `RNG` to sample inputs.\n\n        Params:\n            total_reps (positive int):\n                number of independent simulation replications\n                to run in an experiment -- corresponds to number of\n                Uniform random variables to draw for each\n                state variable.\n            RNG (np.random.Generator):\n                random number generator used to sample random\n                inputs -- for reproducibility, it is recommended to\n                use a distinct RNG for sampling random inputs different\n                from the RNG for simulating the experiment/model.\n            spec (dict):\n                random inputs' specification -- stores details\n                for random input sampling -- keys are strings\n                corresponding to input names (they must match\n                names in each `SubpopModel`'s `SubpopParams` or associated\n                `EpiMetric` or `Compartment` instances to be valid)\n                and values are 2-tuples of nonnegative floats corresponding\n                to lower and upper bounds for sampling that input from a\n                uniform distribution.\n\n        NOTE:\n            If an input is an |A| x |R| array (for age-risk),\n            the current functionality does not support sampling individual\n            age-risk elements separately. Instead, a single scalar value\n            is sampled at a time for the entire input. Consequently,\n            if an |A| x |R| input is chosen to be randomly sampled,\n            all its elements will have the same sampled value.\n\n            If a user wants to sample some age-risk elements separately,\n            they should create new inputs for these elements. \"Inputs\"\n            refers to both parameters (in `SubpopParams`) and initial values\n            of `Compartment` and `EpiMetric` instances. For example, if the model\n            has a parameter `H_to_R_rate` that is 2x1 (2 age groups, 1 risk group)\n            and the user wants to sample each element separately, they should create\n            two parameters: `H_to_R_rate_age_group_1` and `H_to_R_rate_age_group_2.`\n            These should be added to the relevant `SubpopParams` instance and\n            input dictionary/file used to create the `SubpopParams` instance.\n            The user can then specify both parameters to be randomly sampled\n            and specify the lower and upper bounds accordingly.\n\n            TODO: allow sampling individual age-risk elements separately\n            without creating new parameters for each element.\n\n            (Developer note: the difficulty is not with randomly sampling\n            arrays, but rather storing arrays in SQL -- SQL tables only\n            support atomic values.)\n        \"\"\"\n\n        inputs_realizations = self.inputs_realizations\n\n        for subpop_model in self.experiment_subpop_models:\n\n            subpop_name = subpop_model.name\n\n            compartments_names_list = list(subpop_model.compartments.keys())\n            epi_metrics_names_list = list(subpop_model.epi_metrics.keys())\n            params_names_list = [field.name for field in fields(subpop_model.params)]\n\n            if not check_is_subset_list(spec[subpop_name],\n                                        compartments_names_list + epi_metrics_names_list + params_names_list):\n                raise (f\"\\\"random_inputs_spec[\\\"{subpop_name}\\\"]\\\" keys are not a subset \"\n                       \"of the state variables and parameters on SubpopModel \\\"{subpop_name}\\\" -- \"\n                       \"modify \\\"random_inputs_spec\\\" and re-initialize experiment.\")\n\n            for state_var_name, bounds in spec[subpop_name].items():\n                lower_bd = bounds[0]\n                upper_bd = bounds[1]\n                inputs_realizations[subpop_name][state_var_name] = \\\n                    RNG.uniform(low=lower_bd,\n                                high=upper_bd,\n                                size=total_reps)\n\n    def get_state_var_df(self,\n                         state_var_name: str,\n                         subpop_name: str = None,\n                         age_group: int = None,\n                         risk_group: int = None,\n                         results_filename: str = None) -&gt; pd.DataFrame:\n        \"\"\"\n        Get pandas DataFrame of recorded values of `StateVariable` given by\n        `state_var_name`, in the `SubpopModel` given by `subpop_name`,\n        for the age-risk group given by `age_group` and `risk_group`.\n        If `subpop_name` is not specified, then values are summed across all\n        associated subpopulations. Similarly, if `age_group` (or `risk_group`)\n        is not specified, then values are summed across all age groups\n        (or risk groups).\n\n        Args:\n            state_var_name (str):\n                Name of the `StateVariable` to retrieve.\n            subpop_name (Optional[str]):\n                The name of the `SubpopModel` for filtering. If None, values are\n                summed across all `SubpopModel` instances.\n            age_group (Optional[int]):\n                The age group to select. If None, values are summed across\n                all age groups.\n            risk_group (Optional[int]):\n                The risk group to select. If None, values are summed across\n                all risk groups.\n            results_filename (Optional[str]):\n                If provided, saves the resulting DataFrame as a CSV.\n\n        Returns:\n            A pandas DataFrame where rows represent the replication and columns indicate the\n            simulation day (timepoint) of recording. DataFrame values are the `StateVariable`'s\n            current_val or the sum of the `StateVariable`'s current_val across subpopulations,\n            age groups, or risk groups (the combination of what is summed over is\n            specified by the user -- details are in the part of this docstring describing\n            this function's parameters).\n        \"\"\"\n\n        if state_var_name not in self.state_variables_to_record:\n            raise ExperimentError(\"\\\"state_var_name\\\" is not in \\\"self.state_variables_to_record\\\" --\"\n                                  \"function call is invalid.\")\n\n        conn = sqlite3.connect(self.database_filename)\n\n        # Query all results table entries where state_var_name matches\n        # This will return results across all subpopulations, age groups,\n        #   and risk groups\n        df = get_sql_table_as_df(conn,\n                                 \"SELECT * FROM results WHERE state_var_name = ?\",\n                                 chunk_size=int(1e4),\n                                 sql_query_params=(state_var_name,))\n\n        conn.close()\n\n        # Define filter conditions\n        filters = {\n            \"subpop_name\": subpop_name,\n            \"age_group\": age_group,\n            \"risk_group\": risk_group\n        }\n\n        # Filter DataFrame based on user-specified conditions\n        #   (for example, if user specifies subpop_name, return subset of\n        #   DataFrame where subpop_name matches)\n        conditions = [(df[col] == value) for col, value in filters.items() if value is not None]\n        df_filtered = df if not conditions else df[np.logical_and.reduce(conditions)]\n\n        # Group DataFrame based on unique combinations of \"rep\" and \"timepoint\" columns\n        # Then sum (numeric values only), return the \"value\" column, and reset the index\n        #   so that \"rep\" and \"timepoint\" become regular columns and are not the index\n        df_aggregated = \\\n            df_filtered.groupby([\"rep\",\n                                 \"timepoint\"]).sum(numeric_only=True)[\"value\"].reset_index()\n\n        # breakpoint()\n\n        # Use pivot() function to reshape the DataFrame for its final form\n        # The \"timepoint\" values are spread across new columns\n        #   (creating a column for each unique timepoint).\n        # The \"value\" column populates the corresponding cells.\n        df_final = df_aggregated.pivot(index=\"rep\",\n                                       columns=\"timepoint\",\n                                       values=\"value\")\n\n        if results_filename:\n            df_final.to_csv(results_filename)\n\n        return df_final\n\n    def log_current_vals_to_sql(self,\n                                rep_counter: int,\n                                experiment_cursor: sqlite3.Cursor) -&gt; None:\n        \"\"\"\n        For each subpopulation and state variable to record\n        associated with this `Experiment`, save current values to\n        \"results\" table in SQL database specified by `experiment_cursor`.\n\n        Params:\n            rep_counter (int):\n                Current replication ID.\n            experiment_cursor (sqlite3.Cursor):\n                Cursor object connected to the database\n                where results should be inserted.\n        \"\"\"\n\n        for subpop_model in self.experiment_subpop_models:\n            for state_var_name in self.state_variables_to_record:\n                data = format_current_val_for_sql(subpop_model,\n                                                  state_var_name,\n                                                  rep_counter)\n                experiment_cursor.executemany(\n                    \"INSERT INTO results VALUES (?, ?, ?, ?, ?, ?, ?)\", data)\n\n    def log_inputs_to_sql(self,\n                          experiment_cursor: sqlite3.Cursor):\n        \"\"\"\n        For each subpopulation, add a new table to SQL\n        database specified by `experiment_cursor`. Each table\n        contains information on inputs that vary across\n        replications (either due to random sampling or\n        user-specified deterministic sequence). Each table\n        contains inputs information from `Experiment` attribute\n        `self.inputs_realizations` for a given subpopulation.\n\n        Params:\n            experiment_cursor (sqlite3.Cursor):\n                Cursor object connected to the database\n                where results should be inserted.\n        \"\"\"\n\n        for subpop_model in self.experiment_subpop_models:\n            table_name = f'\"{subpop_model.name}_inputs\"'\n\n            # Get the column names (dynamically, based on table)\n            experiment_cursor.execute(f\"PRAGMA table_info({table_name})\")\n\n            # Extract column names from the table info\n            # But exclude the column name \"rep\"\n            columns_info = experiment_cursor.fetchall()\n            column_names = [col[1] for col in columns_info if col[1] != \"rep\"]\n\n            # Create a placeholder string for the dynamic query\n            placeholders = \", \".join([\"?\" for _ in column_names])  # Number of placeholders matches number of columns\n\n            # Create the dynamic INSERT statement\n            sql_statement = f\"INSERT INTO {table_name} ({', '.join(column_names)}) VALUES ({placeholders})\"\n\n            # Create list of lists -- each nested list contains a sequence of values\n            #   for that particular input\n            subpop_inputs_realizations = self.inputs_realizations[subpop_model.name]\n            inputs_vals_over_reps_list = \\\n                [np.array(subpop_inputs_realizations[input_name]).reshape(-1,1) for input_name in column_names]\n            inputs_vals_over_reps_list = np.hstack(inputs_vals_over_reps_list)\n\n            experiment_cursor.executemany(sql_statement, inputs_vals_over_reps_list)\n\n    def apply_inputs_to_model(self,\n                              rep_counter: int):\n        \"\"\"\n        Changes inputs (parameters or initial values) for a given\n        replication according to `self.inputs_realizations` attribute.\n\n        Specifically, for each subpopulation, this function retrieves\n        the corresponding values from `self.inputs_realizations` and applies them to either:\n        (a) the subpopulation's `StateVariable`, if the input corresponds to a state variable,\n        or (b) the subpopulation's `params` attribute, if the input corresponds to a model\n        parameter. If the parameter or state variable is multidimensional\n        (e.g., varies across age or risk groups), it is assigned a numpy array of\n        the appropriate shape with the replicated input value.\n\n        Params:\n            rep_counter (int):\n                Replication ID, used to retrieve the correct\n                realizations of inputs for the current run.\n        \"\"\"\n\n        for subpop_model in self.experiment_subpop_models:\n\n            params = subpop_model.params\n\n            for input_name, input_val in self.inputs_realizations[subpop_model.name].items():\n\n                dimensions = (params.num_age_groups, params.num_risk_groups)\n\n                if input_name in subpop_model.all_state_variables.keys():\n                    subpop_model.all_state_variables[input_name].current_val = np.full(dimensions,\n                                                                                       input_val[rep_counter])\n                else:\n                    if np.isscalar(getattr(subpop_model.params, input_name)):\n                        setattr(subpop_model.params, input_name, input_val[rep_counter])\n                    else:\n                        setattr(subpop_model.params, input_name, np.full(dimensions, input_val[rep_counter]))\n\n    def simulate_reps_and_save_results(self,\n                                       reps: int,\n                                       end_day: int,\n                                       days_per_save: int,\n                                       inputs_are_static: bool,\n                                       filename: str = None):\n        \"\"\"\n        Helper function that executes main loop over\n        replications in `Experiment` and saves results.\n\n        Params:\n            reps (int):\n                number of independent simulation replications\n                to run in an experiment.\n            end_day (int):\n                stop simulation at end_day (i.e. exclusive,\n                simulate up to but not including end_day).\n            days_per_save (int):\n                indicates how often to save simulation results.\n            inputs_are_static (bool):\n                indicates if inputs are same across replications.\n            filename (str):\n                if specified, must be valid filename with suffix \".csv\" --\n                experiment results are saved to this CSV file.\n        \"\"\"\n\n        # Override each subpop config's save_daily_history attribute --\n        #   set it to False -- because we will manually save history\n        #   to results database according to user-defined\n        #   days_between_save_history for all subpops\n        for subpop_model in self.experiment_subpop_models:\n            subpop_model.config.save_daily_history = False\n\n        model = self.model\n\n        # Connect to SQL database\n        conn = sqlite3.connect(self.database_filename)\n        cursor = conn.cursor()\n\n        # Loop through replications\n        for rep in range(reps):\n\n            # Reset model and clear its history\n            model.reset_simulation()\n\n            # Apply new values of inputs, if some\n            #   inputs change between replications\n            if not inputs_are_static:\n                self.apply_inputs_to_model(rep)\n                self.log_inputs_to_sql(cursor)\n\n            # Simulate model and save results every `days_per_save` days\n            while model.current_simulation_day &lt; end_day:\n                model.simulate_until_day(min(model.current_simulation_day + days_per_save,\n                                             end_day))\n\n                self.log_current_vals_to_sql(rep, cursor)\n\n        self.results_df = get_sql_table_as_df(conn, \"SELECT * FROM results\", chunk_size=int(1e4))\n\n        if filename:\n            self.results_df.to_csv(filename)\n\n        # Commit changes to database and close\n        conn.commit()\n        conn.close()\n\n    def create_results_sql_table(self):\n        \"\"\"\n        Create SQL database and save to `self.database_filename`.\n        Create table named `results` with columns `subpop_name`,\n        `state_var_name`, `age_group`, `risk_group`, `rep`, `timepoint`,\n        and `value` to store results from each replication of experiment.\n        \"\"\"\n\n        # Make sure user is not overwriting database\n        if os.path.exists(self.database_filename):\n            raise ExperimentError(\"Database already exists! Overwriting is not allowed. \"\n                                  \"Delete existing .db file or change database_filename \"\n                                  \"attribute.\")\n\n        # Connect to the SQLite database and create database\n        # Create a cursor object to execute SQL commands\n        # Initialize a table with columns given by column_names\n        # Commit changes and close the connection\n        conn = sqlite3.connect(self.database_filename)\n        cursor = conn.cursor()\n        cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS results (\n            subpop_name TEXT,\n            state_var_name TEXT,\n            age_group INT,\n            risk_group INT,\n            rep INT,\n            timepoint INT,\n            value FLOAT,\n            PRIMARY KEY (subpop_name, state_var_name, age_group, risk_group, rep, timepoint)\n        )\n        \"\"\")\n        conn.commit()\n        conn.close()\n\n    def create_inputs_realizations_sql_tables(self):\n        \"\"\"\n        Create tables in SQL database given by `self.database_filename`\n        to store realizations of inputs that change across\n        replications. There is one table per associated subpopulation.\n        \"\"\"\n\n        conn = sqlite3.connect(self.database_filename)\n        cursor = conn.cursor()\n\n        for subpop_name in self.inputs_realizations.keys():\n            table_name = f'\"{subpop_name}_inputs\"'\n\n            column_names = self.inputs_realizations[subpop_name].keys()\n\n            # Construct the column definitions dynamically\n            column_definitions = \", \".join([f'\"{col}\" FLOAT' for col in column_names])\n\n            # SQL statement to create table\n            # Each table has a column called \"rep\" which is the primary\n            #   key and automatically increments every time a row is added\n            sql_statement = f\"\"\"\n            CREATE TABLE IF NOT EXISTS {table_name} (\n                rep INTEGER PRIMARY KEY AUTOINCREMENT,\n                {column_definitions}\n            )\n            \"\"\"\n\n            cursor.execute(sql_statement)\n\n        conn.commit()\n        conn.close()\n\n    def write_inputs_csvs(self,\n                          suffix: str):\n        \"\"\"\n        For each subpopulation, writes a CSV (with a filename\n        based on provided suffix) containing values of inputs\n        across replications.\n\n        Params:\n            suffix (str):\n                Common suffix used to generate CSV filenames.\n        \"\"\"\n\n        for subpop_model in self.experiment_subpop_models:\n            conn = sqlite3.connect(self.database_filename)\n\n            table_name = f\"{subpop_model.name}_inputs\"\n\n            subpop_inputs_df = get_sql_table_as_df(conn, f\"SELECT * FROM {table_name}\", chunk_size=int(1e4))\n\n            subpop_inputs_df.to_csv(f\"{subpop_model.name}_{suffix}\", index=False)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.__init__","title":"<code>__init__(model: SubpopModel | MetapopModel, state_variables_to_record: list, database_filename: str)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>model</code> <code>SubpopModel | MetapopModel</code> <p>SubpopModel or MetapopModel instance on which to run multiple replications.</p> required <code>state_variables_to_record</code> <code>list[str]</code> <p>list or list-like of strings corresponding to state variables to record -- each string must match a state variable name on each SubpopModel in the MetapopModel.</p> required <code>database_filename</code> <code>str</code> <p>must be valid filename with suffix \".db\" -- experiment results are saved to this SQL database</p> required Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def __init__(self,\n             model: SubpopModel | MetapopModel,\n             state_variables_to_record: list,\n             database_filename: str):\n\n    \"\"\"\n    Params:\n        model (SubpopModel | MetapopModel):\n            SubpopModel or MetapopModel instance on which to\n            run multiple replications.\n        state_variables_to_record (list[str]):\n            list or list-like of strings corresponding to\n            state variables to record -- each string must match\n            a state variable name on each SubpopModel in\n            the MetapopModel.\n        database_filename (str):\n            must be valid filename with suffix \".db\" --\n            experiment results are saved to this SQL database\n    \"\"\"\n\n    self.model = model\n    self.state_variables_to_record = state_variables_to_record\n    self.database_filename = database_filename\n\n    self.has_been_run = False\n\n    # Create experiment_subpop_models tuple\n    # If model is MetapopModel instance, then this tuple is a list\n    #   of all associated SubpopModel instances\n    # If model is a SubpopModel instance, then this tuple\n    #   only contains that SubpopModel.\n    if isinstance(model, MetapopModel):\n        experiment_subpop_models = tuple(model.subpop_models.values())\n    elif isinstance(model, SubpopModel):\n        experiment_subpop_models = (model,)\n    else:\n        raise ExperimentError(\"\\\"model\\\" argument must be an instance of SubpopModel \"\n                              \"or MetapopModel class.\")\n    self.experiment_subpop_models = experiment_subpop_models\n\n    # Initialize results_df attribute -- this will store\n    #   results of experiment run\n    self.results_df = None\n\n    # User-specified deterministic sequences for inputs or randomly\n    #   sampled inputs' realizations are stored in this dictionary\n    self.inputs_realizations = {}\n\n    for subpop_model in self.experiment_subpop_models:\n        self.inputs_realizations[subpop_model.name] = {}\n\n        # Make sure the state variables to record are valid -- the names\n        #   of the state variables to record must match actual state variables\n        #   on each SubpopModel\n        if not check_is_subset_list(state_variables_to_record,\n                                    subpop_model.all_state_variables.keys()):\n            raise ExperimentError(\n                f\"\\\"state_variables_to_record\\\" list is not a subset \"\n                \"of the state variables on SubpopModel \\\"{subpop_name}\\\" -- \"\n                \"modify \\\"state_variables_to_record\\\" and re-initialize experiment.\")\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.apply_inputs_to_model","title":"<code>apply_inputs_to_model(rep_counter: int)</code>","text":"<p>Changes inputs (parameters or initial values) for a given replication according to <code>self.inputs_realizations</code> attribute.</p> <p>Specifically, for each subpopulation, this function retrieves the corresponding values from <code>self.inputs_realizations</code> and applies them to either: (a) the subpopulation's <code>StateVariable</code>, if the input corresponds to a state variable, or (b) the subpopulation's <code>params</code> attribute, if the input corresponds to a model parameter. If the parameter or state variable is multidimensional (e.g., varies across age or risk groups), it is assigned a numpy array of the appropriate shape with the replicated input value.</p> <p>Parameters:</p> Name Type Description Default <code>rep_counter</code> <code>int</code> <p>Replication ID, used to retrieve the correct realizations of inputs for the current run.</p> required Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def apply_inputs_to_model(self,\n                          rep_counter: int):\n    \"\"\"\n    Changes inputs (parameters or initial values) for a given\n    replication according to `self.inputs_realizations` attribute.\n\n    Specifically, for each subpopulation, this function retrieves\n    the corresponding values from `self.inputs_realizations` and applies them to either:\n    (a) the subpopulation's `StateVariable`, if the input corresponds to a state variable,\n    or (b) the subpopulation's `params` attribute, if the input corresponds to a model\n    parameter. If the parameter or state variable is multidimensional\n    (e.g., varies across age or risk groups), it is assigned a numpy array of\n    the appropriate shape with the replicated input value.\n\n    Params:\n        rep_counter (int):\n            Replication ID, used to retrieve the correct\n            realizations of inputs for the current run.\n    \"\"\"\n\n    for subpop_model in self.experiment_subpop_models:\n\n        params = subpop_model.params\n\n        for input_name, input_val in self.inputs_realizations[subpop_model.name].items():\n\n            dimensions = (params.num_age_groups, params.num_risk_groups)\n\n            if input_name in subpop_model.all_state_variables.keys():\n                subpop_model.all_state_variables[input_name].current_val = np.full(dimensions,\n                                                                                   input_val[rep_counter])\n            else:\n                if np.isscalar(getattr(subpop_model.params, input_name)):\n                    setattr(subpop_model.params, input_name, input_val[rep_counter])\n                else:\n                    setattr(subpop_model.params, input_name, np.full(dimensions, input_val[rep_counter]))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.create_inputs_realizations_sql_tables","title":"<code>create_inputs_realizations_sql_tables()</code>","text":"<p>Create tables in SQL database given by <code>self.database_filename</code> to store realizations of inputs that change across replications. There is one table per associated subpopulation.</p> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def create_inputs_realizations_sql_tables(self):\n    \"\"\"\n    Create tables in SQL database given by `self.database_filename`\n    to store realizations of inputs that change across\n    replications. There is one table per associated subpopulation.\n    \"\"\"\n\n    conn = sqlite3.connect(self.database_filename)\n    cursor = conn.cursor()\n\n    for subpop_name in self.inputs_realizations.keys():\n        table_name = f'\"{subpop_name}_inputs\"'\n\n        column_names = self.inputs_realizations[subpop_name].keys()\n\n        # Construct the column definitions dynamically\n        column_definitions = \", \".join([f'\"{col}\" FLOAT' for col in column_names])\n\n        # SQL statement to create table\n        # Each table has a column called \"rep\" which is the primary\n        #   key and automatically increments every time a row is added\n        sql_statement = f\"\"\"\n        CREATE TABLE IF NOT EXISTS {table_name} (\n            rep INTEGER PRIMARY KEY AUTOINCREMENT,\n            {column_definitions}\n        )\n        \"\"\"\n\n        cursor.execute(sql_statement)\n\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.create_results_sql_table","title":"<code>create_results_sql_table()</code>","text":"<p>Create SQL database and save to <code>self.database_filename</code>. Create table named <code>results</code> with columns <code>subpop_name</code>, <code>state_var_name</code>, <code>age_group</code>, <code>risk_group</code>, <code>rep</code>, <code>timepoint</code>, and <code>value</code> to store results from each replication of experiment.</p> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def create_results_sql_table(self):\n    \"\"\"\n    Create SQL database and save to `self.database_filename`.\n    Create table named `results` with columns `subpop_name`,\n    `state_var_name`, `age_group`, `risk_group`, `rep`, `timepoint`,\n    and `value` to store results from each replication of experiment.\n    \"\"\"\n\n    # Make sure user is not overwriting database\n    if os.path.exists(self.database_filename):\n        raise ExperimentError(\"Database already exists! Overwriting is not allowed. \"\n                              \"Delete existing .db file or change database_filename \"\n                              \"attribute.\")\n\n    # Connect to the SQLite database and create database\n    # Create a cursor object to execute SQL commands\n    # Initialize a table with columns given by column_names\n    # Commit changes and close the connection\n    conn = sqlite3.connect(self.database_filename)\n    cursor = conn.cursor()\n    cursor.execute(\"\"\"\n    CREATE TABLE IF NOT EXISTS results (\n        subpop_name TEXT,\n        state_var_name TEXT,\n        age_group INT,\n        risk_group INT,\n        rep INT,\n        timepoint INT,\n        value FLOAT,\n        PRIMARY KEY (subpop_name, state_var_name, age_group, risk_group, rep, timepoint)\n    )\n    \"\"\")\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.get_state_var_df","title":"<code>get_state_var_df(state_var_name: str, subpop_name: str = None, age_group: int = None, risk_group: int = None, results_filename: str = None) -&gt; pd.DataFrame</code>","text":"<p>Get pandas DataFrame of recorded values of <code>StateVariable</code> given by <code>state_var_name</code>, in the <code>SubpopModel</code> given by <code>subpop_name</code>, for the age-risk group given by <code>age_group</code> and <code>risk_group</code>. If <code>subpop_name</code> is not specified, then values are summed across all associated subpopulations. Similarly, if <code>age_group</code> (or <code>risk_group</code>) is not specified, then values are summed across all age groups (or risk groups).</p> <p>Parameters:</p> Name Type Description Default <code>state_var_name</code> <code>str</code> <p>Name of the <code>StateVariable</code> to retrieve.</p> required <code>subpop_name</code> <code>Optional[str]</code> <p>The name of the <code>SubpopModel</code> for filtering. If None, values are summed across all <code>SubpopModel</code> instances.</p> <code>None</code> <code>age_group</code> <code>Optional[int]</code> <p>The age group to select. If None, values are summed across all age groups.</p> <code>None</code> <code>risk_group</code> <code>Optional[int]</code> <p>The risk group to select. If None, values are summed across all risk groups.</p> <code>None</code> <code>results_filename</code> <code>Optional[str]</code> <p>If provided, saves the resulting DataFrame as a CSV.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A pandas DataFrame where rows represent the replication and columns indicate the</p> <code>DataFrame</code> <p>simulation day (timepoint) of recording. DataFrame values are the <code>StateVariable</code>'s</p> <code>DataFrame</code> <p>current_val or the sum of the <code>StateVariable</code>'s current_val across subpopulations,</p> <code>DataFrame</code> <p>age groups, or risk groups (the combination of what is summed over is</p> <code>DataFrame</code> <p>specified by the user -- details are in the part of this docstring describing</p> <code>DataFrame</code> <p>this function's parameters).</p> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def get_state_var_df(self,\n                     state_var_name: str,\n                     subpop_name: str = None,\n                     age_group: int = None,\n                     risk_group: int = None,\n                     results_filename: str = None) -&gt; pd.DataFrame:\n    \"\"\"\n    Get pandas DataFrame of recorded values of `StateVariable` given by\n    `state_var_name`, in the `SubpopModel` given by `subpop_name`,\n    for the age-risk group given by `age_group` and `risk_group`.\n    If `subpop_name` is not specified, then values are summed across all\n    associated subpopulations. Similarly, if `age_group` (or `risk_group`)\n    is not specified, then values are summed across all age groups\n    (or risk groups).\n\n    Args:\n        state_var_name (str):\n            Name of the `StateVariable` to retrieve.\n        subpop_name (Optional[str]):\n            The name of the `SubpopModel` for filtering. If None, values are\n            summed across all `SubpopModel` instances.\n        age_group (Optional[int]):\n            The age group to select. If None, values are summed across\n            all age groups.\n        risk_group (Optional[int]):\n            The risk group to select. If None, values are summed across\n            all risk groups.\n        results_filename (Optional[str]):\n            If provided, saves the resulting DataFrame as a CSV.\n\n    Returns:\n        A pandas DataFrame where rows represent the replication and columns indicate the\n        simulation day (timepoint) of recording. DataFrame values are the `StateVariable`'s\n        current_val or the sum of the `StateVariable`'s current_val across subpopulations,\n        age groups, or risk groups (the combination of what is summed over is\n        specified by the user -- details are in the part of this docstring describing\n        this function's parameters).\n    \"\"\"\n\n    if state_var_name not in self.state_variables_to_record:\n        raise ExperimentError(\"\\\"state_var_name\\\" is not in \\\"self.state_variables_to_record\\\" --\"\n                              \"function call is invalid.\")\n\n    conn = sqlite3.connect(self.database_filename)\n\n    # Query all results table entries where state_var_name matches\n    # This will return results across all subpopulations, age groups,\n    #   and risk groups\n    df = get_sql_table_as_df(conn,\n                             \"SELECT * FROM results WHERE state_var_name = ?\",\n                             chunk_size=int(1e4),\n                             sql_query_params=(state_var_name,))\n\n    conn.close()\n\n    # Define filter conditions\n    filters = {\n        \"subpop_name\": subpop_name,\n        \"age_group\": age_group,\n        \"risk_group\": risk_group\n    }\n\n    # Filter DataFrame based on user-specified conditions\n    #   (for example, if user specifies subpop_name, return subset of\n    #   DataFrame where subpop_name matches)\n    conditions = [(df[col] == value) for col, value in filters.items() if value is not None]\n    df_filtered = df if not conditions else df[np.logical_and.reduce(conditions)]\n\n    # Group DataFrame based on unique combinations of \"rep\" and \"timepoint\" columns\n    # Then sum (numeric values only), return the \"value\" column, and reset the index\n    #   so that \"rep\" and \"timepoint\" become regular columns and are not the index\n    df_aggregated = \\\n        df_filtered.groupby([\"rep\",\n                             \"timepoint\"]).sum(numeric_only=True)[\"value\"].reset_index()\n\n    # breakpoint()\n\n    # Use pivot() function to reshape the DataFrame for its final form\n    # The \"timepoint\" values are spread across new columns\n    #   (creating a column for each unique timepoint).\n    # The \"value\" column populates the corresponding cells.\n    df_final = df_aggregated.pivot(index=\"rep\",\n                                   columns=\"timepoint\",\n                                   values=\"value\")\n\n    if results_filename:\n        df_final.to_csv(results_filename)\n\n    return df_final\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.log_current_vals_to_sql","title":"<code>log_current_vals_to_sql(rep_counter: int, experiment_cursor: sqlite3.Cursor) -&gt; None</code>","text":"<p>For each subpopulation and state variable to record associated with this <code>Experiment</code>, save current values to \"results\" table in SQL database specified by <code>experiment_cursor</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rep_counter</code> <code>int</code> <p>Current replication ID.</p> required <code>experiment_cursor</code> <code>Cursor</code> <p>Cursor object connected to the database where results should be inserted.</p> required Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def log_current_vals_to_sql(self,\n                            rep_counter: int,\n                            experiment_cursor: sqlite3.Cursor) -&gt; None:\n    \"\"\"\n    For each subpopulation and state variable to record\n    associated with this `Experiment`, save current values to\n    \"results\" table in SQL database specified by `experiment_cursor`.\n\n    Params:\n        rep_counter (int):\n            Current replication ID.\n        experiment_cursor (sqlite3.Cursor):\n            Cursor object connected to the database\n            where results should be inserted.\n    \"\"\"\n\n    for subpop_model in self.experiment_subpop_models:\n        for state_var_name in self.state_variables_to_record:\n            data = format_current_val_for_sql(subpop_model,\n                                              state_var_name,\n                                              rep_counter)\n            experiment_cursor.executemany(\n                \"INSERT INTO results VALUES (?, ?, ?, ?, ?, ?, ?)\", data)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.log_inputs_to_sql","title":"<code>log_inputs_to_sql(experiment_cursor: sqlite3.Cursor)</code>","text":"<p>For each subpopulation, add a new table to SQL database specified by <code>experiment_cursor</code>. Each table contains information on inputs that vary across replications (either due to random sampling or user-specified deterministic sequence). Each table contains inputs information from <code>Experiment</code> attribute <code>self.inputs_realizations</code> for a given subpopulation.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_cursor</code> <code>Cursor</code> <p>Cursor object connected to the database where results should be inserted.</p> required Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def log_inputs_to_sql(self,\n                      experiment_cursor: sqlite3.Cursor):\n    \"\"\"\n    For each subpopulation, add a new table to SQL\n    database specified by `experiment_cursor`. Each table\n    contains information on inputs that vary across\n    replications (either due to random sampling or\n    user-specified deterministic sequence). Each table\n    contains inputs information from `Experiment` attribute\n    `self.inputs_realizations` for a given subpopulation.\n\n    Params:\n        experiment_cursor (sqlite3.Cursor):\n            Cursor object connected to the database\n            where results should be inserted.\n    \"\"\"\n\n    for subpop_model in self.experiment_subpop_models:\n        table_name = f'\"{subpop_model.name}_inputs\"'\n\n        # Get the column names (dynamically, based on table)\n        experiment_cursor.execute(f\"PRAGMA table_info({table_name})\")\n\n        # Extract column names from the table info\n        # But exclude the column name \"rep\"\n        columns_info = experiment_cursor.fetchall()\n        column_names = [col[1] for col in columns_info if col[1] != \"rep\"]\n\n        # Create a placeholder string for the dynamic query\n        placeholders = \", \".join([\"?\" for _ in column_names])  # Number of placeholders matches number of columns\n\n        # Create the dynamic INSERT statement\n        sql_statement = f\"INSERT INTO {table_name} ({', '.join(column_names)}) VALUES ({placeholders})\"\n\n        # Create list of lists -- each nested list contains a sequence of values\n        #   for that particular input\n        subpop_inputs_realizations = self.inputs_realizations[subpop_model.name]\n        inputs_vals_over_reps_list = \\\n            [np.array(subpop_inputs_realizations[input_name]).reshape(-1,1) for input_name in column_names]\n        inputs_vals_over_reps_list = np.hstack(inputs_vals_over_reps_list)\n\n        experiment_cursor.executemany(sql_statement, inputs_vals_over_reps_list)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.run_random_inputs","title":"<code>run_random_inputs(num_reps: int, simulation_end_day: int, random_inputs_RNG: np.random.Generator, random_inputs_spec: dict, days_between_save_history: int = 1, results_filename: str = None, inputs_filename_suffix: str = None)</code>","text":"<p>Runs the associated <code>SubpopModel</code> or <code>MetapopModel</code> for a given number of independent replications until <code>simulation_end_day</code>, where certain parameter values or initial values are independently randomly sampled for each replication. Random sampling details (which inputs to sample and what Uniform distribution lower and upper bounds to use for each input) are specified in <code>random_inputs_spec</code>, and random sampling of inputs uses <code>random_inputs_RNG</code>. User can specify how often to save the history and a CSV file in which to store this history. User can also specify a filename suffix to name CSV files in which to store realizations of inputs.</p> <p>Parameters:</p> Name Type Description Default <code>num_reps</code> <code>positive int</code> <p>number of independent simulation replications to run in an experiment.</p> required <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at simulation_end_day (i.e. exclusive, simulate up to but not including simulation_end_day).</p> required <code>random_inputs_RNG</code> <code>Generator</code> <p>random number generator used to sample random inputs -- for reproducibility, it is recommended to use a distinct RNG for sampling random inputs different from the RNG for simulating the experiment/model.</p> required <code>random_inputs_spec</code> <code>dict</code> <p>random inputs' specification -- stores details for random input sampling -- keys are strings corresponding to input names (they must match names in each <code>SubpopModel</code>'s <code>SubpopParams</code> or associated <code>EpiMetric</code> or <code>Compartment</code> instances to be valid) and values are 2-tuples of nonnegative floats corresponding to lower and upper bounds for sampling that input from a uniform distribution.</p> required <code>days_between_save_history</code> <code>positive int</code> <p>indicates how often to save simulation results.</p> <code>1</code> <code>results_filename</code> <code>str</code> <p>if specified, must be valid filename with suffix \".csv\" -- experiment results are saved to this CSV file</p> <code>None</code> <code>inputs_filename_suffix</code> <code>str</code> <p>if specified, must be a valid filename with suffix \".csv\" -- one inputs CSV is generated for each <code>SubpopModel</code> with the filename \"{name}_{inputs_filename}\" where name is the name of the <code>SubpopModel</code> -- saves the values of each parameter that varies between replications</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def run_random_inputs(self,\n                      num_reps: int,\n                      simulation_end_day: int,\n                      random_inputs_RNG: np.random.Generator,\n                      random_inputs_spec: dict,\n                      days_between_save_history: int = 1,\n                      results_filename: str = None,\n                      inputs_filename_suffix: str = None):\n    \"\"\"\n    Runs the associated `SubpopModel` or `MetapopModel` for a\n    given number of independent replications until `simulation_end_day`,\n    where certain parameter values or initial values are\n    independently randomly sampled for each replication.\n    Random sampling details (which inputs to sample and what\n    Uniform distribution lower and upper bounds to use for each input)\n    are specified in `random_inputs_spec`, and random sampling of inputs\n    uses `random_inputs_RNG`. User can specify how often to save the\n    history and a CSV file in which to store this history.\n    User can also specify a filename suffix to name CSV files\n    in which to store realizations of inputs.\n\n    Params:\n        num_reps (positive int):\n            number of independent simulation replications\n            to run in an experiment.\n        simulation_end_day (positive int):\n            stop simulation at simulation_end_day (i.e. exclusive,\n            simulate up to but not including simulation_end_day).\n        random_inputs_RNG (np.random.Generator):\n            random number generator used to sample random\n            inputs -- for reproducibility, it is recommended to\n            use a distinct RNG for sampling random inputs different\n            from the RNG for simulating the experiment/model.\n        random_inputs_spec (dict):\n            random inputs' specification -- stores details\n            for random input sampling -- keys are strings\n            corresponding to input names (they must match\n            names in each `SubpopModel`'s `SubpopParams` or associated\n            `EpiMetric` or `Compartment` instances to be valid)\n            and values are 2-tuples of nonnegative floats corresponding\n            to lower and upper bounds for sampling that input from a\n            uniform distribution.\n        days_between_save_history (positive int):\n            indicates how often to save simulation results.\n        results_filename (str):\n            if specified, must be valid filename with suffix \".csv\" --\n            experiment results are saved to this CSV file\n        inputs_filename_suffix (str):\n            if specified, must be a valid filename with suffix \".csv\" --\n            one inputs CSV is generated for each `SubpopModel` with the\n            filename \"{name}_{inputs_filename}\" where name is the name\n            of the `SubpopModel` -- saves the values of each parameter that\n            varies between replications\n    \"\"\"\n\n    if self.has_been_run:\n        raise ExperimentError(\"Experiment has already been run. \"\n                              \"Create a new Experiment instance to simulate \"\n                              \"more replications.\")\n\n    else:\n        self.has_been_run = True\n\n        self.sample_random_inputs(num_reps,\n                                  random_inputs_RNG,\n                                  random_inputs_spec)\n\n        self.create_results_sql_table()\n        self.create_inputs_realizations_sql_tables()\n\n        self.simulate_reps_and_save_results(reps=num_reps,\n                                            end_day=simulation_end_day,\n                                            days_per_save=days_between_save_history,\n                                            inputs_are_static=False,\n                                            filename=results_filename)\n\n        if inputs_filename_suffix:\n            self.write_inputs_csvs(inputs_filename_suffix)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.run_sequences_of_inputs","title":"<code>run_sequences_of_inputs(num_reps: int, simulation_end_day: int, sequences_of_inputs: dict, days_between_save_history: int = 1, results_filename: str = None, inputs_filename_suffix: str = None)</code>","text":"<p>Runs the associated <code>SubpopModel</code> or <code>MetapopModel</code> for a given number of independent replications until <code>simulation_end_day</code>, where certain parameter values or initial values deterministically change between replications, according to <code>sequences_of_inputs</code>. User can specify how often to save the history and a CSV file in which to store this history. User can also specify a filename suffix to name CSV files in which to store sequences of inputs.</p> <p>Parameters:</p> Name Type Description Default <code>num_reps</code> <code>positive int</code> <p>number of independent simulation replications to run in an experiment.</p> required <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at <code>simulation_end_day</code> (i.e. exclusive, simulate up to but not including <code>simulation_end_day</code>).</p> required <code>sequences_of_inputs</code> <code>dict</code> <p>dictionary of dictionaries that stores user-specified deterministic sequences for inputs -- must follow specific structure. Keys are <code>SubpopModel</code> names, values are dictionaries. These second-layer dictionaries' keys are strings corresponding to input names (they must match names in each <code>SubpopModel</code>'s <code>SubpopParams</code> to be valid) and values are list-like, where the ith element corresponds to the ith random sample for that input.</p> required <code>days_between_save_history</code> <code>positive int</code> <p>indicates how often to save simulation results.</p> <code>1</code> <code>results_filename</code> <code>str</code> <p>if specified, must be valid filename with suffix \".csv\" -- experiment results are saved to this CSV file</p> <code>None</code> <code>inputs_filename_suffix</code> <code>str</code> <p>if specified, must be a valid filename with suffix \".csv\" -- one inputs CSV is generated for each <code>SubpopModel</code> with the filename \"{name}_{inputs_filename}\" where name is the name of the <code>SubpopModel</code> -- saves the values of each parameter that varies between replications</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def run_sequences_of_inputs(self,\n                            num_reps: int,\n                            simulation_end_day: int,\n                            sequences_of_inputs: dict,\n                            days_between_save_history: int = 1,\n                            results_filename: str = None,\n                            inputs_filename_suffix: str = None):\n    \"\"\"\n    Runs the associated `SubpopModel` or `MetapopModel` for a\n    given number of independent replications until `simulation_end_day`,\n    where certain parameter values or initial values deterministically\n    change between replications, according to `sequences_of_inputs`.\n    User can specify how often to save the history and a CSV file\n    in which to store this history. User can also specify a filename\n    suffix to name CSV files in which to store sequences of inputs.\n\n    Params:\n        num_reps (positive int):\n            number of independent simulation replications\n            to run in an experiment.\n        simulation_end_day (positive int):\n            stop simulation at `simulation_end_day` (i.e. exclusive,\n            simulate up to but not including `simulation_end_day`).\n        sequences_of_inputs (dict):\n            dictionary of dictionaries that stores user-specified deterministic\n            sequences for inputs -- must follow specific structure.\n            Keys are `SubpopModel` names, values are dictionaries.\n            These second-layer dictionaries' keys are strings corresponding\n            to input names (they must match names in each `SubpopModel`'s\n            `SubpopParams` to be valid) and values are list-like, where the ith\n            element corresponds to the ith random sample for that input.\n        days_between_save_history (positive int):\n            indicates how often to save simulation results.\n        results_filename (str):\n            if specified, must be valid filename with suffix \".csv\" --\n            experiment results are saved to this CSV file\n        inputs_filename_suffix (str):\n            if specified, must be a valid filename with suffix \".csv\" --\n            one inputs CSV is generated for each `SubpopModel` with the\n            filename \"{name}_{inputs_filename}\" where name is the name\n            of the `SubpopModel` -- saves the values of each parameter that\n            varies between replications\n    \"\"\"\n\n    if self.has_been_run:\n        raise ExperimentError(\"Experiment has already been run. \"\n                              \"Create a new Experiment instance to simulate \"\n                              \"more replications.\")\n\n    else:\n        self.has_been_run = True\n\n        self.inputs_realizations = sequences_of_inputs\n\n        self.create_results_sql_table()\n        self.create_inputs_realizations_sql_tables()\n\n        self.simulate_reps_and_save_results(reps=num_reps,\n                                            end_day=simulation_end_day,\n                                            days_per_save=days_between_save_history,\n                                            inputs_are_static=False,\n                                            filename=results_filename)\n\n        if inputs_filename_suffix:\n            self.write_inputs_csvs(inputs_filename_suffix)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.run_static_inputs","title":"<code>run_static_inputs(num_reps: int, simulation_end_day: int, days_between_save_history: int = 1, results_filename: str = None)</code>","text":"<p>Runs the associated <code>SubpopModel</code> or <code>MetapopModel</code> for a given number of independent replications until <code>simulation_end_day</code>. Parameter values and initial values are the same across simulation replications. User can specify how often to save the history and a CSV file in which to store this history.</p> <p>Parameters:</p> Name Type Description Default <code>num_reps</code> <code>positive int</code> <p>number of independent simulation replications to run in an experiment.</p> required <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at simulation_end_day (i.e. exclusive, simulate up to but not including simulation_end_day).</p> required <code>days_between_save_history</code> <code>positive int</code> <p>indicates how often to save simulation results.</p> <code>1</code> <code>results_filename</code> <code>str</code> <p>if specified, must be valid filename with suffix \".csv\" -- experiment results are saved to this CSV file.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def run_static_inputs(self,\n                      num_reps: int,\n                      simulation_end_day: int,\n                      days_between_save_history: int = 1,\n                      results_filename: str = None):\n    \"\"\"\n    Runs the associated `SubpopModel` or `MetapopModel` for a\n    given number of independent replications until `simulation_end_day`.\n    Parameter values and initial values are the same across\n    simulation replications. User can specify how often to save the\n    history and a CSV file in which to store this history.\n\n    Params:\n        num_reps (positive int):\n            number of independent simulation replications\n            to run in an experiment.\n        simulation_end_day (positive int):\n            stop simulation at simulation_end_day (i.e. exclusive,\n            simulate up to but not including simulation_end_day).\n        days_between_save_history (positive int):\n            indicates how often to save simulation results.\n        results_filename (str):\n            if specified, must be valid filename with suffix \".csv\" --\n            experiment results are saved to this CSV file.\n    \"\"\"\n\n    if self.has_been_run:\n        raise ExperimentError(\"Experiment has already been run. \"\n                              \"Create a new Experiment instance to simulate \"\n                              \"more replications.\")\n\n    else:\n        self.has_been_run = True\n\n        self.create_results_sql_table()\n\n        self.simulate_reps_and_save_results(reps=num_reps,\n                                            end_day=simulation_end_day,\n                                            days_per_save=days_between_save_history,\n                                            inputs_are_static=True,\n                                            filename=results_filename)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.sample_random_inputs","title":"<code>sample_random_inputs(total_reps: int, RNG: np.random.Generator, spec: dict)</code>","text":"<p>Randomly and independently samples inputs specified by keys of <code>spec</code> according to uniform distribution with lower and upper bounds specified by values of <code>spec</code>. Stores random realizations in <code>self.inputs_realizations</code> attribute. Uses <code>RNG</code> to sample inputs.</p> <p>Parameters:</p> Name Type Description Default <code>total_reps</code> <code>positive int</code> <p>number of independent simulation replications to run in an experiment -- corresponds to number of Uniform random variables to draw for each state variable.</p> required <code>RNG</code> <code>Generator</code> <p>random number generator used to sample random inputs -- for reproducibility, it is recommended to use a distinct RNG for sampling random inputs different from the RNG for simulating the experiment/model.</p> required <code>spec</code> <code>dict</code> <p>random inputs' specification -- stores details for random input sampling -- keys are strings corresponding to input names (they must match names in each <code>SubpopModel</code>'s <code>SubpopParams</code> or associated <code>EpiMetric</code> or <code>Compartment</code> instances to be valid) and values are 2-tuples of nonnegative floats corresponding to lower and upper bounds for sampling that input from a uniform distribution.</p> required NOTE <p>If an input is an |A| x |R| array (for age-risk), the current functionality does not support sampling individual age-risk elements separately. Instead, a single scalar value is sampled at a time for the entire input. Consequently, if an |A| x |R| input is chosen to be randomly sampled, all its elements will have the same sampled value.</p> <p>If a user wants to sample some age-risk elements separately, they should create new inputs for these elements. \"Inputs\" refers to both parameters (in <code>SubpopParams</code>) and initial values of <code>Compartment</code> and <code>EpiMetric</code> instances. For example, if the model has a parameter <code>H_to_R_rate</code> that is 2x1 (2 age groups, 1 risk group) and the user wants to sample each element separately, they should create two parameters: <code>H_to_R_rate_age_group_1</code> and <code>H_to_R_rate_age_group_2.</code> These should be added to the relevant <code>SubpopParams</code> instance and input dictionary/file used to create the <code>SubpopParams</code> instance. The user can then specify both parameters to be randomly sampled and specify the lower and upper bounds accordingly.</p> <p>TODO: allow sampling individual age-risk elements separately without creating new parameters for each element.</p> <p>(Developer note: the difficulty is not with randomly sampling arrays, but rather storing arrays in SQL -- SQL tables only support atomic values.)</p> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def sample_random_inputs(self,\n                         total_reps: int,\n                         RNG: np.random.Generator,\n                         spec: dict):\n    \"\"\"\n    Randomly and independently samples inputs specified by keys of\n    `spec` according to uniform distribution with lower\n    and upper bounds specified by values of `spec`.\n    Stores random realizations in `self.inputs_realizations` attribute.\n    Uses `RNG` to sample inputs.\n\n    Params:\n        total_reps (positive int):\n            number of independent simulation replications\n            to run in an experiment -- corresponds to number of\n            Uniform random variables to draw for each\n            state variable.\n        RNG (np.random.Generator):\n            random number generator used to sample random\n            inputs -- for reproducibility, it is recommended to\n            use a distinct RNG for sampling random inputs different\n            from the RNG for simulating the experiment/model.\n        spec (dict):\n            random inputs' specification -- stores details\n            for random input sampling -- keys are strings\n            corresponding to input names (they must match\n            names in each `SubpopModel`'s `SubpopParams` or associated\n            `EpiMetric` or `Compartment` instances to be valid)\n            and values are 2-tuples of nonnegative floats corresponding\n            to lower and upper bounds for sampling that input from a\n            uniform distribution.\n\n    NOTE:\n        If an input is an |A| x |R| array (for age-risk),\n        the current functionality does not support sampling individual\n        age-risk elements separately. Instead, a single scalar value\n        is sampled at a time for the entire input. Consequently,\n        if an |A| x |R| input is chosen to be randomly sampled,\n        all its elements will have the same sampled value.\n\n        If a user wants to sample some age-risk elements separately,\n        they should create new inputs for these elements. \"Inputs\"\n        refers to both parameters (in `SubpopParams`) and initial values\n        of `Compartment` and `EpiMetric` instances. For example, if the model\n        has a parameter `H_to_R_rate` that is 2x1 (2 age groups, 1 risk group)\n        and the user wants to sample each element separately, they should create\n        two parameters: `H_to_R_rate_age_group_1` and `H_to_R_rate_age_group_2.`\n        These should be added to the relevant `SubpopParams` instance and\n        input dictionary/file used to create the `SubpopParams` instance.\n        The user can then specify both parameters to be randomly sampled\n        and specify the lower and upper bounds accordingly.\n\n        TODO: allow sampling individual age-risk elements separately\n        without creating new parameters for each element.\n\n        (Developer note: the difficulty is not with randomly sampling\n        arrays, but rather storing arrays in SQL -- SQL tables only\n        support atomic values.)\n    \"\"\"\n\n    inputs_realizations = self.inputs_realizations\n\n    for subpop_model in self.experiment_subpop_models:\n\n        subpop_name = subpop_model.name\n\n        compartments_names_list = list(subpop_model.compartments.keys())\n        epi_metrics_names_list = list(subpop_model.epi_metrics.keys())\n        params_names_list = [field.name for field in fields(subpop_model.params)]\n\n        if not check_is_subset_list(spec[subpop_name],\n                                    compartments_names_list + epi_metrics_names_list + params_names_list):\n            raise (f\"\\\"random_inputs_spec[\\\"{subpop_name}\\\"]\\\" keys are not a subset \"\n                   \"of the state variables and parameters on SubpopModel \\\"{subpop_name}\\\" -- \"\n                   \"modify \\\"random_inputs_spec\\\" and re-initialize experiment.\")\n\n        for state_var_name, bounds in spec[subpop_name].items():\n            lower_bd = bounds[0]\n            upper_bd = bounds[1]\n            inputs_realizations[subpop_name][state_var_name] = \\\n                RNG.uniform(low=lower_bd,\n                            high=upper_bd,\n                            size=total_reps)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.simulate_reps_and_save_results","title":"<code>simulate_reps_and_save_results(reps: int, end_day: int, days_per_save: int, inputs_are_static: bool, filename: str = None)</code>","text":"<p>Helper function that executes main loop over replications in <code>Experiment</code> and saves results.</p> <p>Parameters:</p> Name Type Description Default <code>reps</code> <code>int</code> <p>number of independent simulation replications to run in an experiment.</p> required <code>end_day</code> <code>int</code> <p>stop simulation at end_day (i.e. exclusive, simulate up to but not including end_day).</p> required <code>days_per_save</code> <code>int</code> <p>indicates how often to save simulation results.</p> required <code>inputs_are_static</code> <code>bool</code> <p>indicates if inputs are same across replications.</p> required <code>filename</code> <code>str</code> <p>if specified, must be valid filename with suffix \".csv\" -- experiment results are saved to this CSV file.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def simulate_reps_and_save_results(self,\n                                   reps: int,\n                                   end_day: int,\n                                   days_per_save: int,\n                                   inputs_are_static: bool,\n                                   filename: str = None):\n    \"\"\"\n    Helper function that executes main loop over\n    replications in `Experiment` and saves results.\n\n    Params:\n        reps (int):\n            number of independent simulation replications\n            to run in an experiment.\n        end_day (int):\n            stop simulation at end_day (i.e. exclusive,\n            simulate up to but not including end_day).\n        days_per_save (int):\n            indicates how often to save simulation results.\n        inputs_are_static (bool):\n            indicates if inputs are same across replications.\n        filename (str):\n            if specified, must be valid filename with suffix \".csv\" --\n            experiment results are saved to this CSV file.\n    \"\"\"\n\n    # Override each subpop config's save_daily_history attribute --\n    #   set it to False -- because we will manually save history\n    #   to results database according to user-defined\n    #   days_between_save_history for all subpops\n    for subpop_model in self.experiment_subpop_models:\n        subpop_model.config.save_daily_history = False\n\n    model = self.model\n\n    # Connect to SQL database\n    conn = sqlite3.connect(self.database_filename)\n    cursor = conn.cursor()\n\n    # Loop through replications\n    for rep in range(reps):\n\n        # Reset model and clear its history\n        model.reset_simulation()\n\n        # Apply new values of inputs, if some\n        #   inputs change between replications\n        if not inputs_are_static:\n            self.apply_inputs_to_model(rep)\n            self.log_inputs_to_sql(cursor)\n\n        # Simulate model and save results every `days_per_save` days\n        while model.current_simulation_day &lt; end_day:\n            model.simulate_until_day(min(model.current_simulation_day + days_per_save,\n                                         end_day))\n\n            self.log_current_vals_to_sql(rep, cursor)\n\n    self.results_df = get_sql_table_as_df(conn, \"SELECT * FROM results\", chunk_size=int(1e4))\n\n    if filename:\n        self.results_df.to_csv(filename)\n\n    # Commit changes to database and close\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Experiment.write_inputs_csvs","title":"<code>write_inputs_csvs(suffix: str)</code>","text":"<p>For each subpopulation, writes a CSV (with a filename based on provided suffix) containing values of inputs across replications.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>Common suffix used to generate CSV filenames.</p> required Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def write_inputs_csvs(self,\n                      suffix: str):\n    \"\"\"\n    For each subpopulation, writes a CSV (with a filename\n    based on provided suffix) containing values of inputs\n    across replications.\n\n    Params:\n        suffix (str):\n            Common suffix used to generate CSV filenames.\n    \"\"\"\n\n    for subpop_model in self.experiment_subpop_models:\n        conn = sqlite3.connect(self.database_filename)\n\n        table_name = f\"{subpop_model.name}_inputs\"\n\n        subpop_inputs_df = get_sql_table_as_df(conn, f\"SELECT * FROM {table_name}\", chunk_size=int(1e4))\n\n        subpop_inputs_df.to_csv(f\"{subpop_model.name}_{suffix}\", index=False)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.ExperimentError","title":"<code>ExperimentError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for experiment errors.</p> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>class ExperimentError(Exception):\n    \"\"\"Custom exceptions for experiment errors.\"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.InterSubpopRepo","title":"<code>InterSubpopRepo</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Holds collection of <code>SubpopState</code> instances, with     actions to query and interact with them.</p> <p>Attributes:</p> Name Type Description <code>subpop_models</code> <code>objdict</code> <p>keys are unique names of subpopulation models, values are their respective <code>SubpopModel</code> instances -- this dictionary contains all <code>SubpopModel</code> instances that comprise a <code>MetapopModel</code> instance.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class InterSubpopRepo(ABC):\n    \"\"\"\n    Holds collection of `SubpopState` instances, with\n        actions to query and interact with them.\n\n    Attributes:\n        subpop_models (sc.objdict):\n            keys are unique names of subpopulation models,\n            values are their respective `SubpopModel` instances --\n            this dictionary contains all `SubpopModel` instances\n            that comprise a `MetapopModel` instance.\n    \"\"\"\n\n    def __init__(self,\n                 subpop_models: Optional[dict] = None):\n        self.subpop_models = sc.objdict(subpop_models)\n\n        # The \"name\" argument for instantiating a SubpopModel\n        #   is optional -- but SubpopModel instances must have\n        #   names when used in a MetapopModel\n        # So, we assign names to each SubpopModel based on\n        #   the keys of the dictionary that creates the InterSubpopRepo\n        for name, model in subpop_models.items():\n            model.name = name\n\n    @abstractmethod\n    def compute_shared_quantities(self):\n        \"\"\"\n        Subclasses must provide concrete implementation. This method\n        is called by the `MetapopModel` instance at the beginning of\n        each simulation day, before each `SubpopModel` simulates that day.\n\n        Note: often, `InteractionTerm`s across `SubpopModel`s share similar\n        terms in their computation. This `self.compute_shared_quantities`\n        method computes such similar terms up front to reduce redundant\n        computation.\n        \"\"\"\n\n        pass\n\n    def update_all_interaction_terms(self):\n        \"\"\"\n        Updates `SubpopState` of each `SubpopModel` in\n        `self.subpop_models` to reflect current values of each\n        `InteractionTerm` on that `SubpopModel`.\n        \"\"\"\n\n        for subpop_model in self.subpop_models.values():\n            for iterm in subpop_model.interaction_terms.values():\n                iterm.update_current_val(self,\n                                         subpop_model.params)\n            subpop_model.state.sync_to_current_vals(subpop_model.interaction_terms)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.InterSubpopRepo.compute_shared_quantities","title":"<code>compute_shared_quantities()</code>","text":"<p>Subclasses must provide concrete implementation. This method is called by the <code>MetapopModel</code> instance at the beginning of each simulation day, before each <code>SubpopModel</code> simulates that day.</p> <p>Note: often, <code>InteractionTerm</code>s across <code>SubpopModel</code>s share similar terms in their computation. This <code>self.compute_shared_quantities</code> method computes such similar terms up front to reduce redundant computation.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@abstractmethod\ndef compute_shared_quantities(self):\n    \"\"\"\n    Subclasses must provide concrete implementation. This method\n    is called by the `MetapopModel` instance at the beginning of\n    each simulation day, before each `SubpopModel` simulates that day.\n\n    Note: often, `InteractionTerm`s across `SubpopModel`s share similar\n    terms in their computation. This `self.compute_shared_quantities`\n    method computes such similar terms up front to reduce redundant\n    computation.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.InterSubpopRepo.update_all_interaction_terms","title":"<code>update_all_interaction_terms()</code>","text":"<p>Updates <code>SubpopState</code> of each <code>SubpopModel</code> in <code>self.subpop_models</code> to reflect current values of each <code>InteractionTerm</code> on that <code>SubpopModel</code>.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_all_interaction_terms(self):\n    \"\"\"\n    Updates `SubpopState` of each `SubpopModel` in\n    `self.subpop_models` to reflect current values of each\n    `InteractionTerm` on that `SubpopModel`.\n    \"\"\"\n\n    for subpop_model in self.subpop_models.values():\n        for iterm in subpop_model.interaction_terms.values():\n            iterm.update_current_val(self,\n                                     subpop_model.params)\n        subpop_model.state.sync_to_current_vals(subpop_model.interaction_terms)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.InteractionTerm","title":"<code>InteractionTerm</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that depend on the state of more than one <code>SubpopModel</code> (i.e., that depend on more than one <code>SubpopState</code>). These variables are functions of how subpopulations interact.</p> <p>In contrast to other state variables, each <code>InteractionTerm</code> takes in an <code>InterSubpopRepo</code> instance to update its <code>self.current_val</code>. Other state variables that are \"local\" and depend on exactly one subpopulation only need to take in one <code>SubpopState</code> and one <code>SubpopParams</code> instance to update its current value.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class InteractionTerm(StateVariable, ABC):\n\n    \"\"\"\n    Abstract base class for variables that depend on the state of\n    more than one `SubpopModel` (i.e., that depend on more than one\n    `SubpopState`). These variables are functions of how subpopulations\n    interact.\n\n    In contrast to other state variables, each `InteractionTerm`\n    takes in an `InterSubpopRepo` instance to update its `self.current_val`.\n    Other state variables that are \"local\" and depend on\n    exactly one subpopulation only need to take in one `SubpopState`\n    and one `SubpopParams` instance to update its current value.\n\n    Inherits attributes from `StateVariable`.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    @abstractmethod\n    def update_current_val(self,\n                           inter_subpop_repo: InterSubpopRepo,\n                           subpop_params: SubpopParams) -&gt; None:\n        \"\"\"\n        Subclasses must provide a concrete implementation of\n        updating `self.current_val` in-place.\n\n        Args:\n            inter_subpop_repo (InterSubpopRepo):\n                manages collection of subpop models with\n                methods for querying information.\n            subpop_params (SubpopParams):\n                holds values of subpopulation's epidemiological parameters.\n        \"\"\"\n\n        pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.InteractionTerm.update_current_val","title":"<code>update_current_val(inter_subpop_repo: InterSubpopRepo, subpop_params: SubpopParams) -&gt; None</code>","text":"<p>Subclasses must provide a concrete implementation of updating <code>self.current_val</code> in-place.</p> <p>Parameters:</p> Name Type Description Default <code>inter_subpop_repo</code> <code>InterSubpopRepo</code> <p>manages collection of subpop models with methods for querying information.</p> required <code>subpop_params</code> <code>SubpopParams</code> <p>holds values of subpopulation's epidemiological parameters.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self,\n                       inter_subpop_repo: InterSubpopRepo,\n                       subpop_params: SubpopParams) -&gt; None:\n    \"\"\"\n    Subclasses must provide a concrete implementation of\n    updating `self.current_val` in-place.\n\n    Args:\n        inter_subpop_repo (InterSubpopRepo):\n            manages collection of subpop models with\n            methods for querying information.\n        subpop_params (SubpopParams):\n            holds values of subpopulation's epidemiological parameters.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.JointTransitionTypes","title":"<code>JointTransitionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class JointTransitionTypes(str, Enum):\n    MULTINOMIAL = \"multinomial\"\n    MULTINOMIAL_DETERMINISTIC = \"multinomial_deterministic\"\n    MULTINOMIAL_TAYLOR_APPROX = \"multinomial_taylor_approx\"\n    MULTINOMIAL_TAYLOR_APPROX_DETERMINISTIC = \"multinomial_taylor_approx_deterministic\"\n    POISSON = \"poisson\"\n    POISSON_DETERMINISTIC = \"poisson_deterministic\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.MetapopModel","title":"<code>MetapopModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class that bundles <code>SubpopModel</code>s linked using     a travel model.</p> <p>Parameters:</p> Name Type Description Default <code>inter_subpop_repo</code> <code>InterSubpopRepo</code> <p>Accesses and manages <code>SubpopState</code> instances of corresponding <code>SubpopModel</code>s, and provides methods to query current values.</p> required <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class MetapopModel(ABC):\n    \"\"\"\n    Abstract base class that bundles `SubpopModel`s linked using\n        a travel model.\n\n    Params:\n        inter_subpop_repo (InterSubpopRepo):\n            Accesses and manages `SubpopState` instances\n            of corresponding `SubpopModel`s, and provides\n            methods to query current values.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 inter_subpop_repo,\n                 name: str = \"\"):\n        \"\"\"\n        Params:\n            inter_subpop_repo (InterSubpopRepo):\n                manages collection of subpopulation models with\n                methods for querying information.\n            name (str):\n                unique identifier for `MetapopModel`.\n        \"\"\"\n\n        self.subpop_models = inter_subpop_repo.subpop_models\n\n        self.inter_subpop_repo = inter_subpop_repo\n\n        self.name = name\n\n        for model in self.subpop_models.values():\n            model.metapop_model = self\n            model.interaction_terms = model.create_interaction_terms()\n            model.state.interaction_terms = model.interaction_terms\n\n    def extract_states_dict_from_models_dict(self,\n                                             models_dict: sc.objdict) -&gt; sc.objdict:\n        \"\"\"\n        (Currently unused utility function.)\n\n        Takes objdict of subpop models, where keys are subpop model names and\n            values are the subpop model instances, and returns objdict of\n            subpop model states, where keys are subpop model names and\n            values are the subpop model `SubpopState` instances.\n        \"\"\"\n\n        states_dict = \\\n            sc.objdict({name: model.state for name, model in models_dict.items()})\n\n        return states_dict\n\n    def simulate_until_day(self,\n                           simulation_end_day: int) -&gt; None:\n        \"\"\"\n        Advance simulation model time until `simulation_end_day` in\n        `MetapopModel`.\n\n        NOT just the same as looping through each `SubpopModel`'s\n        `simulate_until_day` method. On the `MetapopModel`,\n        because `SubpopModel` instances are linked with `InteractionTerm`s\n        and are not independent of each other, this `MetapopModel`'s\n        `simulate_until_day` method has additional functionality.\n\n        Note: the update order at the beginning of each day is very important!\n\n        - First, each `SubpopModel` updates its daily state (computing\n            `Schedule` and `DynamicVal` instances).\n        - Second, the `MetapopModel`'s `InterSubpopRepo` computes any shared\n            terms used across subpopulations (to reduce computational overhead),\n            and then updates each `SubpopModel`'s associated `InteractionTerm`\n            instances.\n        - Third, each `SubpopModel` simulates discretized timesteps (sampling\n            `TransitionVariable`s, updating `EpiMetric`s, and updating `Compartment`s).\n\n        Args:\n            simulation_end_day (positive int):\n                stop simulation at `simulation_end_day` (i.e. exclusive,\n                simulate up to but not including `simulation_end_day`).\n        \"\"\"\n\n        if self.current_simulation_day &gt; simulation_end_day:\n            raise MetapopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                   f\"exceeds last simulation day ({simulation_end_day}).\")\n\n        while self.current_simulation_day &lt; simulation_end_day:\n\n            for subpop_model in self.subpop_models.values():\n                subpop_model.prepare_daily_state()\n\n            self.inter_subpop_repo.compute_shared_quantities()\n            self.inter_subpop_repo.update_all_interaction_terms()\n\n            for subpop_model in self.subpop_models.values():\n\n                save_daily_history = subpop_model.config.save_daily_history\n                timesteps_per_day = subpop_model.config.timesteps_per_day\n\n                subpop_model.simulate_timesteps(timesteps_per_day)\n\n                if save_daily_history:\n                    subpop_model.save_daily_history()\n\n                subpop_model.increment_simulation_day()\n\n    def display(self):\n        \"\"\"\n        Prints structure (compartments and linkages), transition variables,\n        epi metrics, schedules, and dynamic values for each `SubpopModel`\n        instance in `self.subpop_models`.\n        \"\"\"\n        for subpop_model in self.subpop_models.values():\n            subpop_model.display()\n\n    def reset_simulation(self):\n        \"\"\"\n        Resets `MetapopModel` by resetting and clearing\n            history on all `SubpopModel` instances in\n            `self.subpop_models`.\n        \"\"\"\n\n        for subpop_model in self.subpop_models.values():\n            subpop_model.reset_simulation()\n\n    @property\n    def current_simulation_day(self) -&gt; int:\n        \"\"\"\n        Returns:\n            Current simulation day. The current simulation day of the\n            `MetapopModel` should be the same as each individual `SubpopModel`\n            in the `MetapopModel`. Otherwise, an error is raised.\n        \"\"\"\n\n        current_simulation_days_list = []\n\n        for subpop_model in self.subpop_models.values():\n            current_simulation_days_list.append(subpop_model.current_simulation_day)\n\n        if len(set(current_simulation_days_list)) &gt; 1:\n            raise MetapopModelError(\"Subpopulation models are on different simulation days \"\n                                    \"and are out-of-sync. This may be caused by simulating \"\n                                    \"a subpopulation model independently from the \"\n                                    \"metapopulation model. Fix error and try again.\")\n        else:\n            return current_simulation_days_list[0]\n\n    @property\n    def current_real_date(self) -&gt; datetime.date:\n        \"\"\"\n        Returns:\n            Current real date corresponding to current simulation day.\n            The current real date of the `MetapopModel` should be the same as\n            each individual `SubpopModel` in the `MetapopModel`.\n            Otherwise, an error is raised.\n        \"\"\"\n\n        current_real_dates_list = []\n\n        for subpop_model in self.subpop_models.values():\n            current_real_dates_list.append(subpop_model.current_real_date)\n\n        if len(set(current_real_dates_list)) &gt; 1:\n            raise MetapopModelError(\"Subpopulation models are on different real dates \"\n                                    \"and are out-of-sync. This may be caused by simulating \"\n                                    \"a subpopulation model independently from the \"\n                                    \"metapopulation model. Fix error and try again.\")\n        else:\n            return current_real_dates_list[0]\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.MetapopModel.current_real_date","title":"<code>current_real_date: datetime.date</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>date</code> <p>Current real date corresponding to current simulation day.</p> <code>date</code> <p>The current real date of the <code>MetapopModel</code> should be the same as</p> <code>date</code> <p>each individual <code>SubpopModel</code> in the <code>MetapopModel</code>.</p> <code>date</code> <p>Otherwise, an error is raised.</p>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.MetapopModel.current_simulation_day","title":"<code>current_simulation_day: int</code>  <code>property</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>Current simulation day. The current simulation day of the</p> <code>int</code> <p><code>MetapopModel</code> should be the same as each individual <code>SubpopModel</code></p> <code>int</code> <p>in the <code>MetapopModel</code>. Otherwise, an error is raised.</p>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.MetapopModel.__init__","title":"<code>__init__(inter_subpop_repo, name: str = '')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>inter_subpop_repo</code> <code>InterSubpopRepo</code> <p>manages collection of subpopulation models with methods for querying information.</p> required <code>name</code> <code>str</code> <p>unique identifier for <code>MetapopModel</code>.</p> <code>''</code> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             inter_subpop_repo,\n             name: str = \"\"):\n    \"\"\"\n    Params:\n        inter_subpop_repo (InterSubpopRepo):\n            manages collection of subpopulation models with\n            methods for querying information.\n        name (str):\n            unique identifier for `MetapopModel`.\n    \"\"\"\n\n    self.subpop_models = inter_subpop_repo.subpop_models\n\n    self.inter_subpop_repo = inter_subpop_repo\n\n    self.name = name\n\n    for model in self.subpop_models.values():\n        model.metapop_model = self\n        model.interaction_terms = model.create_interaction_terms()\n        model.state.interaction_terms = model.interaction_terms\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.MetapopModel.display","title":"<code>display()</code>","text":"<p>Prints structure (compartments and linkages), transition variables, epi metrics, schedules, and dynamic values for each <code>SubpopModel</code> instance in <code>self.subpop_models</code>.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def display(self):\n    \"\"\"\n    Prints structure (compartments and linkages), transition variables,\n    epi metrics, schedules, and dynamic values for each `SubpopModel`\n    instance in `self.subpop_models`.\n    \"\"\"\n    for subpop_model in self.subpop_models.values():\n        subpop_model.display()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.MetapopModel.extract_states_dict_from_models_dict","title":"<code>extract_states_dict_from_models_dict(models_dict: sc.objdict) -&gt; sc.objdict</code>","text":"<p>(Currently unused utility function.)</p> <p>Takes objdict of subpop models, where keys are subpop model names and     values are the subpop model instances, and returns objdict of     subpop model states, where keys are subpop model names and     values are the subpop model <code>SubpopState</code> instances.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def extract_states_dict_from_models_dict(self,\n                                         models_dict: sc.objdict) -&gt; sc.objdict:\n    \"\"\"\n    (Currently unused utility function.)\n\n    Takes objdict of subpop models, where keys are subpop model names and\n        values are the subpop model instances, and returns objdict of\n        subpop model states, where keys are subpop model names and\n        values are the subpop model `SubpopState` instances.\n    \"\"\"\n\n    states_dict = \\\n        sc.objdict({name: model.state for name, model in models_dict.items()})\n\n    return states_dict\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.MetapopModel.reset_simulation","title":"<code>reset_simulation()</code>","text":"<p>Resets <code>MetapopModel</code> by resetting and clearing     history on all <code>SubpopModel</code> instances in     <code>self.subpop_models</code>.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset_simulation(self):\n    \"\"\"\n    Resets `MetapopModel` by resetting and clearing\n        history on all `SubpopModel` instances in\n        `self.subpop_models`.\n    \"\"\"\n\n    for subpop_model in self.subpop_models.values():\n        subpop_model.reset_simulation()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.MetapopModel.simulate_until_day","title":"<code>simulate_until_day(simulation_end_day: int) -&gt; None</code>","text":"<p>Advance simulation model time until <code>simulation_end_day</code> in <code>MetapopModel</code>.</p> <p>NOT just the same as looping through each <code>SubpopModel</code>'s <code>simulate_until_day</code> method. On the <code>MetapopModel</code>, because <code>SubpopModel</code> instances are linked with <code>InteractionTerm</code>s and are not independent of each other, this <code>MetapopModel</code>'s <code>simulate_until_day</code> method has additional functionality.</p> <p>Note: the update order at the beginning of each day is very important!</p> <ul> <li>First, each <code>SubpopModel</code> updates its daily state (computing     <code>Schedule</code> and <code>DynamicVal</code> instances).</li> <li>Second, the <code>MetapopModel</code>'s <code>InterSubpopRepo</code> computes any shared     terms used across subpopulations (to reduce computational overhead),     and then updates each <code>SubpopModel</code>'s associated <code>InteractionTerm</code>     instances.</li> <li>Third, each <code>SubpopModel</code> simulates discretized timesteps (sampling     <code>TransitionVariable</code>s, updating <code>EpiMetric</code>s, and updating <code>Compartment</code>s).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at <code>simulation_end_day</code> (i.e. exclusive, simulate up to but not including <code>simulation_end_day</code>).</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def simulate_until_day(self,\n                       simulation_end_day: int) -&gt; None:\n    \"\"\"\n    Advance simulation model time until `simulation_end_day` in\n    `MetapopModel`.\n\n    NOT just the same as looping through each `SubpopModel`'s\n    `simulate_until_day` method. On the `MetapopModel`,\n    because `SubpopModel` instances are linked with `InteractionTerm`s\n    and are not independent of each other, this `MetapopModel`'s\n    `simulate_until_day` method has additional functionality.\n\n    Note: the update order at the beginning of each day is very important!\n\n    - First, each `SubpopModel` updates its daily state (computing\n        `Schedule` and `DynamicVal` instances).\n    - Second, the `MetapopModel`'s `InterSubpopRepo` computes any shared\n        terms used across subpopulations (to reduce computational overhead),\n        and then updates each `SubpopModel`'s associated `InteractionTerm`\n        instances.\n    - Third, each `SubpopModel` simulates discretized timesteps (sampling\n        `TransitionVariable`s, updating `EpiMetric`s, and updating `Compartment`s).\n\n    Args:\n        simulation_end_day (positive int):\n            stop simulation at `simulation_end_day` (i.e. exclusive,\n            simulate up to but not including `simulation_end_day`).\n    \"\"\"\n\n    if self.current_simulation_day &gt; simulation_end_day:\n        raise MetapopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                               f\"exceeds last simulation day ({simulation_end_day}).\")\n\n    while self.current_simulation_day &lt; simulation_end_day:\n\n        for subpop_model in self.subpop_models.values():\n            subpop_model.prepare_daily_state()\n\n        self.inter_subpop_repo.compute_shared_quantities()\n        self.inter_subpop_repo.update_all_interaction_terms()\n\n        for subpop_model in self.subpop_models.values():\n\n            save_daily_history = subpop_model.config.save_daily_history\n            timesteps_per_day = subpop_model.config.timesteps_per_day\n\n            subpop_model.simulate_timesteps(timesteps_per_day)\n\n            if save_daily_history:\n                subpop_model.save_daily_history()\n\n            subpop_model.increment_simulation_day()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.MetapopModelError","title":"<code>MetapopModelError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for metapopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class MetapopModelError(Exception):\n    \"\"\"Custom exceptions for metapopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Schedule","title":"<code>Schedule</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that are functions of real-world dates -- for example, contact matrices (which depend on the day of the week and whether the current day is a holiday), historical vaccination data, and seasonality.</p> <p>Inherits attributes from <code>StateVariable</code>.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@dataclass\nclass Schedule(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that are functions of real-world\n    dates -- for example, contact matrices (which depend on the day of\n    the week and whether the current day is a holiday), historical\n    vaccination data, and seasonality.\n\n    Inherits attributes from `StateVariable`.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 timeseries_df: Optional[dict] = None):\n        \"\"\"\n        Args:\n            init_val (Optional[np.ndarray | float]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                has a \"date\" column with strings in format `\"YYYY-MM-DD\"`\n                of consecutive calendar days, and other columns\n                corresponding to values on those days\n        \"\"\"\n\n        super().__init__(init_val)\n        self.timeseries_df = timeseries_df\n\n    @abstractmethod\n    def update_current_val(self,\n                           params: SubpopParams,\n                           current_date: datetime.date) -&gt; None:\n        \"\"\"\n        Subpop classes must provide a concrete implementation of\n        updating `self.current_val` in-place.\n\n        Args:\n            params (SubpopParams):\n                fixed parameters of subpopulation model.\n            current_date (date):\n                real-world date corresponding to\n                model's current simulation day.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Schedule.__init__","title":"<code>__init__(init_val: Optional[np.ndarray | float] = None, timeseries_df: Optional[dict] = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[ndarray | float]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>has a \"date\" column with strings in format <code>\"YYYY-MM-DD\"</code> of consecutive calendar days, and other columns corresponding to values on those days</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[np.ndarray | float] = None,\n             timeseries_df: Optional[dict] = None):\n    \"\"\"\n    Args:\n        init_val (Optional[np.ndarray | float]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            has a \"date\" column with strings in format `\"YYYY-MM-DD\"`\n            of consecutive calendar days, and other columns\n            corresponding to values on those days\n    \"\"\"\n\n    super().__init__(init_val)\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.Schedule.update_current_val","title":"<code>update_current_val(params: SubpopParams, current_date: datetime.date) -&gt; None</code>","text":"<p>Subpop classes must provide a concrete implementation of updating <code>self.current_val</code> in-place.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>SubpopParams</code> <p>fixed parameters of subpopulation model.</p> required <code>current_date</code> <code>date</code> <p>real-world date corresponding to model's current simulation day.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self,\n                       params: SubpopParams,\n                       current_date: datetime.date) -&gt; None:\n    \"\"\"\n    Subpop classes must provide a concrete implementation of\n    updating `self.current_val` in-place.\n\n    Args:\n        params (SubpopParams):\n            fixed parameters of subpopulation model.\n        current_date (date):\n            real-world date corresponding to\n            model's current simulation day.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.StateVariable","title":"<code>StateVariable</code>","text":"<p>Parent class of <code>InteractionTerm</code>, <code>Compartment</code>, <code>EpiMetric</code>, <code>DynamicVal</code>, and <code>Schedule</code> classes. All subclasses have the common attributes <code>self.init_val</code> and <code>self.current_val</code>.</p> <p>Attributes:</p> Name Type Description <code>init_val</code> <code>ndarray</code> <p>holds initial value of <code>StateVariable</code> for age-risk groups.</p> <code>current_val</code> <code>ndarray</code> <p>same size as <code>self.init_val</code>, holds current value of <code>StateVariable</code> for age-risk groups.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of <code>self.current_val</code>, holds history of compartment states for age-risk groups -- element t corresponds to previous <code>self.current_val</code> value at end of simulation day t.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class StateVariable:\n    \"\"\"\n    Parent class of `InteractionTerm`, `Compartment`, `EpiMetric`,\n    `DynamicVal`, and `Schedule` classes. All subclasses have the\n    common attributes `self.init_val` and `self.current_val`.\n\n    Attributes:\n        init_val (np.ndarray):\n            holds initial value of `StateVariable` for age-risk groups.\n        current_val (np.ndarray):\n            same size as `self.init_val`, holds current value of `StateVariable`\n            for age-risk groups.\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of `self.current_val`, holds\n            history of compartment states for age-risk groups --\n            element t corresponds to previous `self.current_val` value at\n            end of simulation day t.\n    \"\"\"\n\n    def __init__(self, init_val=None):\n        self.init_val = init_val\n        self.current_val = copy.deepcopy(init_val)\n        self.history_vals_list = []\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending `self.current_val` attribute\n            to `self.history_vals_list` in place.\n\n        Deep copying is CRUCIAL because `self.current_val` is a mutable\n            `np.ndarray` -- without deep copying, `self.history_vals_list` would\n            have the same value for all elements.\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets `self.current_val` to `self.init_val`\n        and resets `self.history_vals_list` attribute to empty list.\n        \"\"\"\n\n        self.current_val = copy.deepcopy(self.init_val)\n        self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.StateVariable.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets <code>self.current_val</code> to <code>self.init_val</code> and resets <code>self.history_vals_list</code> attribute to empty list.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets `self.current_val` to `self.init_val`\n    and resets `self.history_vals_list` attribute to empty list.\n    \"\"\"\n\n    self.current_val = copy.deepcopy(self.init_val)\n    self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.StateVariable.save_history","title":"<code>save_history() -&gt; None</code>","text":"<p>Saves current value to history by appending <code>self.current_val</code> attribute     to <code>self.history_vals_list</code> in place.</p> <p>Deep copying is CRUCIAL because <code>self.current_val</code> is a mutable     <code>np.ndarray</code> -- without deep copying, <code>self.history_vals_list</code> would     have the same value for all elements.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending `self.current_val` attribute\n        to `self.history_vals_list` in place.\n\n    Deep copying is CRUCIAL because `self.current_val` is a mutable\n        `np.ndarray` -- without deep copying, `self.history_vals_list` would\n        have the same value for all elements.\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel","title":"<code>SubpopModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Contains and manages all necessary components for simulating a compartmental model for a given subpopulation.</p> <p>Each <code>SubpopModel</code> instance includes compartments, epi metrics, dynamic vals, a data container for the current simulation state, transition variables and transition variable groups, epidemiological parameters, simulation experiment configuration parameters, and a random number generator.</p> <p>All city-level subpopulation models, regardless of disease type and compartment/transition structure, are instances of this class.</p> <p>When creating an instance, the order of elements does not matter within <code>self.compartments</code>, <code>self.epi_metrics</code>, <code>self.dynamic_vals</code>, <code>self.transition_variables</code>, and <code>self.transition_variable_groups</code>. The \"flow\" and \"physics\" information are stored on the objects.</p> <p>Attributes:</p> Name Type Description <code>interaction_terms</code> <code>objdict</code> <p>objdict of all the subpop model's <code>InteractionTerm</code> instances.</p> <code>compartments</code> <code>objdict</code> <p>objdict of all the subpop model's <code>Compartment</code> instances.</p> <code>transition_variables</code> <code>objdict</code> <p>objdict of all the subpop model's <code>TransitionVariable</code> instances.</p> <code>transition_variable_groups</code> <code>objdict</code> <p>objdict of all the subpop model's <code>TransitionVariableGroup</code> instances.</p> <code>epi_metrics</code> <code>objdict</code> <p>objdict of all the subpop model's <code>EpiMetric</code> instances.</p> <code>dynamic_vals</code> <code>objdict</code> <p>objdict of all the subpop model's <code>DynamicVal</code> instances.</p> <code>schedules</code> <code>objdict</code> <p>objdict of all the subpop model's <code>Schedule</code> instances.</p> <code>current_simulation_day</code> <code>int</code> <p>tracks current simulation day -- incremented by +1 when <code>config.timesteps_per_day</code> discretized timesteps have completed.</p> <code>current_real_date</code> <code>date</code> <p>tracks real-world date -- advanced by +1 day when <code>config.timesteps_per_day</code> discretized timesteps have completed.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class SubpopModel(ABC):\n    \"\"\"\n    Contains and manages all necessary components for\n    simulating a compartmental model for a given subpopulation.\n\n    Each `SubpopModel` instance includes compartments,\n    epi metrics, dynamic vals, a data container for the current simulation\n    state, transition variables and transition variable groups,\n    epidemiological parameters, simulation experiment configuration\n    parameters, and a random number generator.\n\n    All city-level subpopulation models, regardless of disease type and\n    compartment/transition structure, are instances of this class.\n\n    When creating an instance, the order of elements does not matter\n    within `self.compartments`, `self.epi_metrics`, `self.dynamic_vals`,\n    `self.transition_variables`, and `self.transition_variable_groups`.\n    The \"flow\" and \"physics\" information are stored on the objects.\n\n    Attributes:\n        interaction_terms (sc.objdict):\n            objdict of all the subpop model's `InteractionTerm` instances.\n        compartments (sc.objdict):\n            objdict of all the subpop model's `Compartment` instances.\n        transition_variables (sc.objdict):\n            objdict of all the subpop model's `TransitionVariable` instances.\n        transition_variable_groups (sc.objdict):\n            objdict of all the subpop model's `TransitionVariableGroup` instances.\n        epi_metrics (sc.objdict):\n            objdict of all the subpop model's `EpiMetric` instances.\n        dynamic_vals (sc.objdict):\n            objdict of all the subpop model's `DynamicVal` instances.\n        schedules (sc.objdict):\n            objdict of all the subpop model's `Schedule` instances.\n        current_simulation_day (int):\n            tracks current simulation day -- incremented by +1\n            when `config.timesteps_per_day` discretized timesteps\n            have completed.\n        current_real_date (datetime.date):\n            tracks real-world date -- advanced by +1 day when\n            `config.timesteps_per_day` discretized timesteps\n            have completed.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 state: SubpopState,\n                 params: SubpopParams,\n                 config: Config,\n                 RNG: np.random.Generator,\n                 name: str = \"\",\n                 metapop_model: MetapopModel = None):\n\n        \"\"\"\n        Params:\n            state (SubpopState):\n                holds current values of `SubpopModel`'s state variables.\n            params (SubpopParams):\n                data container for the model's epidemiological parameters,\n                such as the \"Greek letters\" characterizing sojourn times\n                in compartments.\n            config (Config):\n                data container for the model's simulation configuration values.\n            RNG (np.random.Generator):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            name (str):\n                unique identifier of `SubpopModel`.\n            metapop_model (Optional[MetapopModel]):\n                if not `None`, is the `MetapopModel` instance\n                associated with this `SubpopModel`.\n        \"\"\"\n\n        self.state = copy.deepcopy(state)\n        self.params = copy.deepcopy(params)\n        self.config = copy.deepcopy(config)\n\n        self.RNG = RNG\n\n        self.current_simulation_day = 0\n        self.start_real_date = self.get_start_real_date()\n        self.current_real_date = self.start_real_date\n\n        self.metapop_model = None\n        self.name = name\n\n        self.interaction_terms = self.create_interaction_terms()\n        self.compartments = self.create_compartments()\n        self.transition_variables = self.create_transition_variables()\n        self.transition_variable_groups = self.create_transition_variable_groups()\n\n        # Some epi metrics depend on transition variables, so\n        #   set up epi metrics after transition variables\n        self.epi_metrics = self.create_epi_metrics()\n        self.dynamic_vals = self.create_dynamic_vals()\n        self.schedules = self.create_schedules()\n\n        self.all_state_variables = {**self.interaction_terms,\n                                    **self.compartments,\n                                    **self.epi_metrics,\n                                    **self.dynamic_vals,\n                                    **self.schedules}\n\n        # The model's state also has access to the model's\n        #   compartments, epi_metrics, dynamic_vals, and schedules --\n        #   so that state can easily retrieve each object's\n        #   current_val and store it\n        self.state.interaction_terms = self.interaction_terms\n        self.state.compartments = self.compartments\n        self.state.epi_metrics = self.epi_metrics\n        self.state.dynamic_vals = self.dynamic_vals\n        self.state.schedules = self.schedules\n\n        self.params.total_pop_age_risk = self.compute_total_pop_age_risk()\n\n    def compute_total_pop_age_risk(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns:\n            np.ndarray:\n                |A| x |R| array, where |A| is the number of age groups\n                and |R| is the number of risk groups, corresponding to\n                total population for that age-risk group (summed\n                over all compartments in the subpop model).\n        \"\"\"\n\n        total_pop_age_risk = np.zeros((self.params.num_age_groups,\n                                       self.params.num_risk_groups))\n\n        # At initialization (before simulation is run), each\n        #   compartment's current val is equivalent to the initial val\n        #   specified in the state variables' init val JSON.\n        for compartment in self.compartments.values():\n            total_pop_age_risk += compartment.current_val\n\n        return total_pop_age_risk\n\n    def get_start_real_date(self):\n        \"\"\"\n        Fetches `start_real_date` from `self.config` -- converts to\n            proper datetime.date format if originally given as\n            string.\n\n        Returns:\n            start_real_date (datetime.date):\n                real-world date that corresponds to start of\n                simulation.\n        \"\"\"\n\n        start_real_date = self.config.start_real_date\n\n        if not isinstance(start_real_date, datetime.date):\n            try:\n                start_real_date = \\\n                    datetime.datetime.strptime(start_real_date, \"%Y-%m-%d\").date()\n            except ValueError:\n                print(\"Error: The date format should be YYYY-MM-DD.\")\n\n        return start_real_date\n\n    @abstractmethod\n    def create_interaction_terms(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_compartments(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_transition_variables(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_transition_variable_groups(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_epi_metrics(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_dynamic_vals(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_schedules(self) -&gt; sc.objdict:\n        pass\n\n    def modify_random_seed(self, new_seed_number) -&gt; None:\n        \"\"\"\n        Modifies model's `self.RNG` attribute in-place to new generator\n        seeded at `new_seed_number`.\n\n        Args:\n            new_seed_number (int):\n                used to re-seed model's random number generator.\n        \"\"\"\n\n        self._bit_generator = np.random.MT19937(seed=new_seed_number)\n        self.RNG = np.random.Generator(self._bit_generator)\n\n    def simulate_until_day(self,\n                           simulation_end_day: int) -&gt; None:\n        \"\"\"\n        Advance simulation model time until `simulation_end_day`.\n\n        Advance time by iterating through simulation days,\n        which are simulated by iterating through discretized\n        timesteps.\n\n        Save daily simulation data as history on each `Compartment`\n        instance.\n\n        Args:\n            simulation_end_day (positive int):\n                stop simulation at `simulation_end_day` (i.e. exclusive,\n                simulate up to but not including `simulation_end_day`).\n        \"\"\"\n\n        if self.current_simulation_day &gt; simulation_end_day:\n            raise SubpopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                   f\"exceeds last simulation day ({simulation_end_day}).\")\n\n        save_daily_history = self.config.save_daily_history\n        timesteps_per_day = self.config.timesteps_per_day\n\n        # simulation_end_day is exclusive endpoint\n        while self.current_simulation_day &lt; simulation_end_day:\n\n            self.prepare_daily_state()\n\n            self.simulate_timesteps(timesteps_per_day)\n\n            if save_daily_history:\n                self.save_daily_history()\n\n            self.increment_simulation_day()\n\n    def simulate_timesteps(self,\n                           num_timesteps: int) -&gt; None:\n        \"\"\"\n        Subroutine for `self.simulate_until_day`.\n\n        Iterates through discretized timesteps to simulate next\n        simulation day. Granularity of discretization is given by\n        attribute `self.config.timesteps_per_day`.\n\n        Properly scales transition variable realizations and changes\n        in dynamic vals by specified timesteps per day.\n\n        Args:\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n        \"\"\"\n\n        for timestep in range(num_timesteps):\n\n            self.update_transition_rates()\n\n            self.sample_transitions()\n\n            self.update_epi_metrics()\n\n            self.update_compartments()\n\n            self.state.sync_to_current_vals(self.epi_metrics)\n            self.state.sync_to_current_vals(self.compartments)\n\n    def prepare_daily_state(self) -&gt; None:\n        \"\"\"\n        At beginning of each day, update current value of\n        interaction terms, schedules, dynamic values --\n        note that these are only updated once a day, not\n        for every discretized timestep.\n        \"\"\"\n\n        subpop_state = self.state\n        subpop_params = self.params\n        current_real_date = self.current_real_date\n\n        # Important note: this order of updating is important,\n        #   because schedules do not depend on other state variables,\n        #   but dynamic vals may depend on schedules\n        # Interaction terms may depend on both schedules\n        #   and dynamic vals (but interaction terms are updated by\n        #   the InterSubpopRepo, not on individual SubpopModel\n        #   instances).\n\n        schedules = self.schedules\n        dynamic_vals = self.dynamic_vals\n\n        # Update schedules for current day\n        for schedule in schedules.values():\n            schedule.update_current_val(subpop_params,\n                                        current_real_date)\n\n        self.state.sync_to_current_vals(schedules)\n\n        # Update dynamic values for current day\n        for dval in dynamic_vals.values():\n            if dval.is_enabled:\n                dval.update_current_val(subpop_state, subpop_params)\n\n        self.state.sync_to_current_vals(dynamic_vals)\n\n    def update_epi_metrics(self) -&gt; None:\n        \"\"\"\n        Update current value attribute on each associated\n            `EpiMetric` instance.\n        \"\"\"\n\n        state = self.state\n        params = self.params\n        timesteps_per_day = self.config.timesteps_per_day\n\n        for metric in self.epi_metrics.values():\n            metric.change_in_current_val = \\\n                metric.get_change_in_current_val(state,\n                                                 params,\n                                                 timesteps_per_day)\n            metric.update_current_val()\n\n    def update_transition_rates(self) -&gt; None:\n        \"\"\"\n        Compute current transition rates for each transition variable,\n            and store this updated value on each variable's\n            current_rate attribute.\n        \"\"\"\n\n        state = self.state\n        params = self.params\n\n        for tvar in self.transition_variables.values():\n            tvar.current_rate = tvar.get_current_rate(state, params)\n\n    def sample_transitions(self) -&gt; None:\n        \"\"\"\n        For each transition variable, sample a random realization\n            using its current rate. Handle jointly distributed transition\n            variables first (using `TransitionVariableGroup` logic), then\n            handle marginally distributed transition variables.\n            Use `SubpopModel`'s `RNG` to generate random variables.\n        \"\"\"\n\n        RNG = self.RNG\n        timesteps_per_day = self.config.timesteps_per_day\n\n        # Obtain transition variable realizations for jointly distributed transition variables\n        #   (i.e. when there are multiple transition variable outflows from an epi compartment)\n        for tvargroup in self.transition_variable_groups.values():\n            tvargroup.current_vals_list = tvargroup.get_joint_realization(RNG,\n                                                                          timesteps_per_day)\n            tvargroup.update_transition_variable_realizations()\n\n        # Obtain transition variable realizations for marginally distributed transition variables\n        #   (i.e. when there is only one transition variable outflow from an epi compartment)\n        # If transition variable is jointly distributed, then its realization has already\n        #   been computed by its transition variable group container previously,\n        #   so skip the marginal computation\n        for tvar in self.transition_variables.values():\n            if not tvar.is_jointly_distributed:\n                tvar.current_val = tvar.get_realization(RNG, timesteps_per_day)\n\n    def update_compartments(self) -&gt; None:\n        \"\"\"\n        Update current value of each `Compartment`, by\n            looping through all `TransitionVariable` instances\n            and subtracting/adding their current values\n            from origin/destination compartments respectively.\n        \"\"\"\n\n        for tvar in self.transition_variables.values():\n            tvar.update_origin_outflow()\n            tvar.update_destination_inflow()\n\n        for compartment in self.compartments.values():\n            compartment.update_current_val()\n\n            # After updating the compartment's current value,\n            #   reset its inflow and outflow attributes, to\n            #   prepare for the next iteration.\n            compartment.reset_inflow()\n            compartment.reset_outflow()\n\n    def increment_simulation_day(self) -&gt; None:\n        \"\"\"\n        Move day counters to next simulation day, both\n            for integer simulation day and real date.\n        \"\"\"\n\n        self.current_simulation_day += 1\n        self.current_real_date += datetime.timedelta(days=1)\n\n    def save_daily_history(self) -&gt; None:\n        \"\"\"\n        Update history at end of each day, not at end of every\n           discretization timestep, to be efficient.\n        Update history of state variables other than `Schedule`\n           instances -- schedules do not have history\n           `TransitionVariableGroup` instances also do not\n           have history, so do not include.\n        \"\"\"\n        for svar in self.interaction_terms.values() + \\\n                    self.compartments.values() + \\\n                    self.epi_metrics.values() + \\\n                    self.dynamic_vals.values():\n            svar.save_history()\n\n    def reset_simulation(self) -&gt; None:\n        \"\"\"\n        Reset simulation in-place. Subsequent method calls of\n        `self.simulate_until_day` start from day 0, with original\n        day 0 state.\n\n        Returns `self.current_simulation_day` to 0.\n        Restores state values to initial values.\n        Clears history on model's state variables.\n        Resets transition variables' `current_val` attribute to 0.\n\n        WARNING:\n            DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n            ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n            WHERE IT LEFT OFF.\n\n        Use method `self.modify_random_seed` to reset model's `RNG` to its\n        initial starting seed.\n        \"\"\"\n\n        self.current_simulation_day = 0\n        self.current_real_date = self.start_real_date\n\n        # AGAIN, MUST BE CAREFUL ABOUT MUTABLE NUMPY ARRAYS -- MUST USE DEEP COPY\n        for svar in self.all_state_variables.values():\n            setattr(svar, \"current_val\", copy.deepcopy(svar.init_val))\n\n        self.state.sync_to_current_vals(self.all_state_variables)\n        self.reset()\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets `self.history_vals_list` attribute of each `InteractionTerm`,\n            `Compartment`, `EpiMetric`, and `DynamicVal` to an empty list.\n            Clears current rates and current values of\n            `TransitionVariable` and `TransitionVariableGroup` instances.\n        \"\"\"\n\n        # Schedules do not have history since they are deterministic\n        for svar in self.all_state_variables.values():\n            svar.reset()\n\n        for tvar in self.transition_variables.values():\n            tvar.current_rate = None\n            tvar.current_val = 0.0\n\n        for tvargroup in self.transition_variable_groups.values():\n            tvargroup.current_vals_list = []\n\n    def find_name_by_compartment(self,\n                                 target_compartment: Compartment) -&gt; str:\n        \"\"\"\n        Given `Compartment`, returns name of that `Compartment`.\n\n        Args:\n            target_compartment (Compartment):\n                Compartment object with a name to look up\n\n        Returns:\n            str:\n                Compartment name, given by the key to look\n                it up in the `SubpopModel`'s compartments objdict\n        \"\"\"\n\n        for name, compartment in self.compartments.items():\n            if compartment == target_compartment:\n                return name\n\n    def display(self) -&gt; None:\n        \"\"\"\n        Prints structure of model (compartments and linkages),\n            transition variables, epi metrics, schedules,\n            and dynamic values.\n        \"\"\"\n\n        # We build origin_dict so that we can print\n        #   compartment transitions in an easy-to-read way --\n        #   for connections between origin --&gt; destination,\n        #   we print all connections with the same origin\n        #   consecutively\n        origin_dict = defaultdict(list)\n\n        # Each key in origin_dict is a string corresponding to\n        #   an origin (Compartment) name\n        # Each val in origin_dict is a list of 3-tuples\n        # Each 3-tuple has the name of a destination (Compartment)\n        #   connected to the given origin, the name of the transition\n        #   variable connecting the origin and destination,\n        #   and Boolean indicating if the transition variable is jointly\n        #   distributed\n        for tvar_name, tvar in self.transition_variables.items():\n            origin_dict[self.find_name_by_compartment(tvar.origin)].append(\n                (self.find_name_by_compartment(tvar.destination),\n                 tvar_name, tvar.is_jointly_distributed))\n\n        print(f\"\\n&gt;&gt;&gt; Displaying SubpopModel {self.name}\")\n\n        print(\"\\nCompartments and transition variables\")\n        print(\"=====================================\")\n        for origin_name, origin in self.compartments.items():\n            for output in origin_dict[origin_name]:\n                if output[2]:\n                    print(f\"{origin_name} --&gt; {output[0]}, via {output[1]}: jointly distributed\")\n                else:\n                    print(f\"{origin_name} --&gt; {output[0]}, via {output[1]}\")\n\n        print(\"\\nEpi metrics\")\n        print(\"===========\")\n        for name in self.epi_metrics.keys():\n            print(f\"{name}\")\n\n        print(\"\\nSchedules\")\n        print(\"=========\")\n        for name in self.schedules.keys():\n            print(f\"{name}\")\n\n        print(\"\\nDynamic values\")\n        print(\"==============\")\n        for name, dynamic_val in self.dynamic_vals.items():\n            if dynamic_val.is_enabled:\n                print(f\"{name}: enabled\")\n            else:\n                print(f\"{name}: disabled\")\n        print(\"\\n\")\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.__init__","title":"<code>__init__(state: SubpopState, params: SubpopParams, config: Config, RNG: np.random.Generator, name: str = '', metapop_model: MetapopModel = None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds current values of <code>SubpopModel</code>'s state variables.</p> required <code>params</code> <code>SubpopParams</code> <p>data container for the model's epidemiological parameters, such as the \"Greek letters\" characterizing sojourn times in compartments.</p> required <code>config</code> <code>Config</code> <p>data container for the model's simulation configuration values.</p> required <code>RNG</code> <code>Generator</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>name</code> <code>str</code> <p>unique identifier of <code>SubpopModel</code>.</p> <code>''</code> <code>metapop_model</code> <code>Optional[MetapopModel]</code> <p>if not <code>None</code>, is the <code>MetapopModel</code> instance associated with this <code>SubpopModel</code>.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             state: SubpopState,\n             params: SubpopParams,\n             config: Config,\n             RNG: np.random.Generator,\n             name: str = \"\",\n             metapop_model: MetapopModel = None):\n\n    \"\"\"\n    Params:\n        state (SubpopState):\n            holds current values of `SubpopModel`'s state variables.\n        params (SubpopParams):\n            data container for the model's epidemiological parameters,\n            such as the \"Greek letters\" characterizing sojourn times\n            in compartments.\n        config (Config):\n            data container for the model's simulation configuration values.\n        RNG (np.random.Generator):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        name (str):\n            unique identifier of `SubpopModel`.\n        metapop_model (Optional[MetapopModel]):\n            if not `None`, is the `MetapopModel` instance\n            associated with this `SubpopModel`.\n    \"\"\"\n\n    self.state = copy.deepcopy(state)\n    self.params = copy.deepcopy(params)\n    self.config = copy.deepcopy(config)\n\n    self.RNG = RNG\n\n    self.current_simulation_day = 0\n    self.start_real_date = self.get_start_real_date()\n    self.current_real_date = self.start_real_date\n\n    self.metapop_model = None\n    self.name = name\n\n    self.interaction_terms = self.create_interaction_terms()\n    self.compartments = self.create_compartments()\n    self.transition_variables = self.create_transition_variables()\n    self.transition_variable_groups = self.create_transition_variable_groups()\n\n    # Some epi metrics depend on transition variables, so\n    #   set up epi metrics after transition variables\n    self.epi_metrics = self.create_epi_metrics()\n    self.dynamic_vals = self.create_dynamic_vals()\n    self.schedules = self.create_schedules()\n\n    self.all_state_variables = {**self.interaction_terms,\n                                **self.compartments,\n                                **self.epi_metrics,\n                                **self.dynamic_vals,\n                                **self.schedules}\n\n    # The model's state also has access to the model's\n    #   compartments, epi_metrics, dynamic_vals, and schedules --\n    #   so that state can easily retrieve each object's\n    #   current_val and store it\n    self.state.interaction_terms = self.interaction_terms\n    self.state.compartments = self.compartments\n    self.state.epi_metrics = self.epi_metrics\n    self.state.dynamic_vals = self.dynamic_vals\n    self.state.schedules = self.schedules\n\n    self.params.total_pop_age_risk = self.compute_total_pop_age_risk()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.compute_total_pop_age_risk","title":"<code>compute_total_pop_age_risk() -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: |A| x |R| array, where |A| is the number of age groups and |R| is the number of risk groups, corresponding to total population for that age-risk group (summed over all compartments in the subpop model).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def compute_total_pop_age_risk(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray:\n            |A| x |R| array, where |A| is the number of age groups\n            and |R| is the number of risk groups, corresponding to\n            total population for that age-risk group (summed\n            over all compartments in the subpop model).\n    \"\"\"\n\n    total_pop_age_risk = np.zeros((self.params.num_age_groups,\n                                   self.params.num_risk_groups))\n\n    # At initialization (before simulation is run), each\n    #   compartment's current val is equivalent to the initial val\n    #   specified in the state variables' init val JSON.\n    for compartment in self.compartments.values():\n        total_pop_age_risk += compartment.current_val\n\n    return total_pop_age_risk\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.display","title":"<code>display() -&gt; None</code>","text":"<p>Prints structure of model (compartments and linkages),     transition variables, epi metrics, schedules,     and dynamic values.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def display(self) -&gt; None:\n    \"\"\"\n    Prints structure of model (compartments and linkages),\n        transition variables, epi metrics, schedules,\n        and dynamic values.\n    \"\"\"\n\n    # We build origin_dict so that we can print\n    #   compartment transitions in an easy-to-read way --\n    #   for connections between origin --&gt; destination,\n    #   we print all connections with the same origin\n    #   consecutively\n    origin_dict = defaultdict(list)\n\n    # Each key in origin_dict is a string corresponding to\n    #   an origin (Compartment) name\n    # Each val in origin_dict is a list of 3-tuples\n    # Each 3-tuple has the name of a destination (Compartment)\n    #   connected to the given origin, the name of the transition\n    #   variable connecting the origin and destination,\n    #   and Boolean indicating if the transition variable is jointly\n    #   distributed\n    for tvar_name, tvar in self.transition_variables.items():\n        origin_dict[self.find_name_by_compartment(tvar.origin)].append(\n            (self.find_name_by_compartment(tvar.destination),\n             tvar_name, tvar.is_jointly_distributed))\n\n    print(f\"\\n&gt;&gt;&gt; Displaying SubpopModel {self.name}\")\n\n    print(\"\\nCompartments and transition variables\")\n    print(\"=====================================\")\n    for origin_name, origin in self.compartments.items():\n        for output in origin_dict[origin_name]:\n            if output[2]:\n                print(f\"{origin_name} --&gt; {output[0]}, via {output[1]}: jointly distributed\")\n            else:\n                print(f\"{origin_name} --&gt; {output[0]}, via {output[1]}\")\n\n    print(\"\\nEpi metrics\")\n    print(\"===========\")\n    for name in self.epi_metrics.keys():\n        print(f\"{name}\")\n\n    print(\"\\nSchedules\")\n    print(\"=========\")\n    for name in self.schedules.keys():\n        print(f\"{name}\")\n\n    print(\"\\nDynamic values\")\n    print(\"==============\")\n    for name, dynamic_val in self.dynamic_vals.items():\n        if dynamic_val.is_enabled:\n            print(f\"{name}: enabled\")\n        else:\n            print(f\"{name}: disabled\")\n    print(\"\\n\")\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.find_name_by_compartment","title":"<code>find_name_by_compartment(target_compartment: Compartment) -&gt; str</code>","text":"<p>Given <code>Compartment</code>, returns name of that <code>Compartment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target_compartment</code> <code>Compartment</code> <p>Compartment object with a name to look up</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Compartment name, given by the key to look it up in the <code>SubpopModel</code>'s compartments objdict</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def find_name_by_compartment(self,\n                             target_compartment: Compartment) -&gt; str:\n    \"\"\"\n    Given `Compartment`, returns name of that `Compartment`.\n\n    Args:\n        target_compartment (Compartment):\n            Compartment object with a name to look up\n\n    Returns:\n        str:\n            Compartment name, given by the key to look\n            it up in the `SubpopModel`'s compartments objdict\n    \"\"\"\n\n    for name, compartment in self.compartments.items():\n        if compartment == target_compartment:\n            return name\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.get_start_real_date","title":"<code>get_start_real_date()</code>","text":"<p>Fetches <code>start_real_date</code> from <code>self.config</code> -- converts to     proper datetime.date format if originally given as     string.</p> <p>Returns:</p> Name Type Description <code>start_real_date</code> <code>date</code> <p>real-world date that corresponds to start of simulation.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_start_real_date(self):\n    \"\"\"\n    Fetches `start_real_date` from `self.config` -- converts to\n        proper datetime.date format if originally given as\n        string.\n\n    Returns:\n        start_real_date (datetime.date):\n            real-world date that corresponds to start of\n            simulation.\n    \"\"\"\n\n    start_real_date = self.config.start_real_date\n\n    if not isinstance(start_real_date, datetime.date):\n        try:\n            start_real_date = \\\n                datetime.datetime.strptime(start_real_date, \"%Y-%m-%d\").date()\n        except ValueError:\n            print(\"Error: The date format should be YYYY-MM-DD.\")\n\n    return start_real_date\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.increment_simulation_day","title":"<code>increment_simulation_day() -&gt; None</code>","text":"<p>Move day counters to next simulation day, both     for integer simulation day and real date.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def increment_simulation_day(self) -&gt; None:\n    \"\"\"\n    Move day counters to next simulation day, both\n        for integer simulation day and real date.\n    \"\"\"\n\n    self.current_simulation_day += 1\n    self.current_real_date += datetime.timedelta(days=1)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.modify_random_seed","title":"<code>modify_random_seed(new_seed_number) -&gt; None</code>","text":"<p>Modifies model's <code>self.RNG</code> attribute in-place to new generator seeded at <code>new_seed_number</code>.</p> <p>Parameters:</p> Name Type Description Default <code>new_seed_number</code> <code>int</code> <p>used to re-seed model's random number generator.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def modify_random_seed(self, new_seed_number) -&gt; None:\n    \"\"\"\n    Modifies model's `self.RNG` attribute in-place to new generator\n    seeded at `new_seed_number`.\n\n    Args:\n        new_seed_number (int):\n            used to re-seed model's random number generator.\n    \"\"\"\n\n    self._bit_generator = np.random.MT19937(seed=new_seed_number)\n    self.RNG = np.random.Generator(self._bit_generator)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.prepare_daily_state","title":"<code>prepare_daily_state() -&gt; None</code>","text":"<p>At beginning of each day, update current value of interaction terms, schedules, dynamic values -- note that these are only updated once a day, not for every discretized timestep.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def prepare_daily_state(self) -&gt; None:\n    \"\"\"\n    At beginning of each day, update current value of\n    interaction terms, schedules, dynamic values --\n    note that these are only updated once a day, not\n    for every discretized timestep.\n    \"\"\"\n\n    subpop_state = self.state\n    subpop_params = self.params\n    current_real_date = self.current_real_date\n\n    # Important note: this order of updating is important,\n    #   because schedules do not depend on other state variables,\n    #   but dynamic vals may depend on schedules\n    # Interaction terms may depend on both schedules\n    #   and dynamic vals (but interaction terms are updated by\n    #   the InterSubpopRepo, not on individual SubpopModel\n    #   instances).\n\n    schedules = self.schedules\n    dynamic_vals = self.dynamic_vals\n\n    # Update schedules for current day\n    for schedule in schedules.values():\n        schedule.update_current_val(subpop_params,\n                                    current_real_date)\n\n    self.state.sync_to_current_vals(schedules)\n\n    # Update dynamic values for current day\n    for dval in dynamic_vals.values():\n        if dval.is_enabled:\n            dval.update_current_val(subpop_state, subpop_params)\n\n    self.state.sync_to_current_vals(dynamic_vals)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets <code>self.history_vals_list</code> attribute of each <code>InteractionTerm</code>,     <code>Compartment</code>, <code>EpiMetric</code>, and <code>DynamicVal</code> to an empty list.     Clears current rates and current values of     <code>TransitionVariable</code> and <code>TransitionVariableGroup</code> instances.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets `self.history_vals_list` attribute of each `InteractionTerm`,\n        `Compartment`, `EpiMetric`, and `DynamicVal` to an empty list.\n        Clears current rates and current values of\n        `TransitionVariable` and `TransitionVariableGroup` instances.\n    \"\"\"\n\n    # Schedules do not have history since they are deterministic\n    for svar in self.all_state_variables.values():\n        svar.reset()\n\n    for tvar in self.transition_variables.values():\n        tvar.current_rate = None\n        tvar.current_val = 0.0\n\n    for tvargroup in self.transition_variable_groups.values():\n        tvargroup.current_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.reset_simulation","title":"<code>reset_simulation() -&gt; None</code>","text":"<p>Reset simulation in-place. Subsequent method calls of <code>self.simulate_until_day</code> start from day 0, with original day 0 state.</p> <p>Returns <code>self.current_simulation_day</code> to 0. Restores state values to initial values. Clears history on model's state variables. Resets transition variables' <code>current_val</code> attribute to 0.</p> WARNING <p>DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE WHERE IT LEFT OFF.</p> <p>Use method <code>self.modify_random_seed</code> to reset model's <code>RNG</code> to its initial starting seed.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset_simulation(self) -&gt; None:\n    \"\"\"\n    Reset simulation in-place. Subsequent method calls of\n    `self.simulate_until_day` start from day 0, with original\n    day 0 state.\n\n    Returns `self.current_simulation_day` to 0.\n    Restores state values to initial values.\n    Clears history on model's state variables.\n    Resets transition variables' `current_val` attribute to 0.\n\n    WARNING:\n        DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n        ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n        WHERE IT LEFT OFF.\n\n    Use method `self.modify_random_seed` to reset model's `RNG` to its\n    initial starting seed.\n    \"\"\"\n\n    self.current_simulation_day = 0\n    self.current_real_date = self.start_real_date\n\n    # AGAIN, MUST BE CAREFUL ABOUT MUTABLE NUMPY ARRAYS -- MUST USE DEEP COPY\n    for svar in self.all_state_variables.values():\n        setattr(svar, \"current_val\", copy.deepcopy(svar.init_val))\n\n    self.state.sync_to_current_vals(self.all_state_variables)\n    self.reset()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.sample_transitions","title":"<code>sample_transitions() -&gt; None</code>","text":"<p>For each transition variable, sample a random realization     using its current rate. Handle jointly distributed transition     variables first (using <code>TransitionVariableGroup</code> logic), then     handle marginally distributed transition variables.     Use <code>SubpopModel</code>'s <code>RNG</code> to generate random variables.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def sample_transitions(self) -&gt; None:\n    \"\"\"\n    For each transition variable, sample a random realization\n        using its current rate. Handle jointly distributed transition\n        variables first (using `TransitionVariableGroup` logic), then\n        handle marginally distributed transition variables.\n        Use `SubpopModel`'s `RNG` to generate random variables.\n    \"\"\"\n\n    RNG = self.RNG\n    timesteps_per_day = self.config.timesteps_per_day\n\n    # Obtain transition variable realizations for jointly distributed transition variables\n    #   (i.e. when there are multiple transition variable outflows from an epi compartment)\n    for tvargroup in self.transition_variable_groups.values():\n        tvargroup.current_vals_list = tvargroup.get_joint_realization(RNG,\n                                                                      timesteps_per_day)\n        tvargroup.update_transition_variable_realizations()\n\n    # Obtain transition variable realizations for marginally distributed transition variables\n    #   (i.e. when there is only one transition variable outflow from an epi compartment)\n    # If transition variable is jointly distributed, then its realization has already\n    #   been computed by its transition variable group container previously,\n    #   so skip the marginal computation\n    for tvar in self.transition_variables.values():\n        if not tvar.is_jointly_distributed:\n            tvar.current_val = tvar.get_realization(RNG, timesteps_per_day)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.save_daily_history","title":"<code>save_daily_history() -&gt; None</code>","text":"<p>Update history at end of each day, not at end of every    discretization timestep, to be efficient. Update history of state variables other than <code>Schedule</code>    instances -- schedules do not have history    <code>TransitionVariableGroup</code> instances also do not    have history, so do not include.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def save_daily_history(self) -&gt; None:\n    \"\"\"\n    Update history at end of each day, not at end of every\n       discretization timestep, to be efficient.\n    Update history of state variables other than `Schedule`\n       instances -- schedules do not have history\n       `TransitionVariableGroup` instances also do not\n       have history, so do not include.\n    \"\"\"\n    for svar in self.interaction_terms.values() + \\\n                self.compartments.values() + \\\n                self.epi_metrics.values() + \\\n                self.dynamic_vals.values():\n        svar.save_history()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.simulate_timesteps","title":"<code>simulate_timesteps(num_timesteps: int) -&gt; None</code>","text":"<p>Subroutine for <code>self.simulate_until_day</code>.</p> <p>Iterates through discretized timesteps to simulate next simulation day. Granularity of discretization is given by attribute <code>self.config.timesteps_per_day</code>.</p> <p>Properly scales transition variable realizations and changes in dynamic vals by specified timesteps per day.</p> <p>Parameters:</p> Name Type Description Default <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def simulate_timesteps(self,\n                       num_timesteps: int) -&gt; None:\n    \"\"\"\n    Subroutine for `self.simulate_until_day`.\n\n    Iterates through discretized timesteps to simulate next\n    simulation day. Granularity of discretization is given by\n    attribute `self.config.timesteps_per_day`.\n\n    Properly scales transition variable realizations and changes\n    in dynamic vals by specified timesteps per day.\n\n    Args:\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n    \"\"\"\n\n    for timestep in range(num_timesteps):\n\n        self.update_transition_rates()\n\n        self.sample_transitions()\n\n        self.update_epi_metrics()\n\n        self.update_compartments()\n\n        self.state.sync_to_current_vals(self.epi_metrics)\n        self.state.sync_to_current_vals(self.compartments)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.simulate_until_day","title":"<code>simulate_until_day(simulation_end_day: int) -&gt; None</code>","text":"<p>Advance simulation model time until <code>simulation_end_day</code>.</p> <p>Advance time by iterating through simulation days, which are simulated by iterating through discretized timesteps.</p> <p>Save daily simulation data as history on each <code>Compartment</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_end_day</code> <code>positive int</code> <p>stop simulation at <code>simulation_end_day</code> (i.e. exclusive, simulate up to but not including <code>simulation_end_day</code>).</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def simulate_until_day(self,\n                       simulation_end_day: int) -&gt; None:\n    \"\"\"\n    Advance simulation model time until `simulation_end_day`.\n\n    Advance time by iterating through simulation days,\n    which are simulated by iterating through discretized\n    timesteps.\n\n    Save daily simulation data as history on each `Compartment`\n    instance.\n\n    Args:\n        simulation_end_day (positive int):\n            stop simulation at `simulation_end_day` (i.e. exclusive,\n            simulate up to but not including `simulation_end_day`).\n    \"\"\"\n\n    if self.current_simulation_day &gt; simulation_end_day:\n        raise SubpopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                               f\"exceeds last simulation day ({simulation_end_day}).\")\n\n    save_daily_history = self.config.save_daily_history\n    timesteps_per_day = self.config.timesteps_per_day\n\n    # simulation_end_day is exclusive endpoint\n    while self.current_simulation_day &lt; simulation_end_day:\n\n        self.prepare_daily_state()\n\n        self.simulate_timesteps(timesteps_per_day)\n\n        if save_daily_history:\n            self.save_daily_history()\n\n        self.increment_simulation_day()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.update_compartments","title":"<code>update_compartments() -&gt; None</code>","text":"<p>Update current value of each <code>Compartment</code>, by     looping through all <code>TransitionVariable</code> instances     and subtracting/adding their current values     from origin/destination compartments respectively.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_compartments(self) -&gt; None:\n    \"\"\"\n    Update current value of each `Compartment`, by\n        looping through all `TransitionVariable` instances\n        and subtracting/adding their current values\n        from origin/destination compartments respectively.\n    \"\"\"\n\n    for tvar in self.transition_variables.values():\n        tvar.update_origin_outflow()\n        tvar.update_destination_inflow()\n\n    for compartment in self.compartments.values():\n        compartment.update_current_val()\n\n        # After updating the compartment's current value,\n        #   reset its inflow and outflow attributes, to\n        #   prepare for the next iteration.\n        compartment.reset_inflow()\n        compartment.reset_outflow()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.update_epi_metrics","title":"<code>update_epi_metrics() -&gt; None</code>","text":"<p>Update current value attribute on each associated     <code>EpiMetric</code> instance.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_epi_metrics(self) -&gt; None:\n    \"\"\"\n    Update current value attribute on each associated\n        `EpiMetric` instance.\n    \"\"\"\n\n    state = self.state\n    params = self.params\n    timesteps_per_day = self.config.timesteps_per_day\n\n    for metric in self.epi_metrics.values():\n        metric.change_in_current_val = \\\n            metric.get_change_in_current_val(state,\n                                             params,\n                                             timesteps_per_day)\n        metric.update_current_val()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModel.update_transition_rates","title":"<code>update_transition_rates() -&gt; None</code>","text":"<p>Compute current transition rates for each transition variable,     and store this updated value on each variable's     current_rate attribute.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_transition_rates(self) -&gt; None:\n    \"\"\"\n    Compute current transition rates for each transition variable,\n        and store this updated value on each variable's\n        current_rate attribute.\n    \"\"\"\n\n    state = self.state\n    params = self.params\n\n    for tvar in self.transition_variables.values():\n        tvar.current_rate = tvar.get_current_rate(state, params)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopModelError","title":"<code>SubpopModelError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for subpopulation simulation model errors.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class SubpopModelError(Exception):\n    \"\"\"Custom exceptions for subpopulation simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopParams","title":"<code>SubpopParams</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Data container for pre-specified and fixed epidemiological parameters in model.</p> <p>Assume that <code>SubpopParams</code> fields are constant or piecewise constant throughout the simulation. For variables that are more complicated and time-dependent, use an <code>EpiMetric</code> instead.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@dataclass\nclass SubpopParams(ABC):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in model.\n\n    Assume that `SubpopParams` fields are constant or piecewise\n    constant throughout the simulation. For variables that\n    are more complicated and time-dependent, use an `EpiMetric`\n    instead.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopState","title":"<code>SubpopState</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Holds current values of <code>SubpopModel</code>'s simulation state.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@dataclass\nclass SubpopState(ABC):\n    \"\"\"\n    Holds current values of `SubpopModel`'s simulation state.\n    \"\"\"\n\n    def sync_to_current_vals(self, lookup_dict: dict):\n        \"\"\"\n        Updates `SubpopState`'s attributes according to\n        data in `lookup_dict.` Keys of `lookup_dict` must match\n        names of attributes of `SubpopState` instance.\n        \"\"\"\n\n        for name, item in lookup_dict.items():\n            setattr(self, name, item.current_val)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.SubpopState.sync_to_current_vals","title":"<code>sync_to_current_vals(lookup_dict: dict)</code>","text":"<p>Updates <code>SubpopState</code>'s attributes according to data in <code>lookup_dict.</code> Keys of <code>lookup_dict</code> must match names of attributes of <code>SubpopState</code> instance.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def sync_to_current_vals(self, lookup_dict: dict):\n    \"\"\"\n    Updates `SubpopState`'s attributes according to\n    data in `lookup_dict.` Keys of `lookup_dict` must match\n    names of attributes of `SubpopState` instance.\n    \"\"\"\n\n    for name, item in lookup_dict.items():\n        setattr(self, name, item.current_val)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionTypes","title":"<code>TransitionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class TransitionTypes(str, Enum):\n    BINOMIAL = \"binomial\"\n    BINOMIAL_DETERMINISTIC = \"binomial_deterministic\"\n    BINOMIAL_TAYLOR_APPROX = \"binomial_taylor_approx\"\n    BINOMIAL_TAYLOR_APPROX_DETERMINISTIC = \"binomial_taylor_approx_deterministic\"\n    POISSON = \"poisson\"\n    POISSON_DETERMINISTIC = \"poisson_deterministic\"\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable","title":"<code>TransitionVariable</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for transition variables in epidemiological model.</p> <p>For example, in an S-I-R model, the new number infected every iteration (the number going from S to I) in an iteration is modeled as a <code>TransitionVariable</code> subclass, with a concrete implementation of the abstract method <code>self.get_current_rate</code>.</p> <p>When an instance is initialized, its <code>self.get_realization</code> attribute is dynamically assigned, just like in the case of <code>TransitionVariableGroup</code> instantiation.</p> <p>Attributes:</p> Name Type Description <code>_transition_type</code> <code>str</code> <p>only values defined in <code>TransitionTypes</code> are valid, specifying probability distribution of transitions between compartments.</p> <code>get_current_rate</code> <code>function</code> <p>provides specific implementation for computing current rate as a function of current subpopulation simulation state and epidemiological parameters.</p> <code>current_rate</code> <code>ndarray</code> <p>holds output from <code>self.get_current_rate</code> method -- used to generate random variable realizations for transitions between compartments.</p> <code>current_val</code> <code>ndarray</code> <p>holds realization of random variable parameterized by <code>self.current_rate</code>.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of <code>self.current_val</code>, holds history of transition variable realizations for age-risk groups -- element t corresponds to previous <code>self.current_val</code> value at end of simulation day t.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class TransitionVariable(ABC):\n    \"\"\"\n    Abstract base class for transition variables in\n    epidemiological model.\n\n    For example, in an S-I-R model, the new number infected\n    every iteration (the number going from S to I) in an iteration\n    is modeled as a `TransitionVariable` subclass, with a concrete\n    implementation of the abstract method `self.get_current_rate`.\n\n    When an instance is initialized, its `self.get_realization` attribute\n    is dynamically assigned, just like in the case of\n    `TransitionVariableGroup` instantiation.\n\n    Attributes:\n        _transition_type (str):\n            only values defined in `TransitionTypes` are valid, specifying\n            probability distribution of transitions between compartments.\n        get_current_rate (function):\n            provides specific implementation for computing current rate\n            as a function of current subpopulation simulation state and\n            epidemiological parameters.\n        current_rate (np.ndarray):\n            holds output from `self.get_current_rate` method -- used to generate\n            random variable realizations for transitions between compartments.\n        current_val (np.ndarray):\n            holds realization of random variable parameterized by\n            `self.current_rate`.\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of `self.current_val`, holds\n            history of transition variable realizations for age-risk\n            groups -- element t corresponds to previous `self.current_val`\n            value at end of simulation day t.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin: Compartment,\n                 destination: Compartment,\n                 transition_type: TransitionTypes,\n                 is_jointly_distributed: str=False):\n        \"\"\"\n        Parameters:\n            origin (Compartment):\n                `Compartment` from which `TransitionVariable` exits.\n            destination (Compartment):\n                `Compartment` that the `TransitionVariable` enters.\n            transition_type (str):\n                only values defined in `TransitionTypes` are valid, specifying\n                probability distribution of transitions between compartments.\n            is_jointly_distributed (bool):\n                indicates if transition quantity must be jointly computed\n                (i.e. if there are multiple outflows from the origin compartment).\n        \"\"\"\n\n        self.origin = origin\n        self.destination = destination\n\n        # Also see __init__ method in TransitionVariableGroup class.\n        #   The structure is similar.\n        self._transition_type = transition_type\n        self._is_jointly_distributed = is_jointly_distributed\n\n        if is_jointly_distributed:\n            self.get_realization = None\n        else:\n            self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_rate = None\n        self.current_val = 0\n\n        self.history_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; TransitionTypes:\n        return self._transition_type\n\n    @property\n    def is_jointly_distributed(self) -&gt; bool:\n        return self._is_jointly_distributed\n\n    @abstractmethod\n    def get_current_rate(self,\n                         state: SubpopState,\n                         params: SubpopParams) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns current rate of transition variable,\n        based on current state of the simulation and epidemiological parameters.\n        Output should be a numpy array of size |A| x |R|, where |A| is the\n        number of age groups and |R| is number of risk groups.\n\n        Args:\n            state (SubpopState):\n                holds subpopulation simulation state\n                (current values of `StateVariable` instances).\n            params (SubpopParams):\n                holds values of epidemiological parameters.\n\n        Returns:\n            np.ndarray:\n                holds age-risk transition rate,\n                must be same shape as origin.init_val,\n                i.e. be size |A| x |R|, where |A| is the number of age groups\n                and |R| is number of risk groups.\n        \"\"\"\n        pass\n\n    def update_origin_outflow(self) -&gt; None:\n        \"\"\"\n        Adds current realization of `TransitionVariable` to\n            its origin `Compartment`'s current_outflow.\n            Used to compute total number leaving that\n            origin `Compartment`.\n        \"\"\"\n\n        self.origin.current_outflow = self.origin.current_outflow + self.current_val\n\n    def update_destination_inflow(self) -&gt; None:\n        \"\"\"\n        Adds current realization of `TransitionVariable` to\n            its destination `Compartment`'s `current_inflow`.\n            Used to compute total number leaving that\n            destination `Compartment`.\n        \"\"\"\n\n        self.destination.current_inflow = self.destination.current_inflow + self.current_val\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending `self.current_val`\n            attribute to `self.history_vals_list` in place.\n\n        Deep copying is CRUCIAL because `self.current_val` is a mutable\n            np.ndarray -- without deep copying, `self.history_vals_list` would\n            have the same value for all elements.\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets `self.history_vals_list` attribute to empty list.\n        \"\"\"\n\n        self.history_vals_list = []\n\n    def get_realization(self,\n                        RNG: np.random.Generator,\n                        num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        This method gets assigned to one of the following methods\n            based on the `TransitionVariable` transition type:\n            `self.get_binomial_realization`, `self.get_binomial_taylor_approx_realization`,\n            `self.get_poisson_realization`, `self.get_binomial_deterministic_realization`,\n            `self.get_binomial_taylor_approx_deterministic_realization`,\n            `self.get_poisson_deterministic_realization`. This is done so that\n            the same method `self.get_realization` can be called regardless of\n            transition type.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n        \"\"\"\n\n        pass\n\n    def get_binomial_realization(self,\n                                 RNG: np.random.Generator,\n                                 num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses `RNG` to generate binomial random variable with\n            number of trials equal to population count in the\n            origin `Compartment` and probability computed from\n            a function of the `TransitionVariable`'s current rate\n            -- see the `approx_binomial_probability_from_rate`\n            function for details.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size |A| x |R|, where |A| is the number of age groups and\n                |R| is number of risk groups.\n        \"\"\"\n\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=approx_binomial_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n\n    def get_binomial_taylor_approx_realization(self,\n                                               RNG: np.random.Generator,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses `RNG` to generate binomial random variable with\n            number of trials equal to population count in the\n            origin `Compartment` and probability equal to\n            the `TransitionVariable`'s `current_rate` / `num_timesteps`.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size |A| x |R|, where |A| is the number of age groups and L\n                is number of risk groups.\n        \"\"\"\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=self.current_rate * (1.0 / num_timesteps))\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses `RNG` to generate Poisson random variable with\n            rate equal to (population count in the\n            origin `Compartment` x the `TransitionVariable`'s\n            `current_rate` / `num_timesteps`)\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size |A| x |R|, where |A| is the number of age groups and\n                |R| is number of risk groups.\n        \"\"\"\n        return RNG.poisson(self.base_count * self.current_rate / float(num_timesteps))\n\n    def get_binomial_deterministic_realization(self,\n                                               RNG: np.random.Generator,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of binomial distribution\n            (number of trials x probability), where number of trials\n            equals population count in the origin `Compartment` and\n            probability is computed from a function of the `TransitionVariable`'s\n            current rate -- see the `approx_binomial_probability_from_rate`\n            function for details.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size |A| x |R|, where |A| is the number of age groups and\n                |R| is number of risk groups.\n        \"\"\"\n\n        return np.asarray(self.base_count *\n                          approx_binomial_probability_from_rate(self.current_rate, 1.0 / num_timesteps),\n                          dtype=int)\n\n    def get_binomial_taylor_approx_deterministic_realization(self,\n                                                             RNG: np.random.Generator,\n                                                             num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of binomial distribution\n            (number of trials x probability), where number of trials\n            equals population count in the origin `Compartment` and\n            probability equals the `TransitionVariable`'s `current_rate` /\n            `num_timesteps`.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size |A| x |R|, where |A| is the number of age groups and\n                |R| is number of risk groups.\n        \"\"\"\n\n        return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n\n    def get_poisson_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of Poisson distribution,\n            given by (population count in the origin `Compartment` x\n            `TransitionVariable`'s `current_rate` / `num_timesteps`).\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size |A| x |R|, where |A| is the number of age groups and\n                |R| is number of risk groups.\n        \"\"\"\n\n        return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n\n    @property\n    def base_count(self) -&gt; np.ndarray:\n        return self.origin.current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.__init__","title":"<code>__init__(origin: Compartment, destination: Compartment, transition_type: TransitionTypes, is_jointly_distributed: str = False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Compartment</code> <p><code>Compartment</code> from which <code>TransitionVariable</code> exits.</p> required <code>destination</code> <code>Compartment</code> <p><code>Compartment</code> that the <code>TransitionVariable</code> enters.</p> required <code>transition_type</code> <code>str</code> <p>only values defined in <code>TransitionTypes</code> are valid, specifying probability distribution of transitions between compartments.</p> required <code>is_jointly_distributed</code> <code>bool</code> <p>indicates if transition quantity must be jointly computed (i.e. if there are multiple outflows from the origin compartment).</p> <code>False</code> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             origin: Compartment,\n             destination: Compartment,\n             transition_type: TransitionTypes,\n             is_jointly_distributed: str=False):\n    \"\"\"\n    Parameters:\n        origin (Compartment):\n            `Compartment` from which `TransitionVariable` exits.\n        destination (Compartment):\n            `Compartment` that the `TransitionVariable` enters.\n        transition_type (str):\n            only values defined in `TransitionTypes` are valid, specifying\n            probability distribution of transitions between compartments.\n        is_jointly_distributed (bool):\n            indicates if transition quantity must be jointly computed\n            (i.e. if there are multiple outflows from the origin compartment).\n    \"\"\"\n\n    self.origin = origin\n    self.destination = destination\n\n    # Also see __init__ method in TransitionVariableGroup class.\n    #   The structure is similar.\n    self._transition_type = transition_type\n    self._is_jointly_distributed = is_jointly_distributed\n\n    if is_jointly_distributed:\n        self.get_realization = None\n    else:\n        self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_rate = None\n    self.current_val = 0\n\n    self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_binomial_deterministic_realization","title":"<code>get_binomial_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministically returns mean of binomial distribution     (number of trials x probability), where number of trials     equals population count in the origin <code>Compartment</code> and     probability is computed from a function of the <code>TransitionVariable</code>'s     current rate -- see the <code>approx_binomial_probability_from_rate</code>     function for details.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size |A| x |R|, where |A| is the number of age groups and |R| is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_binomial_deterministic_realization(self,\n                                           RNG: np.random.Generator,\n                                           num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of binomial distribution\n        (number of trials x probability), where number of trials\n        equals population count in the origin `Compartment` and\n        probability is computed from a function of the `TransitionVariable`'s\n        current rate -- see the `approx_binomial_probability_from_rate`\n        function for details.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size |A| x |R|, where |A| is the number of age groups and\n            |R| is number of risk groups.\n    \"\"\"\n\n    return np.asarray(self.base_count *\n                      approx_binomial_probability_from_rate(self.current_rate, 1.0 / num_timesteps),\n                      dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_binomial_realization","title":"<code>get_binomial_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Uses <code>RNG</code> to generate binomial random variable with     number of trials equal to population count in the     origin <code>Compartment</code> and probability computed from     a function of the <code>TransitionVariable</code>'s current rate     -- see the <code>approx_binomial_probability_from_rate</code>     function for details.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size |A| x |R|, where |A| is the number of age groups and |R| is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_binomial_realization(self,\n                             RNG: np.random.Generator,\n                             num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses `RNG` to generate binomial random variable with\n        number of trials equal to population count in the\n        origin `Compartment` and probability computed from\n        a function of the `TransitionVariable`'s current rate\n        -- see the `approx_binomial_probability_from_rate`\n        function for details.\n\n    Parameters:\n        RNG (np.random.Generator object):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size |A| x |R|, where |A| is the number of age groups and\n            |R| is number of risk groups.\n    \"\"\"\n\n    return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                        p=approx_binomial_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_binomial_taylor_approx_deterministic_realization","title":"<code>get_binomial_taylor_approx_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministically returns mean of binomial distribution     (number of trials x probability), where number of trials     equals population count in the origin <code>Compartment</code> and     probability equals the <code>TransitionVariable</code>'s <code>current_rate</code> /     <code>num_timesteps</code>.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size |A| x |R|, where |A| is the number of age groups and |R| is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_binomial_taylor_approx_deterministic_realization(self,\n                                                         RNG: np.random.Generator,\n                                                         num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of binomial distribution\n        (number of trials x probability), where number of trials\n        equals population count in the origin `Compartment` and\n        probability equals the `TransitionVariable`'s `current_rate` /\n        `num_timesteps`.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size |A| x |R|, where |A| is the number of age groups and\n            |R| is number of risk groups.\n    \"\"\"\n\n    return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_binomial_taylor_approx_realization","title":"<code>get_binomial_taylor_approx_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Uses <code>RNG</code> to generate binomial random variable with     number of trials equal to population count in the     origin <code>Compartment</code> and probability equal to     the <code>TransitionVariable</code>'s <code>current_rate</code> / <code>num_timesteps</code>.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size |A| x |R|, where |A| is the number of age groups and L is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_binomial_taylor_approx_realization(self,\n                                           RNG: np.random.Generator,\n                                           num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses `RNG` to generate binomial random variable with\n        number of trials equal to population count in the\n        origin `Compartment` and probability equal to\n        the `TransitionVariable`'s `current_rate` / `num_timesteps`.\n\n    Parameters:\n        RNG (np.random.Generator object):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size |A| x |R|, where |A| is the number of age groups and L\n            is number of risk groups.\n    \"\"\"\n    return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                        p=self.current_rate * (1.0 / num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_current_rate","title":"<code>get_current_rate(state: SubpopState, params: SubpopParams) -&gt; np.ndarray</code>","text":"<p>Computes and returns current rate of transition variable, based on current state of the simulation and epidemiological parameters. Output should be a numpy array of size |A| x |R|, where |A| is the number of age groups and |R| is number of risk groups.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>SubpopState</code> <p>holds subpopulation simulation state (current values of <code>StateVariable</code> instances).</p> required <code>params</code> <code>SubpopParams</code> <p>holds values of epidemiological parameters.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: holds age-risk transition rate, must be same shape as origin.init_val, i.e. be size |A| x |R|, where |A| is the number of age groups and |R| is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@abstractmethod\ndef get_current_rate(self,\n                     state: SubpopState,\n                     params: SubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns current rate of transition variable,\n    based on current state of the simulation and epidemiological parameters.\n    Output should be a numpy array of size |A| x |R|, where |A| is the\n    number of age groups and |R| is number of risk groups.\n\n    Args:\n        state (SubpopState):\n            holds subpopulation simulation state\n            (current values of `StateVariable` instances).\n        params (SubpopParams):\n            holds values of epidemiological parameters.\n\n    Returns:\n        np.ndarray:\n            holds age-risk transition rate,\n            must be same shape as origin.init_val,\n            i.e. be size |A| x |R|, where |A| is the number of age groups\n            and |R| is number of risk groups.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_poisson_deterministic_realization","title":"<code>get_poisson_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministically returns mean of Poisson distribution,     given by (population count in the origin <code>Compartment</code> x     <code>TransitionVariable</code>'s <code>current_rate</code> / <code>num_timesteps</code>).</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size |A| x |R|, where |A| is the number of age groups and |R| is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_poisson_deterministic_realization(self,\n                                          RNG: np.random.Generator,\n                                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of Poisson distribution,\n        given by (population count in the origin `Compartment` x\n        `TransitionVariable`'s `current_rate` / `num_timesteps`).\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size |A| x |R|, where |A| is the number of age groups and\n            |R| is number of risk groups.\n    \"\"\"\n\n    return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_poisson_realization","title":"<code>get_poisson_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Uses <code>RNG</code> to generate Poisson random variable with     rate equal to (population count in the     origin <code>Compartment</code> x the <code>TransitionVariable</code>'s     <code>current_rate</code> / <code>num_timesteps</code>)</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size |A| x |R|, where |A| is the number of age groups and |R| is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_poisson_realization(self,\n                            RNG: np.random.Generator,\n                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses `RNG` to generate Poisson random variable with\n        rate equal to (population count in the\n        origin `Compartment` x the `TransitionVariable`'s\n        `current_rate` / `num_timesteps`)\n\n    Parameters:\n        RNG (np.random.Generator object):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size |A| x |R|, where |A| is the number of age groups and\n            |R| is number of risk groups.\n    \"\"\"\n    return RNG.poisson(self.base_count * self.current_rate / float(num_timesteps))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_realization","title":"<code>get_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>This method gets assigned to one of the following methods     based on the <code>TransitionVariable</code> transition type:     <code>self.get_binomial_realization</code>, <code>self.get_binomial_taylor_approx_realization</code>,     <code>self.get_poisson_realization</code>, <code>self.get_binomial_deterministic_realization</code>,     <code>self.get_binomial_taylor_approx_deterministic_realization</code>,     <code>self.get_poisson_deterministic_realization</code>. This is done so that     the same method <code>self.get_realization</code> can be called regardless of     transition type.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_realization(self,\n                    RNG: np.random.Generator,\n                    num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    This method gets assigned to one of the following methods\n        based on the `TransitionVariable` transition type:\n        `self.get_binomial_realization`, `self.get_binomial_taylor_approx_realization`,\n        `self.get_poisson_realization`, `self.get_binomial_deterministic_realization`,\n        `self.get_binomial_taylor_approx_deterministic_realization`,\n        `self.get_poisson_deterministic_realization`. This is done so that\n        the same method `self.get_realization` can be called regardless of\n        transition type.\n\n    Parameters:\n        RNG (np.random.Generator object):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets <code>self.history_vals_list</code> attribute to empty list.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets `self.history_vals_list` attribute to empty list.\n    \"\"\"\n\n    self.history_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.save_history","title":"<code>save_history() -&gt; None</code>","text":"<p>Saves current value to history by appending <code>self.current_val</code>     attribute to <code>self.history_vals_list</code> in place.</p> <p>Deep copying is CRUCIAL because <code>self.current_val</code> is a mutable     np.ndarray -- without deep copying, <code>self.history_vals_list</code> would     have the same value for all elements.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending `self.current_val`\n        attribute to `self.history_vals_list` in place.\n\n    Deep copying is CRUCIAL because `self.current_val` is a mutable\n        np.ndarray -- without deep copying, `self.history_vals_list` would\n        have the same value for all elements.\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.update_destination_inflow","title":"<code>update_destination_inflow() -&gt; None</code>","text":"<p>Adds current realization of <code>TransitionVariable</code> to     its destination <code>Compartment</code>'s <code>current_inflow</code>.     Used to compute total number leaving that     destination <code>Compartment</code>.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_destination_inflow(self) -&gt; None:\n    \"\"\"\n    Adds current realization of `TransitionVariable` to\n        its destination `Compartment`'s `current_inflow`.\n        Used to compute total number leaving that\n        destination `Compartment`.\n    \"\"\"\n\n    self.destination.current_inflow = self.destination.current_inflow + self.current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariable.update_origin_outflow","title":"<code>update_origin_outflow() -&gt; None</code>","text":"<p>Adds current realization of <code>TransitionVariable</code> to     its origin <code>Compartment</code>'s current_outflow.     Used to compute total number leaving that     origin <code>Compartment</code>.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_origin_outflow(self) -&gt; None:\n    \"\"\"\n    Adds current realization of `TransitionVariable` to\n        its origin `Compartment`'s current_outflow.\n        Used to compute total number leaving that\n        origin `Compartment`.\n    \"\"\"\n\n    self.origin.current_outflow = self.origin.current_outflow + self.current_val\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup","title":"<code>TransitionVariableGroup</code>","text":"<p>Container for <code>TransitionVariable</code> objects to handle joint sampling, when there are multiple outflows from a single compartment.</p> <p>For example, if all outflows of compartment <code>H</code> are: <code>R</code> and <code>D</code>, i.e. from the hospital, people either recover or die, a <code>TransitionVariableGroup</code> that holds both <code>R</code> and <code>D</code> handles the correct correlation structure between <code>R</code> and <code>D.</code></p> <p>When an instance is initialized, its <code>self.get_joint_realization</code> attribute is dynamically assigned to a method according to its <code>self.transition_type</code> attribute. This enables all instances to use the same method during simulation.</p> <p>Attributes:</p> Name Type Description <code>origin</code> <code>Compartment</code> <p>specifies origin of <code>TransitionVariableGroup</code> -- corresponding populations leave this compartment.</p> <code>_transition_type</code> <code>str</code> <p>only values defined in <code>JointTransitionTypes</code> are valid, specifies joint probability distribution of all outflows from origin.</p> <code>transition_variables</code> <code>list[`TransitionVariable`]</code> <p>specifying <code>TransitionVariable</code> instances that outflow from origin -- order does not matter.</p> <code>get_joint_realization</code> <code>function</code> <p>assigned at initialization, generates realizations according to probability distribution given by <code>self._transition_type</code> attribute, returns either (M x |A| x |R|) or ((M+1) x |A| x |R|) np.ndarray, where M is the length of <code>self.transition_variables</code> (i.e., number of outflows from origin), |A| is the number of age groups, |R| is number of risk groups.</p> <code>current_vals_list</code> <code>list</code> <p>used to store results from <code>self.get_joint_realization</code> -- has either M or M+1 arrays of size |A| x |R|.</p> <p>See <code>__init__</code> docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class TransitionVariableGroup:\n    \"\"\"\n    Container for `TransitionVariable` objects to handle joint sampling,\n    when there are multiple outflows from a single compartment.\n\n    For example, if all outflows of compartment `H` are: `R` and `D`,\n    i.e. from the hospital, people either recover or die,\n    a `TransitionVariableGroup` that holds both `R` and `D` handles\n    the correct correlation structure between `R` and `D.`\n\n    When an instance is initialized, its `self.get_joint_realization` attribute\n    is dynamically assigned to a method according to its `self.transition_type`\n    attribute. This enables all instances to use the same method during\n    simulation.\n\n    Attributes:\n        origin (Compartment):\n            specifies origin of `TransitionVariableGroup` --\n            corresponding populations leave this compartment.\n        _transition_type (str):\n            only values defined in `JointTransitionTypes` are valid,\n            specifies joint probability distribution of all outflows\n            from origin.\n        transition_variables (list[`TransitionVariable`]):\n            specifying `TransitionVariable` instances that outflow from origin --\n            order does not matter.\n        get_joint_realization (function):\n            assigned at initialization, generates realizations according\n            to probability distribution given by `self._transition_type` attribute,\n            returns either (M x |A| x |R|) or ((M+1) x |A| x |R|) np.ndarray,\n            where M is the length of `self.transition_variables` (i.e., number of\n            outflows from origin), |A| is the number of age groups, |R| is number of\n            risk groups.\n        current_vals_list (list):\n            used to store results from `self.get_joint_realization` --\n            has either M or M+1 arrays of size |A| x |R|.\n\n    See `__init__` docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin: Compartment,\n                 transition_type: TransitionTypes,\n                 transition_variables: list[TransitionVariable]):\n        \"\"\"\n        Args:\n            transition_type (str):\n                only values defined in `TransitionTypes` are valid, specifying\n                probability distribution of transitions between compartments.\n\n        See class docstring for other parameters.\n        \"\"\"\n\n        self.origin = origin\n        self.transition_variables = transition_variables\n\n        # If marginal transition type is any kind of binomial transition,\n        #   then its joint transition type is a multinomial counterpart\n        # For example, if the marginal transition type is TransitionTypes.BINOMIAL_DETERMINISTIC,\n        #   then the joint transition type is JointTransitionTypes.MULTINOMIAL_DETERMINISTIC\n        transition_type = transition_type.replace(\"binomial\", \"multinomial\")\n        self._transition_type = transition_type\n\n        # Dynamically assign a method to get_joint_realization attribute\n        #   based on the value of transition_type\n        # getattr fetches a method by name\n        self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; JointTransitionTypes:\n        return self._transition_type\n\n    def get_total_rate(self) -&gt; np.ndarray:\n        \"\"\"\n        Return the age-risk-specific total transition rate,\n        which is the sum of the current rate of each transition variable\n        in this transition variable group.\n\n        Used to properly scale multinomial probabilities vector so\n        that elements sum to 1.\n\n        Returns:\n            numpy array of positive floats with size equal to number\n            of age groups x number of risk groups, and with value\n            corresponding to sum of current rates of transition variables in\n            transition variable group.\n        \"\"\"\n\n        # axis 0: corresponds to outgoing transition variable\n        # axis 1: corresponds to age groups\n        # axis 2: corresponds to risk groups\n        # --&gt; summing over axis 0 gives the total rate for each age-risk group\n        return np.sum(self.get_current_rates_array(), axis=0)\n\n    def get_probabilities_array(self,\n                                num_timesteps: int) -&gt; list:\n        \"\"\"\n        Returns an array of probabilities used for joint binomial\n        (multinomial) transitions (`get_multinomial_realization` method).\n\n        Returns:\n            contains positive floats &lt;= 1, size equal to\n            ((length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n        \"\"\"\n\n        total_rate = self.get_total_rate()\n\n        total_outgoing_probability = approx_binomial_probability_from_rate(total_rate,\n                                                                           1 / num_timesteps)\n\n        # Create probabilities_list, where element i corresponds to the\n        #   transition variable i's current rate divided by the total rate,\n        #   multiplized by the total outgoing probability\n        # This generates the probabilities array that parameterizes the\n        #   multinomial distribution\n        probabilities_list = []\n\n        for transition_variable in self.transition_variables:\n            probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                      total_outgoing_probability)\n\n        # Append the probability that a person stays in the compartment\n        probabilities_list.append(1 - total_outgoing_probability)\n\n        return np.asarray(probabilities_list)\n\n    def get_current_rates_array(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of current rates of transition variables in\n        self.transition_variables -- ith element in array\n        corresponds to current rate of ith transition variable.\n\n        Returns:\n            array of positive floats, size equal to (length of outgoing\n            transition variables list x number of age groups x number of risk groups).\n        \"\"\"\n\n        current_rates_list = []\n        for tvar in self.transition_variables:\n            current_rates_list.append(tvar.current_rate)\n\n        return np.asarray(current_rates_list)\n\n    def get_joint_realization(self,\n                              RNG: np.random.Generator,\n                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        This function is dynamically assigned based on the\n        `TransitionVariableGroup`'s `transition_type` -- this function is set to\n        one of the following methods: `self.get_multinomial_realization`,\n        `self.get_multinomial_taylor_approx_realization`,\n        `self.get_poisson_realization`, `self.get_multinomial_deterministic_realization`,\n        `self.get_multinomial_taylor_approx_deterministic_realization`,\n        `self.get_poisson_deterministic_realization`.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n        \"\"\"\n\n        pass\n\n    def get_multinomial_realization(self,\n                                    RNG: np.random.Generator,\n                                    num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                ((length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    probabilities_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_multinomial_taylor_approx_realization(self,\n                                                  RNG: np.random.Generator,\n                                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution\n        using Taylor Series approximation for probability parameter.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size equal to (length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                compartment).\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        current_rates_array = self.get_current_rates_array()\n\n        total_rate = self.get_total_rate()\n\n        # Multiply current rates array by length of time interval (1 / num_timesteps)\n        # Also append additional value corresponding to probability of\n        #   remaining in current epi compartment (not transitioning at all)\n        # Note: \"vstack\" function here works better than append function because append\n        #   automatically flattens the resulting array, resulting in dimension issues\n        current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                                np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    current_scaled_rates_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from Poisson distribution.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                 used to generate stochastic transitions in the model and control\n                 reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to length of\n                (outgoing transition variables list x\n                number of age groups x number of risk groups).\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n        transition_variables = self.transition_variables\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                for outflow_ix in range(num_outflows):\n                    realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                        self.origin.current_val[age_group, risk_group] *\n                        transition_variables[outflow_ix].current_rate[\n                            age_group, risk_group] / num_timesteps)\n\n        return realizations_array\n\n    def get_multinomial_deterministic_realization(self,\n                                                  RNG: np.random.Generator,\n                                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to `self.get_multinomial_realization` --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                (length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n        return np.asarray(self.origin.current_val * probabilities_array, dtype=int)\n\n    def get_multinomial_taylor_approx_deterministic_realization(self,\n                                                                RNG: np.random.Generator,\n                                                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to `self.get_multinomial_taylor_approx_realization` --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                (length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same compartment (not transitioning to any outgoing\n                compartment).\n        \"\"\"\n\n        current_rates_array = self.get_current_rates_array()\n        return np.asarray(self.origin.current_val * current_rates_array / num_timesteps, dtype=int)\n\n    def get_poisson_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to `self.get_poisson_realization` --\n        uses mean (rate array) as realization rather than randomly sampling.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                (length of outgoing transition variables list\n                x number of age groups x number of risk groups).\n        \"\"\"\n\n        return np.asarray(self.origin.current_val *\n                          self.get_current_rates_array() / num_timesteps, dtype=int)\n\n    def reset(self) -&gt; None:\n        self.current_vals_list = []\n\n    def update_transition_variable_realizations(self) -&gt; None:\n        \"\"\"\n        Updates current_val attribute on all `TransitionVariable`\n        instances contained in this `TransitionVariableGroup`.\n        \"\"\"\n\n        # Since the ith element in probabilities_array corresponds to the ith transition variable\n        #   in transition_variables, the ith element in multinomial_realizations_list\n        #   also corresponds to the ith transition variable in transition_variables\n        # Update the current realization of the transition variables contained in this group\n        for ix in range(len(self.transition_variables)):\n            self.transition_variables[ix].current_val = \\\n                self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.__init__","title":"<code>__init__(origin: Compartment, transition_type: TransitionTypes, transition_variables: list[TransitionVariable])</code>","text":"<p>Parameters:</p> Name Type Description Default <code>transition_type</code> <code>str</code> <p>only values defined in <code>TransitionTypes</code> are valid, specifying probability distribution of transitions between compartments.</p> required <p>See class docstring for other parameters.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             origin: Compartment,\n             transition_type: TransitionTypes,\n             transition_variables: list[TransitionVariable]):\n    \"\"\"\n    Args:\n        transition_type (str):\n            only values defined in `TransitionTypes` are valid, specifying\n            probability distribution of transitions between compartments.\n\n    See class docstring for other parameters.\n    \"\"\"\n\n    self.origin = origin\n    self.transition_variables = transition_variables\n\n    # If marginal transition type is any kind of binomial transition,\n    #   then its joint transition type is a multinomial counterpart\n    # For example, if the marginal transition type is TransitionTypes.BINOMIAL_DETERMINISTIC,\n    #   then the joint transition type is JointTransitionTypes.MULTINOMIAL_DETERMINISTIC\n    transition_type = transition_type.replace(\"binomial\", \"multinomial\")\n    self._transition_type = transition_type\n\n    # Dynamically assign a method to get_joint_realization attribute\n    #   based on the value of transition_type\n    # getattr fetches a method by name\n    self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_vals_list = []\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_current_rates_array","title":"<code>get_current_rates_array() -&gt; np.ndarray</code>","text":"<p>Returns an array of current rates of transition variables in self.transition_variables -- ith element in array corresponds to current rate of ith transition variable.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>array of positive floats, size equal to (length of outgoing</p> <code>ndarray</code> <p>transition variables list x number of age groups x number of risk groups).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_current_rates_array(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of current rates of transition variables in\n    self.transition_variables -- ith element in array\n    corresponds to current rate of ith transition variable.\n\n    Returns:\n        array of positive floats, size equal to (length of outgoing\n        transition variables list x number of age groups x number of risk groups).\n    \"\"\"\n\n    current_rates_list = []\n    for tvar in self.transition_variables:\n        current_rates_list.append(tvar.current_rate)\n\n    return np.asarray(current_rates_list)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_joint_realization","title":"<code>get_joint_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>This function is dynamically assigned based on the <code>TransitionVariableGroup</code>'s <code>transition_type</code> -- this function is set to one of the following methods: <code>self.get_multinomial_realization</code>, <code>self.get_multinomial_taylor_approx_realization</code>, <code>self.get_poisson_realization</code>, <code>self.get_multinomial_deterministic_realization</code>, <code>self.get_multinomial_taylor_approx_deterministic_realization</code>, <code>self.get_poisson_deterministic_realization</code>.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_joint_realization(self,\n                          RNG: np.random.Generator,\n                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    This function is dynamically assigned based on the\n    `TransitionVariableGroup`'s `transition_type` -- this function is set to\n    one of the following methods: `self.get_multinomial_realization`,\n    `self.get_multinomial_taylor_approx_realization`,\n    `self.get_poisson_realization`, `self.get_multinomial_deterministic_realization`,\n    `self.get_multinomial_taylor_approx_deterministic_realization`,\n    `self.get_poisson_deterministic_realization`.\n\n    Parameters:\n        RNG (np.random.Generator object):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_multinomial_deterministic_realization","title":"<code>get_multinomial_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministic counterpart to <code>self.get_multinomial_realization</code> -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to (length of outgoing transition variables list + 1) x number of age groups x number of risk groups -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_multinomial_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to `self.get_multinomial_realization` --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            (length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n    return np.asarray(self.origin.current_val * probabilities_array, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_multinomial_realization","title":"<code>get_multinomial_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to ((length of outgoing transition variables list + 1) x number of age groups x number of risk groups) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_multinomial_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution.\n\n    Parameters:\n        RNG (np.random.Generator object):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            ((length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                probabilities_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_multinomial_taylor_approx_deterministic_realization","title":"<code>get_multinomial_taylor_approx_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministic counterpart to <code>self.get_multinomial_taylor_approx_realization</code> -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to (length of outgoing transition variables list + 1) x number of age groups x number of risk groups -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_multinomial_taylor_approx_deterministic_realization(self,\n                                                            RNG: np.random.Generator,\n                                                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to `self.get_multinomial_taylor_approx_realization` --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            (length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            compartment).\n    \"\"\"\n\n    current_rates_array = self.get_current_rates_array()\n    return np.asarray(self.origin.current_val * current_rates_array / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_multinomial_taylor_approx_realization","title":"<code>get_multinomial_taylor_approx_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution using Taylor Series approximation for probability parameter.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size equal to (length of outgoing transition variables list + 1) x number of age groups x number of risk groups -- note the \"+1\" corresponds to the multinomial outcome of staying in the same compartment (not transitioning to any outgoing compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_multinomial_taylor_approx_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution\n    using Taylor Series approximation for probability parameter.\n\n    Parameters:\n        RNG (np.random.Generator object):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size equal to (length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same compartment (not transitioning to any outgoing\n            compartment).\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    current_rates_array = self.get_current_rates_array()\n\n    total_rate = self.get_total_rate()\n\n    # Multiply current rates array by length of time interval (1 / num_timesteps)\n    # Also append additional value corresponding to probability of\n    #   remaining in current epi compartment (not transitioning at all)\n    # Note: \"vstack\" function here works better than append function because append\n    #   automatically flattens the resulting array, resulting in dimension issues\n    current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                            np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                current_scaled_rates_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_poisson_deterministic_realization","title":"<code>get_poisson_deterministic_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Deterministic counterpart to <code>self.get_poisson_realization</code> -- uses mean (rate array) as realization rather than randomly sampling.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to (length of outgoing transition variables list x number of age groups x number of risk groups).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_poisson_deterministic_realization(self,\n                                          RNG: np.random.Generator,\n                                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to `self.get_poisson_realization` --\n    uses mean (rate array) as realization rather than randomly sampling.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            (length of outgoing transition variables list\n            x number of age groups x number of risk groups).\n    \"\"\"\n\n    return np.asarray(self.origin.current_val *\n                      self.get_current_rates_array() / num_timesteps, dtype=int)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_poisson_realization","title":"<code>get_poisson_realization(RNG: np.random.Generator, num_timesteps: int) -&gt; np.ndarray</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from Poisson distribution.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate stochastic transitions in the model and control  reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to length of (outgoing transition variables list x number of age groups x number of risk groups).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_poisson_realization(self,\n                            RNG: np.random.Generator,\n                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from Poisson distribution.\n\n    Parameters:\n        RNG (np.random.Generator object):\n             used to generate stochastic transitions in the model and control\n             reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to length of\n            (outgoing transition variables list x\n            number of age groups x number of risk groups).\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n    transition_variables = self.transition_variables\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            for outflow_ix in range(num_outflows):\n                realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                    self.origin.current_val[age_group, risk_group] *\n                    transition_variables[outflow_ix].current_rate[\n                        age_group, risk_group] / num_timesteps)\n\n    return realizations_array\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_probabilities_array","title":"<code>get_probabilities_array(num_timesteps: int) -&gt; list</code>","text":"<p>Returns an array of probabilities used for joint binomial (multinomial) transitions (<code>get_multinomial_realization</code> method).</p> <p>Returns:</p> Type Description <code>list</code> <p>contains positive floats &lt;= 1, size equal to</p> <code>list</code> <p>((length of outgoing transition variables list + 1)</p> <code>list</code> <p>x number of age groups x number of risk groups) --</p> <code>list</code> <p>note the \"+1\" corresponds to the multinomial outcome of staying</p> <code>list</code> <p>in the same epi compartment (not transitioning to any outgoing</p> <code>list</code> <p>epi compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_probabilities_array(self,\n                            num_timesteps: int) -&gt; list:\n    \"\"\"\n    Returns an array of probabilities used for joint binomial\n    (multinomial) transitions (`get_multinomial_realization` method).\n\n    Returns:\n        contains positive floats &lt;= 1, size equal to\n        ((length of outgoing transition variables list + 1)\n        x number of age groups x number of risk groups) --\n        note the \"+1\" corresponds to the multinomial outcome of staying\n        in the same epi compartment (not transitioning to any outgoing\n        epi compartment).\n    \"\"\"\n\n    total_rate = self.get_total_rate()\n\n    total_outgoing_probability = approx_binomial_probability_from_rate(total_rate,\n                                                                       1 / num_timesteps)\n\n    # Create probabilities_list, where element i corresponds to the\n    #   transition variable i's current rate divided by the total rate,\n    #   multiplized by the total outgoing probability\n    # This generates the probabilities array that parameterizes the\n    #   multinomial distribution\n    probabilities_list = []\n\n    for transition_variable in self.transition_variables:\n        probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                  total_outgoing_probability)\n\n    # Append the probability that a person stays in the compartment\n    probabilities_list.append(1 - total_outgoing_probability)\n\n    return np.asarray(probabilities_list)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_total_rate","title":"<code>get_total_rate() -&gt; np.ndarray</code>","text":"<p>Return the age-risk-specific total transition rate, which is the sum of the current rate of each transition variable in this transition variable group.</p> <p>Used to properly scale multinomial probabilities vector so that elements sum to 1.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>numpy array of positive floats with size equal to number</p> <code>ndarray</code> <p>of age groups x number of risk groups, and with value</p> <code>ndarray</code> <p>corresponding to sum of current rates of transition variables in</p> <code>ndarray</code> <p>transition variable group.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_total_rate(self) -&gt; np.ndarray:\n    \"\"\"\n    Return the age-risk-specific total transition rate,\n    which is the sum of the current rate of each transition variable\n    in this transition variable group.\n\n    Used to properly scale multinomial probabilities vector so\n    that elements sum to 1.\n\n    Returns:\n        numpy array of positive floats with size equal to number\n        of age groups x number of risk groups, and with value\n        corresponding to sum of current rates of transition variables in\n        transition variable group.\n    \"\"\"\n\n    # axis 0: corresponds to outgoing transition variable\n    # axis 1: corresponds to age groups\n    # axis 2: corresponds to risk groups\n    # --&gt; summing over axis 0 gives the total rate for each age-risk group\n    return np.sum(self.get_current_rates_array(), axis=0)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.update_transition_variable_realizations","title":"<code>update_transition_variable_realizations() -&gt; None</code>","text":"<p>Updates current_val attribute on all <code>TransitionVariable</code> instances contained in this <code>TransitionVariableGroup</code>.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_transition_variable_realizations(self) -&gt; None:\n    \"\"\"\n    Updates current_val attribute on all `TransitionVariable`\n    instances contained in this `TransitionVariableGroup`.\n    \"\"\"\n\n    # Since the ith element in probabilities_array corresponds to the ith transition variable\n    #   in transition_variables, the ith element in multinomial_realizations_list\n    #   also corresponds to the ith transition variable in transition_variables\n    # Update the current realization of the transition variables contained in this group\n    for ix in range(len(self.transition_variables)):\n        self.transition_variables[ix].current_val = \\\n            self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.approx_binomial_probability_from_rate","title":"<code>approx_binomial_probability_from_rate(rate: np.ndarray, interval_length: int) -&gt; np.ndarray</code>","text":"<p>Converts a rate (events per time) to the probability of any event occurring in the next time interval of length <code>interval_length</code>, assuming the number of events occurring in time interval follows a Poisson distribution with given rate parameter.</p> <p>The probability of 0 events in <code>interval_length</code> is e^(-<code>rate</code> * <code>interval_length</code>), so the probability of any event in <code>interval_length</code> is 1 - e^(-<code>rate</code> * <code>interval_length</code>).</p> <p>Rate must be |A| x |R| <code>np.ndarray</code>, where |A| is the number of age groups and |R| is the number of risk groups. Rate is transformed to |A| x |R| <code>np.ndarray</code> corresponding to probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>ndarray</code> <p>dimension |A| x |R| (number of age groups x number of risk groups), rate parameters in a Poisson distribution.</p> required <code>interval_length</code> <code>positive int</code> <p>length of time interval in simulation days.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: array of positive scalars, dimension |A| x |R|</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def approx_binomial_probability_from_rate(rate: np.ndarray,\n                                          interval_length: int) -&gt; np.ndarray:\n    \"\"\"\n    Converts a rate (events per time) to the probability of any event\n    occurring in the next time interval of length `interval_length`,\n    assuming the number of events occurring in time interval\n    follows a Poisson distribution with given rate parameter.\n\n    The probability of 0 events in `interval_length` is\n    e^(-`rate` * `interval_length`), so the probability of any event\n    in `interval_length` is 1 - e^(-`rate` * `interval_length`).\n\n    Rate must be |A| x |R| `np.ndarray`, where |A| is the number of\n    age groups and |R| is the number of risk groups. Rate is transformed to\n    |A| x |R| `np.ndarray` corresponding to probabilities.\n\n    Parameters:\n        rate (np.ndarray):\n            dimension |A| x |R| (number of age groups x number of risk groups),\n            rate parameters in a Poisson distribution.\n        interval_length (positive int):\n            length of time interval in simulation days.\n\n    Returns:\n        np.ndarray:\n            array of positive scalars, dimension |A| x |R|\n    \"\"\"\n\n    return 1 - np.exp(-rate * interval_length)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.check_is_subset_list","title":"<code>check_is_subset_list(listA: list, listB: list) -&gt; bool</code>","text":"<p>Parameters:</p> Name Type Description Default <code>listA</code> <code>list</code> <p>list-like of elements to check if subset of listB.</p> required <code>listB</code> <code>list</code> <p>list-like of elements.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if listA is a subset of listB, and False otherwise.</p> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def check_is_subset_list(listA: list,\n                         listB: list) -&gt; bool:\n    \"\"\"\n    Params:\n        listA (list):\n            list-like of elements to check if subset of listB.\n        listB (list):\n            list-like of elements.\n\n    Returns:\n        True if listA is a subset of listB, and False otherwise.\n    \"\"\"\n\n    return all(item in listB for item in listA)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.convert_dict_vals_lists_to_arrays","title":"<code>convert_dict_vals_lists_to_arrays(d: dict) -&gt; dict</code>","text":"Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>def convert_dict_vals_lists_to_arrays(d: dict) -&gt; dict:\n\n    # convert lists to numpy arrays to support numpy operations\n    for key, val in d.items():\n        if type(val) is list:\n            d[key] = np.asarray(val)\n\n    return d\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.format_current_val_for_sql","title":"<code>format_current_val_for_sql(subpop_model: SubpopModel, state_var_name: str, rep: int) -&gt; list</code>","text":"<p>Processes current_val of given subpop_model's <code>StateVariable</code> specified by <code>state_var_name</code>. Current_val is an |A| x |R| numpy array (for age-risk) -- this function \"unpacks\" it into an (|A| x |R|, 1) numpy array (a column vector). Converts metadata (subpop_name, state_var_name, <code>rep</code>, and current_simulation_day) into list of |A| x |R| rows, where each row has 7 elements, for consistent row formatting for batch SQL insertion.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>SubpopModel to record.</p> required <code>state_var_name</code> <code>str</code> <p>StateVariable name to record.</p> required <code>rep</code> <code>int</code> <p>replication counter to record.</p> required <p>Returns:</p> Name Type Description <code>data</code> <code>list</code> <p>list of |A| x |R| rows, where each row is a list of 7 elements corresponding to subpop_name, state_var_name, age_group, risk_group, rep, current_simulation_day, and the scalar element of current_val corresponding to that age-risk group.</p> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def format_current_val_for_sql(subpop_model: SubpopModel,\n                               state_var_name: str,\n                               rep: int) -&gt; list:\n    \"\"\"\n    Processes current_val of given subpop_model's `StateVariable`\n    specified by `state_var_name`. Current_val is an |A| x |R|\n    numpy array (for age-risk) -- this function \"unpacks\" it into an\n    (|A| x |R|, 1) numpy array (a column vector). Converts metadata\n    (subpop_name, state_var_name, `rep`, and current_simulation_day)\n    into list of |A| x |R| rows, where each row has 7 elements, for\n    consistent row formatting for batch SQL insertion.\n\n    Params:\n        subpop_model (SubpopModel):\n            SubpopModel to record.\n        state_var_name (str):\n            StateVariable name to record.\n        rep (int):\n            replication counter to record.\n\n    Returns:\n        data (list):\n            list of |A| x |R| rows, where each row is a list of 7 elements\n            corresponding to subpop_name, state_var_name, age_group, risk_group,\n            rep, current_simulation_day, and the scalar element of current_val\n            corresponding to that age-risk group.\n    \"\"\"\n\n    current_val = subpop_model.all_state_variables[state_var_name].current_val\n\n    A, R = np.shape(current_val)\n\n    # numpy's default is row-major / C-style order\n    # This means the elements are unpacked ROW BY ROW\n    current_val_reshaped = current_val.reshape(-1, 1)\n\n    # (AxR, 1) column vector of row indices, indicating the original row in current_val\n    #   before reshaping\n    # Each integer in np.arange(A) repeated R times\n    age_group_indices = np.repeat(np.arange(A), R).reshape(-1, 1)\n\n    # (AxR, 1) column vector of column indices, indicating the original column\n    #   each element belonged to in current_val before reshaping\n    # Repeat np.arange(R) A times\n    risk_group_indices = np.tile(np.arange(R), A).reshape(-1, 1)\n\n    # (subpop_name, state_var_name, age_group, risk_group, rep, timepoint)\n    data = np.column_stack(\n        (np.full((A * R, 1), subpop_model.name),\n         np.full((A * R, 1), state_var_name),\n         age_group_indices,\n         risk_group_indices,\n         np.full((A * R, 1), rep),\n         np.full((A * R, 1), subpop_model.current_simulation_day),\n         current_val_reshaped)).tolist()\n\n    return data\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.get_sql_table_as_df","title":"<code>get_sql_table_as_df(conn: sqlite3.Connection, sql_query: str, sql_query_params: tuple[str] = None, chunk_size: int = int(10000.0)) -&gt; pd.DataFrame</code>","text":"<p>Returns a pandas DataFrame containing data from specified SQL table, retrieved using the provided database connection. Reads in SQL rows in batches of size <code>chunk_size</code> to avoid memory issues for very large tables.</p> <p>Parameters:</p> Name Type Description Default <code>conn</code> <code>Connection</code> <p>connection to SQL database.</p> required <code>sql_query</code> <code>str</code> <p>SQL query/statement to execute on database.</p> required <code>sql_query_params</code> <code>tuple[str]</code> <p>tuple of strings to pass as parameters to SQL query -- used to avoid SQL injections.</p> <code>None</code> <code>chunk_size</code> <code>positive int</code> <p>number of rows to read in at a time.</p> <code>int(10000.0)</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing data from specified SQL table,</p> <code>DataFrame</code> <p>or empty DataFrame if table does not exist.</p> Source code in <code>CLT_BaseModel/clt_base/experiments.py</code> <pre><code>def get_sql_table_as_df(conn: sqlite3.Connection,\n                        sql_query: str,\n                        sql_query_params: tuple[str] = None,\n                        chunk_size: int = int(1e4)) -&gt; pd.DataFrame:\n    \"\"\"\n    Returns a pandas DataFrame containing data from specified SQL table,\n    retrieved using the provided database connection. Reads in SQL rows\n    in batches of size `chunk_size` to avoid memory issues for very large\n    tables.\n\n    Params:\n        conn (sqlite3.Connection):\n            connection to SQL database.\n        sql_query (str):\n            SQL query/statement to execute on database.\n        sql_query_params (tuple[str]):\n            tuple of strings to pass as parameters to\n            SQL query -- used to avoid SQL injections.\n        chunk_size (positive int):\n            number of rows to read in at a time.\n\n    Returns:\n        DataFrame containing data from specified SQL table,\n        or empty DataFrame if table does not exist.\n    \"\"\"\n\n    chunks = []\n\n    try:\n        for chunk in pd.read_sql_query(sql_query,\n                                       conn,\n                                       chunksize=chunk_size,\n                                       params=sql_query_params):\n            chunks.append(chunk)\n            df = pd.concat(chunks, ignore_index=True)\n\n    # Handle exception gracefully -- print a warning and\n    #   return an empty DataFrame if table given by sql_query\n    #   does not exist\n    except sqlite3.OperationalError as e:\n        if \"no such table\" in str(e).lower():\n            print(f\"Warning: table does not exist for query: {sql_query}. \"\n                  f\"Returning empty DataFrame.\")\n            df = pd.DataFrame()\n\n    return df\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.load_json_augment_dict","title":"<code>load_json_augment_dict(json_filepath: str, d: dict) -&gt; dict</code>","text":"Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>def load_json_augment_dict(json_filepath: str, d: dict) -&gt; dict:\n\n    with open(json_filepath, 'r') as file:\n        data = json.load(file)\n\n    data = convert_dict_vals_lists_to_arrays(data)\n\n    for key, val in data.items():\n        d[key] = val\n\n    return d\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.load_json_new_dict","title":"<code>load_json_new_dict(json_filepath: str) -&gt; dict</code>","text":"Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>def load_json_new_dict(json_filepath: str) -&gt; dict:\n\n    # Note: the \"with open\" is important for file handling\n    #   and avoiding resource leaks -- otherwise,\n    #   we have to manually close the file, which is a bit\n    #   more cumbersome\n    with open(json_filepath, 'r') as file:\n        data = json.load(file)\n\n    # json does not support numpy, so we must convert\n    #   lists to numpy arrays\n    return convert_dict_vals_lists_to_arrays(data)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.make_dataclass_from_dict","title":"<code>make_dataclass_from_dict(dataclass_ref: Type[DataClassProtocol], d: dict) -&gt; DataClassProtocol</code>","text":"<p>Create instance of class dataclass_ref, based on information in dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dataclass_ref</code> <code>Type[DataClassProtocol]</code> <p>(class, not instance) from which to create instance -- must have dataclass decorator.</p> required <code>d</code> <code>dict</code> <p>all keys and values respectively must match name and datatype of dataclass_ref instance attributes.</p> required <p>Returns:</p> Name Type Description <code>DataClassProtocol</code> <code>DataClassProtocol</code> <p>instance of dataclass_ref with attributes dynamically assigned by json_filepath file contents.</p> Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>def make_dataclass_from_dict(dataclass_ref: Type[DataClassProtocol],\n                             d: dict) -&gt; DataClassProtocol:\n    \"\"\"\n    Create instance of class dataclass_ref,\n    based on information in dictionary.\n\n    Args:\n        dataclass_ref (Type[DataClassProtocol]):\n            (class, not instance) from which to create instance --\n            must have dataclass decorator.\n        d (dict):\n            all keys and values respectively must match name and datatype\n            of dataclass_ref instance attributes.\n\n    Returns:\n        DataClassProtocol:\n            instance of dataclass_ref with attributes dynamically\n            assigned by json_filepath file contents.\n    \"\"\"\n\n    d = convert_dict_vals_lists_to_arrays(d)\n\n    return dataclass_ref(**d)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.make_dataclass_from_json","title":"<code>make_dataclass_from_json(dataclass_ref: Type[DataClassProtocol], json_filepath: str) -&gt; DataClassProtocol</code>","text":"<p>Create instance of class dataclass_ref, based on information in json_filepath.</p> <p>Parameters:</p> Name Type Description Default <code>dataclass_ref</code> <code>Type[DataClassProtocol]</code> <p>(class, not instance) from which to create instance -- must have dataclass decorator.</p> required <code>json_filepath</code> <code>str</code> <p>path to json file (path includes actual filename with suffix \".json\") -- all json fields must match name and datatype of dataclass_ref instance attributes.</p> required <p>Returns:</p> Name Type Description <code>DataClassProtocol</code> <code>DataClassProtocol</code> <p>instance of dataclass_ref with attributes dynamically assigned by json_filepath file contents.</p> Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>def make_dataclass_from_json(dataclass_ref: Type[DataClassProtocol],\n                             json_filepath: str) -&gt; DataClassProtocol:\n    \"\"\"\n    Create instance of class dataclass_ref,\n    based on information in json_filepath.\n\n    Args:\n        dataclass_ref (Type[DataClassProtocol]):\n            (class, not instance) from which to create instance --\n            must have dataclass decorator.\n        json_filepath (str):\n            path to json file (path includes actual filename\n            with suffix \".json\") -- all json fields must\n            match name and datatype of dataclass_ref instance\n            attributes.\n\n    Returns:\n        DataClassProtocol:\n            instance of dataclass_ref with attributes dynamically\n            assigned by json_filepath file contents.\n    \"\"\"\n\n    d = load_json_new_dict(json_filepath)\n\n    return make_dataclass_from_dict(dataclass_ref, d)\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.plot_metapop_basic_compartment_history","title":"<code>plot_metapop_basic_compartment_history(metapop_model: MetapopModel, axes: matplotlib.axes.Axes = None)</code>","text":"<p>Plots the compartment data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_basic_compartment_history(metapop_model: MetapopModel,\n                                           axes: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots the compartment data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    # Iterate over subpop models and plot\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_basic_compartment_history(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.plot_metapop_decorator","title":"<code>plot_metapop_decorator(plot_func)</code>","text":"<p>Decorator to handle common metapopulation plotting tasks.</p> Source code in <code>CLT_BaseModel/clt_base/plotting.py</code> <pre><code>def plot_metapop_decorator(plot_func):\n    \"\"\"\n    Decorator to handle common metapopulation plotting tasks.\n    \"\"\"\n\n    @functools.wraps(plot_func)\n    def wrapper(metapop_model: MetapopModel,\n                savefig_filename = None):\n\n        num_plots = len(metapop_model.subpop_models)\n        num_cols = 2\n        num_rows = (num_plots + num_cols - 1) // num_cols\n\n        # Create figure and axes\n        fig, axes = plt.subplots(num_rows, num_cols, figsize=(5 * num_cols, 4 * num_rows))\n        axes = axes.flatten()\n\n        plot_func(metapop_model=metapop_model, axes=axes)\n\n        # Turn off any unused subplots\n        for j in range(num_plots, len(axes)):\n            fig.delaxes(axes[j])  # Remove empty subplot\n\n        # Adjust layout and save/show the figure\n        plt.tight_layout()\n\n        if savefig_filename:\n            plt.savefig(savefig_filename, dpi=1200)\n\n        plt.show()\n\n    return wrapper\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.plot_metapop_epi_metrics","title":"<code>plot_metapop_epi_metrics(metapop_model: MetapopModel, axes: matplotlib.axes.Axes)</code>","text":"<p>Plots the EpiMetric data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_base/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_epi_metrics(metapop_model: MetapopModel,\n                             axes: matplotlib.axes.Axes):\n    \"\"\"\n    Plots the EpiMetric data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_epi_metrics(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.plot_metapop_total_infected_deaths","title":"<code>plot_metapop_total_infected_deaths(metapop_model: MetapopModel, axes: matplotlib.axes.Axes)</code>","text":"<p>Plots the total infected (IP+IS+IA) and deaths data for a metapopulation model.</p> <p>Parameters:</p> Name Type Description Default <code>metapop_model</code> <code>MetapopModel</code> <p>Metapopulation model containing compartments.</p> required <code>axes</code> <code>Axes</code> <p>Matplotlib axes to plot on.</p> required Source code in <code>CLT_BaseModel/clt_base/plotting.py</code> <pre><code>@plot_metapop_decorator\ndef plot_metapop_total_infected_deaths(metapop_model: MetapopModel,\n                                       axes: matplotlib.axes.Axes):\n    \"\"\"\n    Plots the total infected (IP+IS+IA) and deaths data for a metapopulation model.\n\n    Args:\n        metapop_model (MetapopModel):\n            Metapopulation model containing compartments.\n        axes (matplotlib.axes.Axes):\n            Matplotlib axes to plot on.\n    \"\"\"\n\n    # Iterate over subpop models and plot\n    for ix, (subpop_name, subpop_model) in enumerate(metapop_model.subpop_models.items()):\n        plot_subpop_total_infected_deaths(subpop_model, axes[ix])\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.plot_subpop_basic_compartment_history","title":"<code>plot_subpop_basic_compartment_history(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots data for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_basic_compartment_history(subpop_model: SubpopModel,\n                                          ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots data for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    for name, compartment in subpop_model.compartments.items():\n        # Compute summed history values for each age-risk group\n        history_vals_list = [np.sum(age_risk_group_entry) for\n                             age_risk_group_entry in compartment.history_vals_list]\n\n        # Plot data with a label\n        ax.plot(history_vals_list, label=name, alpha=0.6)\n\n    # Set axis title and labels\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Number of individuals\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.plot_subpop_decorator","title":"<code>plot_subpop_decorator(plot_func)</code>","text":"<p>Decorator to handle common subpopulation plotting tasks.</p> Source code in <code>CLT_BaseModel/clt_base/plotting.py</code> <pre><code>def plot_subpop_decorator(plot_func):\n    \"\"\"\n    Decorator to handle common subpopulation plotting tasks.\n    \"\"\"\n\n    @functools.wraps(plot_func)\n    def wrapper(subpop_model: SubpopModel,\n                ax: matplotlib.axes.Axes = None,\n                savefig_filename: str = None):\n        \"\"\"\n        Args:\n            subpop_model (SubpopModel):\n                SubpopModel to plot.\n            ax (matplotlib.axes.Axes):\n                Matplotlib axis to plot on.\n            savefig_filename (str):\n                Optional filename to save the figure.\n        \"\"\"\n\n        ax_provided = ax\n\n        # If no axis is provided, create own axis\n        if ax is None:\n            fig, ax = plt.subplots()\n\n        plot_func(subpop_model=subpop_model, ax=ax)\n\n        if savefig_filename:\n            plt.savefig(savefig_filename, dpi=1200)\n\n        if ax_provided is None:\n            plt.show()\n\n    return wrapper\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.plot_subpop_epi_metrics","title":"<code>plot_subpop_epi_metrics(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots EpiMetric history for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_epi_metrics(subpop_model: SubpopModel,\n                            ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots EpiMetric history for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    for name, epi_metric in subpop_model.epi_metrics.items():\n\n        # Compute summed history values for each age-risk group\n        history_vals_list = [np.average(age_risk_group_entry) for\n                             age_risk_group_entry in epi_metric.history_vals_list]\n\n        # Plot data with a label\n        ax.plot(history_vals_list, label=name, alpha=0.6)\n\n    # Set axis title and labels\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Epi Metric Value\")\n    ax.legend()\n</code></pre>"},{"location":"clt_base_package_reference/#CLT_BaseModel.clt_base.plot_subpop_total_infected_deaths","title":"<code>plot_subpop_total_infected_deaths(subpop_model: SubpopModel, ax: matplotlib.axes.Axes = None)</code>","text":"<p>Plots data for a single subpopulation model on the given axis.</p> <p>Parameters:</p> Name Type Description Default <code>subpop_model</code> <code>SubpopModel</code> <p>Subpopulation model containing compartments.</p> required <code>ax</code> <code>Axes</code> <p>Matplotlib axis to plot on.</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/plotting.py</code> <pre><code>@plot_subpop_decorator\ndef plot_subpop_total_infected_deaths(subpop_model: SubpopModel,\n                                      ax: matplotlib.axes.Axes = None):\n    \"\"\"\n    Plots data for a single subpopulation model on the given axis.\n\n    Args:\n        subpop_model (SubpopModel):\n            Subpopulation model containing compartments.\n        ax (matplotlib.axes.Axes):\n            Matplotlib axis to plot on.\n    \"\"\"\n\n    infected_compartment_names = [name for name in subpop_model.compartments.keys() if\n                                  \"I\" in name or \"H\" in name]\n\n    infected_compartments_history = [subpop_model.compartments[compartment_name].history_vals_list\n                                     for compartment_name in infected_compartment_names]\n\n    total_infected = np.sum(np.asarray(infected_compartments_history), axis=(0, 2, 3))\n\n    ax.plot(total_infected, label=\"Total infected\", alpha=0.6)\n\n    if \"D\" in subpop_model.compartments.keys():\n        deaths = [np.sum(age_risk_group_entry)\n                  for age_risk_group_entry\n                  in subpop_model.compartments.D.history_vals_list]\n\n        ax.plot(deaths, label=\"D\", alpha=0.6)\n\n    ax.set_title(f\"{subpop_model.name}\")\n    ax.set_xlabel(\"Days\")\n    ax.set_ylabel(\"Number of individuals\")\n    ax.legend()\n</code></pre>"},{"location":"flu_components_reference/","title":"Flu Components Code API Reference","text":"<p>Docstrings and references for <code>flu_model</code> module.</p>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.base_path","title":"<code>base_path = Path(__file__).parent.parent / 'flu_demo_input_files'</code>  <code>module-attribute</code>","text":""},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.AbsoluteHumidity","title":"<code>AbsoluteHumidity</code>","text":"<p>               Bases: <code>Schedule</code></p> <p>Schedule-derived class for absolute humidity. Depends on real date (absolute humidity is higher in the summer and lower in the winter in the US).</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class AbsoluteHumidity(clt.Schedule):\n    \"\"\"\n    Schedule-derived class for absolute humidity.\n    Depends on real date (absolute humidity is higher in the summer\n    and lower in the winter in the US).\n    \"\"\"\n\n    def update_current_val(self,\n                           subpop_params: FluSubpopParams,\n                           current_date: datetime.date) -&gt; None:\n        self.current_val = absolute_humidity_func(current_date)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.AsympToRecovered","title":"<code>AsympToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IA\" to \"R\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class AsympToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IA\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.IA_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.BetaReduct","title":"<code>BetaReduct</code>","text":"<p>               Bases: <code>DynamicVal</code></p> <p>\"Toy\" function representing staged-alert policy     that reduces transmission by 50% when more than 5%     of the total population is infected. Note: the     numbers are completely made up :) The \"permanent_lockdown\" toggle is to avoid \"bang-bang\"     behavior where the staged-alert policy gets triggered     one day and then is off the next, and then is on the     day after, and so on... but as the name suggests,     it IS permanent. TODO: replace with realistic function.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class BetaReduct(clt.DynamicVal):\n    \"\"\"\n    \"Toy\" function representing staged-alert policy\n        that reduces transmission by 50% when more than 5%\n        of the total population is infected. Note: the\n        numbers are completely made up :)\n    The \"permanent_lockdown\" toggle is to avoid \"bang-bang\"\n        behavior where the staged-alert policy gets triggered\n        one day and then is off the next, and then is on the\n        day after, and so on... but as the name suggests,\n        it IS permanent.\n    TODO: replace with realistic function.\n    \"\"\"\n\n    def __init__(self, init_val, is_enabled):\n        super().__init__(init_val, is_enabled)\n        self.permanent_lockdown = False\n\n    def update_current_val(self, state, params):\n        if np.sum(state.IS) / np.sum(params.total_pop_age_risk) &gt; 0.05:\n            self.current_val = .5\n            self.permanent_lockdown = True\n        else:\n            if not self.permanent_lockdown:\n                self.current_val = 0.0\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.ExposedToAsymp","title":"<code>ExposedToAsymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"E\" to \"IA\" compartment. The functional form is the same across subpopulations.</p> <p>Each ExposedToAsymp instance forms a TransitionVariableGroup with a corresponding ExposedToPresymp instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class ExposedToAsymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"E\" to \"IA\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each ExposedToAsymp instance forms a TransitionVariableGroup with\n    a corresponding ExposedToPresymp instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.E_to_I_rate * params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.ExposedToPresymp","title":"<code>ExposedToPresymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"E\" to \"IP\" compartment. The functional form is the same across subpopulations.</p> <p>Each ExposedToPresymp instance forms a TransitionVariableGroup with a corresponding ExposedToAsymp instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class ExposedToPresymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"E\" to \"IP\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each ExposedToPresymp instance forms a TransitionVariableGroup with\n    a corresponding ExposedToAsymp instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.E_to_I_rate * (1 - params.E_to_IA_prop))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluContactMatrix","title":"<code>FluContactMatrix</code>","text":"<p>               Bases: <code>Schedule</code></p> <p>Flu contact matrix.</p> <p>Attributes:</p> Name Type Description <code>timeseries_df</code> <code>DataFrame</code> <p>has a \"date\" column with strings in format \"YYYY-MM-DD\" of consecutive calendar days, and other columns named \"is_school_day\" (bool) and \"is_work_day\" (bool) corresponding to type of day.</p> <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class FluContactMatrix(clt.Schedule):\n    \"\"\"\n    Flu contact matrix.\n\n    Attributes:\n        timeseries_df (pd.DataFrame):\n            has a \"date\" column with strings in format \"YYYY-MM-DD\"\n            of consecutive calendar days, and other columns\n            named \"is_school_day\" (bool) and \"is_work_day\" (bool)\n            corresponding to type of day.\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[np.ndarray | float] = None,\n                 calendar_df: pd.DataFrame = None):\n\n        super().__init__(init_val)\n\n        self.calendar_df = calendar_df\n\n    def update_current_val(self,\n                           subpop_params: FluSubpopParams,\n                           current_date: datetime.date) -&gt; None:\n\n        df = self.calendar_df\n\n        try:\n            current_row = df[df[\"date\"] == current_date].iloc[0]\n        except IndexError:\n            print(f\"Error: {current_date} is not in the Calendar's calendar_df.\")\n\n        self.current_val = subpop_params.total_contact_matrix - \\\n                           (1 - current_row[\"is_school_day\"]) * subpop_params.school_contact_matrix - \\\n                           (1 - current_row[\"is_work_day\"]) * subpop_params.work_contact_matrix\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo","title":"<code>FluInterSubpopRepo</code>","text":"<p>               Bases: <code>InterSubpopRepo</code></p> <p>Holds collection of SubpopState instances, with     actions to query and interact with them.</p> <p>Attributes:</p> Name Type Description <code>subpop_models</code> <code>dict</code> <p>dictionary where keys are SubpopModel names and values are the SubpopModel instances -- whole dictionary contains all SubpopModel instances that comprise the associated MetapopModel</p> <code>subpop_names_mapping</code> <code>dict</code> <p>keys are names of SubpopModel instances and values are integers 0, 1, ..., |L|-1, where |L| is the nubmer of subpopulations (associated SubpopModel instances). Provides a mapping between the name of the subpopulation and the row/column position in travel_proportions_array (and other associated indices used for intermediate computation on this class).</p> <code>travel_proportions_array</code> <code>ndarray</code> <p>|L| x |L| array, where |L| is the number of subpopulations (associated SubpopModel instances). Element i,j corresponds to proportion of subpopulation i that travels to subpopulation j (elements must be in [0,1]). The mapping of subpopulations is given by subpop_names_mapping.</p> <code>sum_prop_residents_traveling_out_array</code> <code>ndarray</code> <p>|L| x 1 array, where |L| is the number of subpopulations (associated SubpopModel instances). Element l is the  sum of the proportion of residents in given subpopulation who travel to a destination subpopulation, summed over all destinations but excluding residents' within-subpopulation traveling. Note that this value may be greater than 1.</p> <code>force_of_infection_array</code> <code>ndarray</code> <p>|L| x |A| x |R| array, where |L| is the number of subpopulations  (associated SubpopModel instances), |A| is the number of age groups,  and |R| is the number of risk groups. Element l,a,r corresponds to the total infection rate to residents of subpopulation l. The mapping of indices to the subpopulation is given by the ordering of subpop names in the \"subpop_name\"  column of the travel_proportions dataframe -- so that the l,a,r element in force_of_infection_array corresponds to the subpopulation whose name is ith  in the \"subpop_name\" column of  travel_proportions.</p> <p>See parent class InterSubpopRepo's docstring for     attributes and additional methods.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class FluInterSubpopRepo(clt.InterSubpopRepo):\n    \"\"\"\n    Holds collection of SubpopState instances, with\n        actions to query and interact with them.\n\n    Attributes:\n        subpop_models (dict):\n            dictionary where keys are SubpopModel names and values are the\n            SubpopModel instances -- whole dictionary contains all SubpopModel\n            instances that comprise the associated MetapopModel\n        subpop_names_mapping (dict):\n            keys are names of SubpopModel instances and values are integers\n            0, 1, ..., |L|-1, where |L| is the nubmer of subpopulations\n            (associated SubpopModel instances). Provides a mapping between\n            the name of the subpopulation and the row/column position in\n            travel_proportions_array (and other associated indices used for\n            intermediate computation on this class).\n        travel_proportions_array (np.ndarray):\n            |L| x |L| array, where |L| is the number of subpopulations\n            (associated SubpopModel instances). Element i,j corresponds to\n            proportion of subpopulation i that travels to subpopulation j\n            (elements must be in [0,1]). The mapping of subpopulations is given by\n            subpop_names_mapping.\n        sum_prop_residents_traveling_out_array (np.ndarray):\n            |L| x 1 array, where |L| is the number of subpopulations (associated\n            SubpopModel instances). Element l is the  sum of the proportion of\n            residents in given subpopulation who travel to a destination subpopulation,\n            summed over all destinations but excluding residents' within-subpopulation\n            traveling. Note that this value may be greater than 1.\n        force_of_infection_array (np.ndarray):\n            |L| x |A| x |R| array, where |L| is the number of subpopulations \n            (associated SubpopModel instances), |A| is the number of age groups, \n            and |R| is the number of risk groups. Element l,a,r corresponds to the\n            total infection rate to residents of subpopulation l. The mapping of indices\n            to the subpopulation is given by the ordering of subpop names in the \"subpop_name\" \n            column of the travel_proportions dataframe -- so that the l,a,r element\n            in force_of_infection_array corresponds to the subpopulation whose name is ith \n            in the \"subpop_name\" column of  travel_proportions.\n\n    See parent class InterSubpopRepo's docstring for\n        attributes and additional methods.\n    \"\"\"\n\n    def __init__(self,\n                 subpop_models: dict,\n                 subpop_names_mapping: dict,\n                 travel_proportions_array: np.ndarray):\n\n        super().__init__(subpop_models)\n\n        self.subpop_names_mapping = subpop_names_mapping\n        self.travel_proportions_array = travel_proportions_array\n\n        self.sum_prop_residents_traveling_out_array = \\\n            self.compute_sum_prop_residents_traveling_out()\n\n        #   This attribute will be set to an array using method compute_shared_quantities()\n        #   during the associated MetapopModel's simulate_until_day() method.\n        self.force_of_infection_array = None\n\n    def compute_shared_quantities(self):\n        \"\"\"\n        Updates force_of_infection_array attribute in-place.\n        \"\"\"\n\n        force_of_infection_array = []\n\n        wtd_no_symp_by_age_cache = self.create_wtd_no_symp_by_age_cache()\n        effective_pop_by_age_cache = self.create_pop_by_age_cache()\n\n        # Extract subpop names in correct order corresponding to their mapping\n        subpop_names_ordered = sorted(self.subpop_names_mapping, key=self.subpop_names_mapping.get)\n\n        for subpop_name in subpop_names_ordered:\n            force_of_infection = \\\n                self.inf_from_home_region_movement(subpop_name,\n                                                   wtd_no_symp_by_age_cache,\n                                                   effective_pop_by_age_cache) + \\\n                self.inf_from_visitors(subpop_name,\n                                       wtd_no_symp_by_age_cache,\n                                       effective_pop_by_age_cache) + \\\n                self.inf_from_residents_traveling(subpop_name,\n                                                  wtd_no_symp_by_age_cache,\n                                                  effective_pop_by_age_cache)\n\n            force_of_infection_array.append(force_of_infection)\n\n        self.force_of_infection_array = np.asarray(force_of_infection_array)\n\n    def prop_residents_traveling_pairwise(self,\n                                          origin_subpop_name: str,\n                                          dest_subpop_name: str) -&gt; float:\n        \"\"\"\n        Returns:\n             (float):\n                the proportion in [0,1] of residents in given origin subpopulation\n                who travel to the given destination subpopulation.\n        \"\"\"\n\n        subpop_names_mapping = self.subpop_names_mapping\n\n        return self.travel_proportions_array[subpop_names_mapping[origin_subpop_name],\n                                             subpop_names_mapping[dest_subpop_name]]\n\n    def compute_sum_prop_residents_traveling_out(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns |L| x 1 array, where |L| is the number of subpopulations,\n        corresponding to the sum of the proportion of residents in given subpopulation\n        who travel to a destination subpopulation, summed over all destinations\n        but excluding residents' within-subpopulation traveling.\n\n        Note that each element's value may be greater than 1!\n        \"\"\"\n\n        travel_proportions_array = self.travel_proportions_array\n\n        # For each subpopulation (row index), sum the travel proportions\n        #   in that row but subtract the diagonal element (because\n        #   we are excluding residents who travel within their home subpopulation).\n        return np.sum(travel_proportions_array, axis=1, keepdims=True) - \\\n               np.diag(travel_proportions_array).reshape(-1, 1)\n\n    def create_wtd_no_symp_by_age_cache(self) -&gt; dict:\n        \"\"\"\n        Creates cache (dictionary) of weighted sum of\n        non-symptomatic infectious people (IP and IA),\n        weighted by relative infectiousness, summed over risk\n        groups and categorized by age, for a given subpopulation.\n\n        Keys are the subpopulation name, values are the\n        |A| x |1| array corresponding to the above weighted sum,\n        where |A| is the number of age groups.\n        \"\"\"\n\n        wtd_no_symp_by_age_cache = {}\n\n        for subpop_model in self.subpop_models.values():\n            wtd_no_symp_by_age_cache[subpop_model.name] = \\\n                compute_wtd_presymp_asymp(subpop_model.state,\n                                          subpop_model.params)\n\n        return wtd_no_symp_by_age_cache\n\n    def create_pop_by_age_cache(self) -&gt; dict:\n        \"\"\"\n        Creates cache (dictionary) of total population\n        for a given subpopulation, summed over risk groups\n        and categorized by age.\n\n        Keys are the subpopulation name, values are the\n        |A| x |1| array corresponding to the above population sum,\n        where |A| is the number of age groups.\n        \"\"\"\n\n        pop_by_age_cache = {}\n\n        for subpop_model in self.subpop_models.values():\n            pop_by_age_cache[subpop_model.name] = \\\n                compute_pop_by_age(subpop_model.params)\n\n        return pop_by_age_cache\n\n    def create_pop_healthy_by_age(self) -&gt; dict:\n        \"\"\"\n        Creates cache (dictionary) of weighted sum of\n        \"healthy-presenting\" people (those not in compartments\n        IS and H). Corresponds to total population minus\n        IS and H populations weighted by multiplier that reduces\n        contact rates of sick individuals, summed over risk groups\n        and categorized by age, for a given subpopulation.\n\n        Keys are the subpopulation name, values are the\n        |A| x |1| array corresponding to the above population sum,\n        where |A| is the number of age groups.\n        \"\"\"\n\n        pop_healthy_by_age = {}\n\n        pop_by_age_cache = self.create_pop_by_age_cache()\n\n        for subpop_model in self.subpop_models.values():\n            subpop_name = subpop_model.name\n            subpop_state = subpop_model.state\n\n            pop_healthy_by_age[subpop_name] = \\\n                (pop_by_age_cache[subpop_name] -\n                 subpop_model.params.contact_mult_symp *\n                 np.sum(subpop_state.IS, axis=1, keepdims=True) +\n                 np.sum(subpop_state.H, axis=1, keepdims=True))\n\n        return pop_healthy_by_age\n\n    def sum_wtd_visitors_by_age(self,\n                                subpop_name: str,\n                                pop_healthy_by_age: dict) -&gt; np.ndarray:\n        \"\"\"\n        Returns |A| x 1 array corresponding to weighted visitors\n        to given subpopulation, where |A| is the number of age groups.\n        \"\"\"\n\n        wtd_visitors_by_origin = []\n\n        for origin_subpop_name in self.subpop_models.keys():\n            if origin_subpop_name == subpop_name:\n                continue\n            else:\n                wtd_visitors_by_origin.append(\n                    self.prop_residents_traveling_pairwise(origin_subpop_name,\n                                                           subpop_name) *\n                    pop_healthy_by_age[origin_subpop_name])\n\n        return np.sum(wtd_visitors_by_origin, axis=1)\n\n    def create_effective_pop_by_age_cache(self):\n        \"\"\"\n        Creates cache (dictionary) of effective population\n        for each subpopulation, which corresponds to a population\n        adjustment to account for non-traveling sick residents,\n        traveling residents, and outside visitors.\n\n        Keys are the subpopulation name, values are the\n        |A| x |1| array corresponding to the above population sum,\n        where |A| is the number of age groups.\n        \"\"\"\n\n        pop_by_age_cache = self.create_pop_by_age_cache()\n        pop_healthy_by_age = self.create_pop_healthy_by_age()\n\n        effective_pop_by_age_cache = {}\n\n        subpop_names_mapping = self.subpop_names_mapping\n\n        for subpop_model in self.subpop_models.values():\n            subpop_name = subpop_model.name\n            subpop_params = subpop_model.params\n\n            effective_pop_by_age_cache[subpop_name] = \\\n                pop_by_age_cache[subpop_name] + \\\n                subpop_params.prop_time_away_by_age * \\\n                (self.sum_wtd_visitors_by_age(subpop_name, pop_healthy_by_age) -\n                 self.sum_prop_residents_traveling_out_array[subpop_names_mapping[subpop_name]] *\n                 pop_healthy_by_age[subpop_name])\n\n        return effective_pop_by_age_cache\n\n    def inf_from_home_region_movement(self,\n                                      subpop_name: str,\n                                      wtd_no_symp_by_age_cache: dict,\n                                      effective_pop_by_age_cache: dict) -&gt; np.ndarray:\n        \"\"\"\n        Returns |A| x 1 array corresponding to infection rate due to\n        residents in given subpopulation traveling within their own\n        subpopulation, where |A| is the number of age groups.\n        \"\"\"\n\n        # Math reminder -- other than the summation over proportion of residents\n        #   traveling, there is only ONE subpopulation index here.\n\n        subpop_model = self.subpop_models[subpop_name]\n        subpop_state = subpop_model.state\n        subpop_params = subpop_model.params\n        subpop_names_mapping = self.subpop_names_mapping\n\n        prop_time_away_by_age = subpop_params.prop_time_away_by_age\n        sum_prop_residents_traveling_out = \\\n            self.sum_prop_residents_traveling_out_array[subpop_names_mapping[subpop_name]]\n\n        contact_matrix = subpop_state.flu_contact_matrix\n        wtd_infected_by_age = \\\n            wtd_no_symp_by_age_cache[subpop_name] + \\\n            np.sum(subpop_state.IS, axis=1, keepdims=True)\n\n        wtd_infected_to_pop_ratio = np.divide(wtd_infected_by_age,\n                                              effective_pop_by_age_cache[subpop_name])\n\n        common_coeff = compute_common_coeff_force_of_infection(subpop_state, subpop_params)\n\n        return common_coeff * (1 - prop_time_away_by_age * sum_prop_residents_traveling_out) * \\\n               np.matmul(contact_matrix, wtd_infected_to_pop_ratio)\n\n    def inf_from_visitors(self,\n                          subpop_name: str,\n                          wtd_no_symp_by_age_cache: dict,\n                          effective_pop_by_age_cache: dict) -&gt; np.ndarray:\n        \"\"\"\n        Returns |L| x |A| x 1 array corresponding to infection rate to given\n        subpopulation, due to outside visitors from other subpopulations,\n        where |A| is the number of age groups.\n        \"\"\"\n\n        subpop_model = self.subpop_models[subpop_name]\n        subpop_state = subpop_model.state\n        subpop_params = subpop_model.params\n\n        all_subpop_models_names = self.subpop_models.keys()\n\n        # Create a list to store all pairwise values\n        # Each element corresponds to the infection rate due to\n        #   visitors from another subpopulation\n        # These elements are summed to obtain the overall infection rate\n        #   from outside visitors from ALL other subpopulations\n        inf_from_visitors_pairwise = []\n\n        for visitors_subpop_name in all_subpop_models_names:\n\n            # Do not include residential travel within same subpopulation\n            #   -- this is handled with inf_from_home_region_movement\n            if visitors_subpop_name == subpop_name:\n                continue\n\n            else:\n                # Math reminder -- the weighted sum of infected people is for\n                #   other subpopulations, but the other indices/values are for\n                #   the input subpopulation.\n\n                contact_mult_symp = subpop_params.contact_mult_symp\n\n                prop_residents_traveling_pairwise = \\\n                    self.prop_residents_traveling_pairwise(visitors_subpop_name,\n                                                           subpop_name)\n\n                prop_time_away_by_age = subpop_params.prop_time_away_by_age\n\n                contact_matrix = subpop_state.flu_contact_matrix\n\n                visitors_subpop_model = self.subpop_models[visitors_subpop_name]\n                visitors_subpop_state = visitors_subpop_model.state\n\n                wtd_infected_visitors_by_age = \\\n                    wtd_no_symp_by_age_cache[visitors_subpop_name] + \\\n                    contact_mult_symp * np.sum(visitors_subpop_state.IS, axis=1, keepdims=True)\n\n                wtd_infected_to_pop_ratio = \\\n                    np.divide(wtd_infected_visitors_by_age,\n                              effective_pop_by_age_cache[subpop_name])\n\n                inf_from_visitors_pairwise.append(\n                    prop_residents_traveling_pairwise *\n                    np.matmul(contact_matrix,\n                              prop_time_away_by_age * wtd_infected_to_pop_ratio))\n\n        common_coeff = compute_common_coeff_force_of_infection(subpop_state, subpop_params)\n\n        return np.sum(common_coeff * subpop_params.contact_mult_travel *\n                      np.asarray(inf_from_visitors_pairwise), axis=0)\n\n    def inf_from_residents_traveling(self,\n                                     subpop_name: str,\n                                     wtd_no_symp_by_age_cache: dict,\n                                     effective_pop_by_age_cache: dict) -&gt; np.ndarray:\n        \"\"\"\n        Returns |A| x 1 array corresponding to infection rate to given\n        subpopulation, due to residents getting infected while visiting\n        other subpopulations and then bringing the infections back home,\n        where |A| is the number of age groups.\n        \"\"\"\n\n        subpop_model = self.subpop_models[subpop_name]\n        subpop_state = subpop_model.state\n        subpop_params = subpop_model.params\n\n        all_subpop_models_names = self.subpop_models.keys()\n\n        # Create a list to store all pairwise values\n        # Each element corresponds to the infection rate due to\n        #   residents visiting another subpopulation\n        # These elements are summed to obtain the overall infection rate\n        #   from residents getting infected in ALL other subpopulations\n        inf_from_residents_traveling_pairwise = []\n\n        for dest_subpop_name in all_subpop_models_names:\n\n            if dest_subpop_name == subpop_name:\n                continue\n\n            else:\n                # Math reminder -- the weighted sum of infected people AND\n                #   the effective population refers to the OTHER subpopulation\n                #   -- because we are dealing with residents that get\n                #   infected in OTHER subpopulations\n\n                prop_residents_traveling_pairwise = self.prop_residents_traveling_pairwise(\n                    subpop_name, dest_subpop_name\n                )\n\n                prop_time_away_by_age = subpop_params.prop_time_away_by_age\n\n                contact_matrix = subpop_state.flu_contact_matrix\n\n                dest_subpop_model = self.subpop_models[dest_subpop_name]\n                dest_subpop_state = dest_subpop_model.state\n\n                # Weighted infected at DESTINATION subpopulation\n                wtd_infected_dest_by_age = \\\n                    wtd_no_symp_by_age_cache[dest_subpop_name] + \\\n                    np.sum(dest_subpop_state.IS, axis=1, keepdims=True)\n\n                # Ratio of weighted infected (at destination) to\n                #   effective population (at destination)\n                wtd_infected_to_pop_dest_ratio = \\\n                    np.divide(wtd_infected_dest_by_age,\n                              effective_pop_by_age_cache[dest_subpop_name])\n\n                inf_from_residents_traveling_pairwise.append(\n                    prop_residents_traveling_pairwise *\n                    wtd_infected_to_pop_dest_ratio *\n                    np.matmul(contact_matrix,\n                              prop_time_away_by_age))\n\n        common_coeff = compute_common_coeff_force_of_infection(subpop_state, subpop_params)\n\n        return np.sum(common_coeff * subpop_params.contact_mult_travel *\n                      inf_from_residents_traveling_pairwise, axis=0)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.compute_shared_quantities","title":"<code>compute_shared_quantities()</code>","text":"<p>Updates force_of_infection_array attribute in-place.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def compute_shared_quantities(self):\n    \"\"\"\n    Updates force_of_infection_array attribute in-place.\n    \"\"\"\n\n    force_of_infection_array = []\n\n    wtd_no_symp_by_age_cache = self.create_wtd_no_symp_by_age_cache()\n    effective_pop_by_age_cache = self.create_pop_by_age_cache()\n\n    # Extract subpop names in correct order corresponding to their mapping\n    subpop_names_ordered = sorted(self.subpop_names_mapping, key=self.subpop_names_mapping.get)\n\n    for subpop_name in subpop_names_ordered:\n        force_of_infection = \\\n            self.inf_from_home_region_movement(subpop_name,\n                                               wtd_no_symp_by_age_cache,\n                                               effective_pop_by_age_cache) + \\\n            self.inf_from_visitors(subpop_name,\n                                   wtd_no_symp_by_age_cache,\n                                   effective_pop_by_age_cache) + \\\n            self.inf_from_residents_traveling(subpop_name,\n                                              wtd_no_symp_by_age_cache,\n                                              effective_pop_by_age_cache)\n\n        force_of_infection_array.append(force_of_infection)\n\n    self.force_of_infection_array = np.asarray(force_of_infection_array)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.compute_sum_prop_residents_traveling_out","title":"<code>compute_sum_prop_residents_traveling_out() -&gt; np.ndarray</code>","text":"<p>Returns |L| x 1 array, where |L| is the number of subpopulations, corresponding to the sum of the proportion of residents in given subpopulation who travel to a destination subpopulation, summed over all destinations but excluding residents' within-subpopulation traveling.</p> <p>Note that each element's value may be greater than 1!</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def compute_sum_prop_residents_traveling_out(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns |L| x 1 array, where |L| is the number of subpopulations,\n    corresponding to the sum of the proportion of residents in given subpopulation\n    who travel to a destination subpopulation, summed over all destinations\n    but excluding residents' within-subpopulation traveling.\n\n    Note that each element's value may be greater than 1!\n    \"\"\"\n\n    travel_proportions_array = self.travel_proportions_array\n\n    # For each subpopulation (row index), sum the travel proportions\n    #   in that row but subtract the diagonal element (because\n    #   we are excluding residents who travel within their home subpopulation).\n    return np.sum(travel_proportions_array, axis=1, keepdims=True) - \\\n           np.diag(travel_proportions_array).reshape(-1, 1)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.create_effective_pop_by_age_cache","title":"<code>create_effective_pop_by_age_cache()</code>","text":"<p>Creates cache (dictionary) of effective population for each subpopulation, which corresponds to a population adjustment to account for non-traveling sick residents, traveling residents, and outside visitors.</p> <p>Keys are the subpopulation name, values are the |A| x |1| array corresponding to the above population sum, where |A| is the number of age groups.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_effective_pop_by_age_cache(self):\n    \"\"\"\n    Creates cache (dictionary) of effective population\n    for each subpopulation, which corresponds to a population\n    adjustment to account for non-traveling sick residents,\n    traveling residents, and outside visitors.\n\n    Keys are the subpopulation name, values are the\n    |A| x |1| array corresponding to the above population sum,\n    where |A| is the number of age groups.\n    \"\"\"\n\n    pop_by_age_cache = self.create_pop_by_age_cache()\n    pop_healthy_by_age = self.create_pop_healthy_by_age()\n\n    effective_pop_by_age_cache = {}\n\n    subpop_names_mapping = self.subpop_names_mapping\n\n    for subpop_model in self.subpop_models.values():\n        subpop_name = subpop_model.name\n        subpop_params = subpop_model.params\n\n        effective_pop_by_age_cache[subpop_name] = \\\n            pop_by_age_cache[subpop_name] + \\\n            subpop_params.prop_time_away_by_age * \\\n            (self.sum_wtd_visitors_by_age(subpop_name, pop_healthy_by_age) -\n             self.sum_prop_residents_traveling_out_array[subpop_names_mapping[subpop_name]] *\n             pop_healthy_by_age[subpop_name])\n\n    return effective_pop_by_age_cache\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.create_pop_by_age_cache","title":"<code>create_pop_by_age_cache() -&gt; dict</code>","text":"<p>Creates cache (dictionary) of total population for a given subpopulation, summed over risk groups and categorized by age.</p> <p>Keys are the subpopulation name, values are the |A| x |1| array corresponding to the above population sum, where |A| is the number of age groups.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_pop_by_age_cache(self) -&gt; dict:\n    \"\"\"\n    Creates cache (dictionary) of total population\n    for a given subpopulation, summed over risk groups\n    and categorized by age.\n\n    Keys are the subpopulation name, values are the\n    |A| x |1| array corresponding to the above population sum,\n    where |A| is the number of age groups.\n    \"\"\"\n\n    pop_by_age_cache = {}\n\n    for subpop_model in self.subpop_models.values():\n        pop_by_age_cache[subpop_model.name] = \\\n            compute_pop_by_age(subpop_model.params)\n\n    return pop_by_age_cache\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.create_pop_healthy_by_age","title":"<code>create_pop_healthy_by_age() -&gt; dict</code>","text":"<p>Creates cache (dictionary) of weighted sum of \"healthy-presenting\" people (those not in compartments IS and H). Corresponds to total population minus IS and H populations weighted by multiplier that reduces contact rates of sick individuals, summed over risk groups and categorized by age, for a given subpopulation.</p> <p>Keys are the subpopulation name, values are the |A| x |1| array corresponding to the above population sum, where |A| is the number of age groups.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_pop_healthy_by_age(self) -&gt; dict:\n    \"\"\"\n    Creates cache (dictionary) of weighted sum of\n    \"healthy-presenting\" people (those not in compartments\n    IS and H). Corresponds to total population minus\n    IS and H populations weighted by multiplier that reduces\n    contact rates of sick individuals, summed over risk groups\n    and categorized by age, for a given subpopulation.\n\n    Keys are the subpopulation name, values are the\n    |A| x |1| array corresponding to the above population sum,\n    where |A| is the number of age groups.\n    \"\"\"\n\n    pop_healthy_by_age = {}\n\n    pop_by_age_cache = self.create_pop_by_age_cache()\n\n    for subpop_model in self.subpop_models.values():\n        subpop_name = subpop_model.name\n        subpop_state = subpop_model.state\n\n        pop_healthy_by_age[subpop_name] = \\\n            (pop_by_age_cache[subpop_name] -\n             subpop_model.params.contact_mult_symp *\n             np.sum(subpop_state.IS, axis=1, keepdims=True) +\n             np.sum(subpop_state.H, axis=1, keepdims=True))\n\n    return pop_healthy_by_age\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.create_wtd_no_symp_by_age_cache","title":"<code>create_wtd_no_symp_by_age_cache() -&gt; dict</code>","text":"<p>Creates cache (dictionary) of weighted sum of non-symptomatic infectious people (IP and IA), weighted by relative infectiousness, summed over risk groups and categorized by age, for a given subpopulation.</p> <p>Keys are the subpopulation name, values are the |A| x |1| array corresponding to the above weighted sum, where |A| is the number of age groups.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_wtd_no_symp_by_age_cache(self) -&gt; dict:\n    \"\"\"\n    Creates cache (dictionary) of weighted sum of\n    non-symptomatic infectious people (IP and IA),\n    weighted by relative infectiousness, summed over risk\n    groups and categorized by age, for a given subpopulation.\n\n    Keys are the subpopulation name, values are the\n    |A| x |1| array corresponding to the above weighted sum,\n    where |A| is the number of age groups.\n    \"\"\"\n\n    wtd_no_symp_by_age_cache = {}\n\n    for subpop_model in self.subpop_models.values():\n        wtd_no_symp_by_age_cache[subpop_model.name] = \\\n            compute_wtd_presymp_asymp(subpop_model.state,\n                                      subpop_model.params)\n\n    return wtd_no_symp_by_age_cache\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.inf_from_home_region_movement","title":"<code>inf_from_home_region_movement(subpop_name: str, wtd_no_symp_by_age_cache: dict, effective_pop_by_age_cache: dict) -&gt; np.ndarray</code>","text":"<p>Returns |A| x 1 array corresponding to infection rate due to residents in given subpopulation traveling within their own subpopulation, where |A| is the number of age groups.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def inf_from_home_region_movement(self,\n                                  subpop_name: str,\n                                  wtd_no_symp_by_age_cache: dict,\n                                  effective_pop_by_age_cache: dict) -&gt; np.ndarray:\n    \"\"\"\n    Returns |A| x 1 array corresponding to infection rate due to\n    residents in given subpopulation traveling within their own\n    subpopulation, where |A| is the number of age groups.\n    \"\"\"\n\n    # Math reminder -- other than the summation over proportion of residents\n    #   traveling, there is only ONE subpopulation index here.\n\n    subpop_model = self.subpop_models[subpop_name]\n    subpop_state = subpop_model.state\n    subpop_params = subpop_model.params\n    subpop_names_mapping = self.subpop_names_mapping\n\n    prop_time_away_by_age = subpop_params.prop_time_away_by_age\n    sum_prop_residents_traveling_out = \\\n        self.sum_prop_residents_traveling_out_array[subpop_names_mapping[subpop_name]]\n\n    contact_matrix = subpop_state.flu_contact_matrix\n    wtd_infected_by_age = \\\n        wtd_no_symp_by_age_cache[subpop_name] + \\\n        np.sum(subpop_state.IS, axis=1, keepdims=True)\n\n    wtd_infected_to_pop_ratio = np.divide(wtd_infected_by_age,\n                                          effective_pop_by_age_cache[subpop_name])\n\n    common_coeff = compute_common_coeff_force_of_infection(subpop_state, subpop_params)\n\n    return common_coeff * (1 - prop_time_away_by_age * sum_prop_residents_traveling_out) * \\\n           np.matmul(contact_matrix, wtd_infected_to_pop_ratio)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.inf_from_residents_traveling","title":"<code>inf_from_residents_traveling(subpop_name: str, wtd_no_symp_by_age_cache: dict, effective_pop_by_age_cache: dict) -&gt; np.ndarray</code>","text":"<p>Returns |A| x 1 array corresponding to infection rate to given subpopulation, due to residents getting infected while visiting other subpopulations and then bringing the infections back home, where |A| is the number of age groups.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def inf_from_residents_traveling(self,\n                                 subpop_name: str,\n                                 wtd_no_symp_by_age_cache: dict,\n                                 effective_pop_by_age_cache: dict) -&gt; np.ndarray:\n    \"\"\"\n    Returns |A| x 1 array corresponding to infection rate to given\n    subpopulation, due to residents getting infected while visiting\n    other subpopulations and then bringing the infections back home,\n    where |A| is the number of age groups.\n    \"\"\"\n\n    subpop_model = self.subpop_models[subpop_name]\n    subpop_state = subpop_model.state\n    subpop_params = subpop_model.params\n\n    all_subpop_models_names = self.subpop_models.keys()\n\n    # Create a list to store all pairwise values\n    # Each element corresponds to the infection rate due to\n    #   residents visiting another subpopulation\n    # These elements are summed to obtain the overall infection rate\n    #   from residents getting infected in ALL other subpopulations\n    inf_from_residents_traveling_pairwise = []\n\n    for dest_subpop_name in all_subpop_models_names:\n\n        if dest_subpop_name == subpop_name:\n            continue\n\n        else:\n            # Math reminder -- the weighted sum of infected people AND\n            #   the effective population refers to the OTHER subpopulation\n            #   -- because we are dealing with residents that get\n            #   infected in OTHER subpopulations\n\n            prop_residents_traveling_pairwise = self.prop_residents_traveling_pairwise(\n                subpop_name, dest_subpop_name\n            )\n\n            prop_time_away_by_age = subpop_params.prop_time_away_by_age\n\n            contact_matrix = subpop_state.flu_contact_matrix\n\n            dest_subpop_model = self.subpop_models[dest_subpop_name]\n            dest_subpop_state = dest_subpop_model.state\n\n            # Weighted infected at DESTINATION subpopulation\n            wtd_infected_dest_by_age = \\\n                wtd_no_symp_by_age_cache[dest_subpop_name] + \\\n                np.sum(dest_subpop_state.IS, axis=1, keepdims=True)\n\n            # Ratio of weighted infected (at destination) to\n            #   effective population (at destination)\n            wtd_infected_to_pop_dest_ratio = \\\n                np.divide(wtd_infected_dest_by_age,\n                          effective_pop_by_age_cache[dest_subpop_name])\n\n            inf_from_residents_traveling_pairwise.append(\n                prop_residents_traveling_pairwise *\n                wtd_infected_to_pop_dest_ratio *\n                np.matmul(contact_matrix,\n                          prop_time_away_by_age))\n\n    common_coeff = compute_common_coeff_force_of_infection(subpop_state, subpop_params)\n\n    return np.sum(common_coeff * subpop_params.contact_mult_travel *\n                  inf_from_residents_traveling_pairwise, axis=0)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.inf_from_visitors","title":"<code>inf_from_visitors(subpop_name: str, wtd_no_symp_by_age_cache: dict, effective_pop_by_age_cache: dict) -&gt; np.ndarray</code>","text":"<p>Returns |L| x |A| x 1 array corresponding to infection rate to given subpopulation, due to outside visitors from other subpopulations, where |A| is the number of age groups.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def inf_from_visitors(self,\n                      subpop_name: str,\n                      wtd_no_symp_by_age_cache: dict,\n                      effective_pop_by_age_cache: dict) -&gt; np.ndarray:\n    \"\"\"\n    Returns |L| x |A| x 1 array corresponding to infection rate to given\n    subpopulation, due to outside visitors from other subpopulations,\n    where |A| is the number of age groups.\n    \"\"\"\n\n    subpop_model = self.subpop_models[subpop_name]\n    subpop_state = subpop_model.state\n    subpop_params = subpop_model.params\n\n    all_subpop_models_names = self.subpop_models.keys()\n\n    # Create a list to store all pairwise values\n    # Each element corresponds to the infection rate due to\n    #   visitors from another subpopulation\n    # These elements are summed to obtain the overall infection rate\n    #   from outside visitors from ALL other subpopulations\n    inf_from_visitors_pairwise = []\n\n    for visitors_subpop_name in all_subpop_models_names:\n\n        # Do not include residential travel within same subpopulation\n        #   -- this is handled with inf_from_home_region_movement\n        if visitors_subpop_name == subpop_name:\n            continue\n\n        else:\n            # Math reminder -- the weighted sum of infected people is for\n            #   other subpopulations, but the other indices/values are for\n            #   the input subpopulation.\n\n            contact_mult_symp = subpop_params.contact_mult_symp\n\n            prop_residents_traveling_pairwise = \\\n                self.prop_residents_traveling_pairwise(visitors_subpop_name,\n                                                       subpop_name)\n\n            prop_time_away_by_age = subpop_params.prop_time_away_by_age\n\n            contact_matrix = subpop_state.flu_contact_matrix\n\n            visitors_subpop_model = self.subpop_models[visitors_subpop_name]\n            visitors_subpop_state = visitors_subpop_model.state\n\n            wtd_infected_visitors_by_age = \\\n                wtd_no_symp_by_age_cache[visitors_subpop_name] + \\\n                contact_mult_symp * np.sum(visitors_subpop_state.IS, axis=1, keepdims=True)\n\n            wtd_infected_to_pop_ratio = \\\n                np.divide(wtd_infected_visitors_by_age,\n                          effective_pop_by_age_cache[subpop_name])\n\n            inf_from_visitors_pairwise.append(\n                prop_residents_traveling_pairwise *\n                np.matmul(contact_matrix,\n                          prop_time_away_by_age * wtd_infected_to_pop_ratio))\n\n    common_coeff = compute_common_coeff_force_of_infection(subpop_state, subpop_params)\n\n    return np.sum(common_coeff * subpop_params.contact_mult_travel *\n                  np.asarray(inf_from_visitors_pairwise), axis=0)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.prop_residents_traveling_pairwise","title":"<code>prop_residents_traveling_pairwise(origin_subpop_name: str, dest_subpop_name: str) -&gt; float</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>the proportion in [0,1] of residents in given origin subpopulation who travel to the given destination subpopulation.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def prop_residents_traveling_pairwise(self,\n                                      origin_subpop_name: str,\n                                      dest_subpop_name: str) -&gt; float:\n    \"\"\"\n    Returns:\n         (float):\n            the proportion in [0,1] of residents in given origin subpopulation\n            who travel to the given destination subpopulation.\n    \"\"\"\n\n    subpop_names_mapping = self.subpop_names_mapping\n\n    return self.travel_proportions_array[subpop_names_mapping[origin_subpop_name],\n                                         subpop_names_mapping[dest_subpop_name]]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluInterSubpopRepo.sum_wtd_visitors_by_age","title":"<code>sum_wtd_visitors_by_age(subpop_name: str, pop_healthy_by_age: dict) -&gt; np.ndarray</code>","text":"<p>Returns |A| x 1 array corresponding to weighted visitors to given subpopulation, where |A| is the number of age groups.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def sum_wtd_visitors_by_age(self,\n                            subpop_name: str,\n                            pop_healthy_by_age: dict) -&gt; np.ndarray:\n    \"\"\"\n    Returns |A| x 1 array corresponding to weighted visitors\n    to given subpopulation, where |A| is the number of age groups.\n    \"\"\"\n\n    wtd_visitors_by_origin = []\n\n    for origin_subpop_name in self.subpop_models.keys():\n        if origin_subpop_name == subpop_name:\n            continue\n        else:\n            wtd_visitors_by_origin.append(\n                self.prop_residents_traveling_pairwise(origin_subpop_name,\n                                                       subpop_name) *\n                pop_healthy_by_age[origin_subpop_name])\n\n    return np.sum(wtd_visitors_by_origin, axis=1)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluMetapopModel","title":"<code>FluMetapopModel</code>","text":"<p>               Bases: <code>MetapopModel</code></p> <p>MetapopModel-derived class specific to flu model. Assigns an instance of FluInterSubpopRepo to model -- the repository holds all subpopulation models included in the metapopulation model, and also a DataFrame with travel proportions information.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class FluMetapopModel(clt.MetapopModel):\n    \"\"\"\n    MetapopModel-derived class specific to flu model.\n    Assigns an instance of FluInterSubpopRepo to model --\n    the repository holds all subpopulation models included\n    in the metapopulation model, and also a DataFrame with\n    travel proportions information.\n    \"\"\"\n\n    def check_travel_proportions(self,\n                                 include_printing=True):\n        \"\"\"\n        Checks to make sure travel_proportions_mapping and\n        travel_proportions_array (located on InterSubpopRepo instance)\n        have correct format on MetapopModel.\n\n        Validates that subpop_names_mapping is a dictionary\n        whose keys are names of associated SubpopModel instances and\n        whose length matches both the number of rows and columns of\n        travel_proportions_array (is a square matrix). Makes sure that\n        numerical values in travel_proportions_array are between [0,1].\n        \"\"\"\n\n        if include_printing:\n            print(\"&gt;&gt;&gt; Running travel proportions checks... \\n\")\n            print(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\")\n\n        error_counter = 0\n\n        # Extract unique subpop_name values\n        # Ensure uniqueness\n        # Ensure they match the unique string IDs of each associated\n        #   SubpopModel instance\n        subpop_names = self.inter_subpop_repo.subpop_names_mapping\n        num_subpop_names = len(subpop_names)\n        travel_proportions_array = self.inter_subpop_repo.travel_proportions_array\n        if np.size(travel_proportions_array) != \\\n                (num_subpop_names, num_subpop_names):\n            error_counter += 1\n            if include_printing:\n                print(\"Length of subpop_names_mapping dictionary must equal \"\n                      \"number of rows and number of columns of travel_proportions_array.\")\n        if set(subpop_names) != set(self.subpop_models.keys()):\n            error_counter += 1\n            if include_printing:\n                print(\"Each key in subpop_names_mapping must match a \"\n                      \"name of an associated SubpopModel instance.\")\n\n        # Check if other values are between 0 and 1\n        if not ((travel_proportions_array &gt;= 0).all() and (travel_proportions_array &lt;= 1).all()):\n            error_counter += 1\n            if include_printing:\n                print(\"All numerical values must be between 0 and 1 \"\n                      \"because they represent proportions.\")\n\n        if error_counter == 0:\n            if include_printing:\n                print(\"OKAY! Travel proportions input into FluMetapopModel is \"\n                      \"correctly formatted.\")\n            return True\n        else:\n            if include_printing:\n                print(f\"Need to fix {error_counter} errors before simulating model.\")\n            return False\n\n    def run_model_checks(self):\n\n        self.check_travel_proportions()\n\n        for subpop_model in self.subpop_models.values():\n            subpop_model.run_model_checks()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluMetapopModel.check_travel_proportions","title":"<code>check_travel_proportions(include_printing=True)</code>","text":"<p>Checks to make sure travel_proportions_mapping and travel_proportions_array (located on InterSubpopRepo instance) have correct format on MetapopModel.</p> <p>Validates that subpop_names_mapping is a dictionary whose keys are names of associated SubpopModel instances and whose length matches both the number of rows and columns of travel_proportions_array (is a square matrix). Makes sure that numerical values in travel_proportions_array are between [0,1].</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def check_travel_proportions(self,\n                             include_printing=True):\n    \"\"\"\n    Checks to make sure travel_proportions_mapping and\n    travel_proportions_array (located on InterSubpopRepo instance)\n    have correct format on MetapopModel.\n\n    Validates that subpop_names_mapping is a dictionary\n    whose keys are names of associated SubpopModel instances and\n    whose length matches both the number of rows and columns of\n    travel_proportions_array (is a square matrix). Makes sure that\n    numerical values in travel_proportions_array are between [0,1].\n    \"\"\"\n\n    if include_printing:\n        print(\"&gt;&gt;&gt; Running travel proportions checks... \\n\")\n        print(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\")\n\n    error_counter = 0\n\n    # Extract unique subpop_name values\n    # Ensure uniqueness\n    # Ensure they match the unique string IDs of each associated\n    #   SubpopModel instance\n    subpop_names = self.inter_subpop_repo.subpop_names_mapping\n    num_subpop_names = len(subpop_names)\n    travel_proportions_array = self.inter_subpop_repo.travel_proportions_array\n    if np.size(travel_proportions_array) != \\\n            (num_subpop_names, num_subpop_names):\n        error_counter += 1\n        if include_printing:\n            print(\"Length of subpop_names_mapping dictionary must equal \"\n                  \"number of rows and number of columns of travel_proportions_array.\")\n    if set(subpop_names) != set(self.subpop_models.keys()):\n        error_counter += 1\n        if include_printing:\n            print(\"Each key in subpop_names_mapping must match a \"\n                  \"name of an associated SubpopModel instance.\")\n\n    # Check if other values are between 0 and 1\n    if not ((travel_proportions_array &gt;= 0).all() and (travel_proportions_array &lt;= 1).all()):\n        error_counter += 1\n        if include_printing:\n            print(\"All numerical values must be between 0 and 1 \"\n                  \"because they represent proportions.\")\n\n    if error_counter == 0:\n        if include_printing:\n            print(\"OKAY! Travel proportions input into FluMetapopModel is \"\n                  \"correctly formatted.\")\n        return True\n    else:\n        if include_printing:\n            print(f\"Need to fix {error_counter} errors before simulating model.\")\n        return False\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel","title":"<code>FluSubpopModel</code>","text":"<p>               Bases: <code>SubpopModel</code></p> <p>Class for creating ImmunoSEIRS flu model with predetermined fixed structure -- initial values and epidemiological structure are populated by user-specified JSON files.</p> <p>Key method create_transmission_model returns a SubpopModel instance with S-E-I-H-R-D compartments and pop_immunity_inf and pop_immunity_hosp epi metrics. </p> The update structure is as follows <ul> <li>S &lt;- S + R_to_S - S_to_E</li> <li>E &lt;- E + S_to_E - E_to_IP - E_to_IA</li> <li>IA &lt;- IA + E_to_IA - IA_to_R </li> <li>IP &lt;- IP + E_to_IP - IP_to_IS</li> <li>IS &lt;- IS + IP_to_IS - IS_to_R - IS_to_H</li> <li>H &lt;- H + IS_to_H - H_to_R - H_to_D</li> <li>R &lt;- R + IS_to_R + H_to_R - R_to_S</li> <li>D &lt;- D + H_to_D</li> </ul> The following are TransitionVariable instances <ul> <li>R_to_S is a RecoveredToSusceptible instance</li> <li>S_to_E is a SusceptibleToExposed instance</li> <li>IP_to_IS is a PresympToSymp instance</li> <li>IS_to_H is a SympToHosp instance</li> <li>IS_to_R is a SympToRecovered instance</li> <li>H_to_R is a HospToRecovered instance</li> <li>H_to_D is a HospToDead instance</li> </ul> There are three TransitionVariableGroups <ul> <li>E_out (handles E_to_IP and E_to_IA)</li> <li>IS_out (handles IS_to_H and IS_to_R)</li> <li>H_out (handles H_to_R and H_to_D)</li> </ul> The following are EpiMetric instances <ul> <li>pop_immunity_inf is a PopulationImmunityInf instance</li> <li>pop_immunity_hosp is a PopulationImmunityHosp instance</li> </ul> <p>Transition rates and update formulas are specified in     corresponding classes.</p> <p>See parent class SubpopModel's docstring for additional attributes.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class FluSubpopModel(clt.SubpopModel):\n    \"\"\"\n    Class for creating ImmunoSEIRS flu model with predetermined fixed\n    structure -- initial values and epidemiological structure are\n    populated by user-specified JSON files.\n\n    Key method create_transmission_model returns a SubpopModel\n    instance with S-E-I-H-R-D compartments and pop_immunity_inf\n    and pop_immunity_hosp epi metrics. \n\n    The update structure is as follows:\n        - S &lt;- S + R_to_S - S_to_E\n        - E &lt;- E + S_to_E - E_to_IP - E_to_IA\n        - IA &lt;- IA + E_to_IA - IA_to_R \n        - IP &lt;- IP + E_to_IP - IP_to_IS\n        - IS &lt;- IS + IP_to_IS - IS_to_R - IS_to_H\n        - H &lt;- H + IS_to_H - H_to_R - H_to_D\n        - R &lt;- R + IS_to_R + H_to_R - R_to_S\n        - D &lt;- D + H_to_D\n\n    The following are TransitionVariable instances:\n        - R_to_S is a RecoveredToSusceptible instance\n        - S_to_E is a SusceptibleToExposed instance\n        - IP_to_IS is a PresympToSymp instance\n        - IS_to_H is a SympToHosp instance\n        - IS_to_R is a SympToRecovered instance\n        - H_to_R is a HospToRecovered instance\n        - H_to_D is a HospToDead instance\n\n    There are three TransitionVariableGroups:\n        - E_out (handles E_to_IP and E_to_IA)\n        - IS_out (handles IS_to_H and IS_to_R)\n        - H_out (handles H_to_R and H_to_D)\n\n    The following are EpiMetric instances:\n        - pop_immunity_inf is a PopulationImmunityInf instance\n        - pop_immunity_hosp is a PopulationImmunityHosp instance\n\n    Transition rates and update formulas are specified in\n        corresponding classes.\n\n    See parent class SubpopModel's docstring for additional attributes.\n    \"\"\"\n\n    def __init__(self,\n                 compartments_epi_metrics: dict,\n                 params: dict,\n                 config: dict,\n                 calendar_df: pd.DataFrame,\n                 RNG: np.random.Generator,\n                 name: str = \"\",\n                 wastewater_enabled: bool = False):\n        \"\"\"\n        Args:\n            compartments_epi_metrics (dict):\n                holds current simulation state information,\n                such as current values of epidemiological compartments\n                and epi metrics -- keys and values respectively\n                must match field names and format of FluSubpopState.\n            params (dict):\n                holds epidemiological parameter values -- keys and\n                values respectively must match field names and\n                format of FluSubpopParams.\n            config (dict):\n                holds configuration values -- keys and values\n                respectively must match field names and format of\n                Config.\n            calendar_df (pd.DataFrame):\n                DataFrame with columns \"date\", \"is_school_day\", and\n                \"is_work_day\" -- \"date\" entries are either strings\n                format with \"YYYY-MM-DD\" or datetime.date objects,\n                and \"is_school_day\" and \"is_work_day\" entries are\n                Booleans indicating if that date is a school\n                day or work day\n            RNG (np.random.Generator):\n                numpy random generator object used to obtain\n                random numbers.\n            name (str):\n                unique name of MetapopModel instance.\n            wastewater_enabled (bool):\n                if True, includes \"wastewater\" EpiMetric. Otherwise,\n                excludes it.\n        \"\"\"\n\n        # Assign config, params, and state to model-specific\n        # types of dataclasses that have epidemiological parameter information\n        # and sim state information\n\n        self.wastewater_enabled = wastewater_enabled\n\n        if not all(isinstance(val, datetime.date) for val in calendar_df[\"date\"]):\n            try:\n                calendar_df[\"date\"] = pd.to_datetime(calendar_df[\"date\"], format=\"%Y-%m-%d\").dt.date\n            except ValueError:\n                print(\"Error: The date format should be YYYY-MM-DD.\")\n\n        self.calendar_df = calendar_df\n\n        state = clt.make_dataclass_from_dict(FluSubpopState, compartments_epi_metrics)\n        params = clt.make_dataclass_from_dict(FluSubpopParams, params)\n        config = clt.make_dataclass_from_dict(clt.Config, config)\n\n        # IMPORTANT NOTE: as always, we must be careful with mutable objects\n        #   and generally use deep copies to avoid modification of the same\n        #   object. But in this function call, using deep copies is unnecessary\n        #   (redundant) because the parent class SubpopModel's __init__()\n        #   creates deep copies.\n        super().__init__(state, params, config, RNG, name)\n\n    def create_interaction_terms(self) -&gt; sc.objdict:\n        \"\"\"\n        If there is no associated MetapopModel, then\n        there is no travel model, so do not create ForceOfInfection\n        instance -- there are no interaction terms for this\n        SubpopModel.\n        \"\"\"\n\n        if self.metapop_model:\n            interaction_terms = sc.objdict()\n            interaction_terms[\"force_of_infection\"] = ForceOfInfection(self.name)\n            return interaction_terms\n\n        else:\n            return sc.objdict()\n\n    def create_compartments(self) -&gt; sc.objdict:\n        \"\"\"\n        Create Compartment instances S-E-IA-IP-IS-H-R-D (7 compartments total),\n            save in sc.objdict, and return objdict\n        \"\"\"\n\n        compartments = sc.objdict()\n\n        for name in (\"S\", \"E\", \"IP\", \"IS\", \"IA\", \"H\", \"R\", \"D\"):\n            compartments[name] = clt.Compartment(getattr(self.state, name))\n\n        return compartments\n\n    def create_dynamic_vals(self) -&gt; sc.objdict:\n        \"\"\"\n        Create all DynamicVal instances, save in sc.objdict, and return objdict\n        \"\"\"\n\n        dynamic_vals = sc.objdict()\n\n        dynamic_vals[\"beta_reduct\"] = BetaReduct(init_val=0.0,\n                                                 is_enabled=False)\n\n        return dynamic_vals\n\n    def create_schedules(self) -&gt; sc.objdict():\n        \"\"\"\n        Create all Schedule instances, save in sc.objdict, and return objdict\n        \"\"\"\n\n        schedules = sc.objdict()\n\n        schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n        schedules[\"flu_contact_matrix\"] = FluContactMatrix(init_val=None,\n                                                           calendar_df=self.calendar_df)\n\n        return schedules\n\n    def create_transition_variables(self) -&gt; sc.objdict:\n        \"\"\"\n        Create all TransitionVariable instances,\n            save in sc.objdict, and return objdict\n        \"\"\"\n\n        # NOTE: see the parent class SubpopModel's __init__() --\n        #   create_transition_variables is called after\n        #   self.config is assigned and after self.compartments\n        #   has been created -- so these variables do exist\n        # TODO: there is potentially a better way to design this\n        #   (in SubpopModel) to be more EXPLICIT -- think about this...\n\n        transition_type = self.config.transition_type\n        compartments = self.compartments\n\n        transition_variables = sc.objdict()\n\n        S = compartments.S\n        E = compartments.E\n        IP = compartments.IP\n        IS = compartments.IS\n        IA = compartments.IA\n        H = compartments.H\n        R = compartments.R\n        D = compartments.D\n\n        transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n        transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n        transition_variables.IP_to_IS = PresympToSymp(IP, IS, transition_type)\n        transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n        transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n        transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n        transition_variables.IS_to_R = SympToRecovered(IS, R, transition_type, True)\n        transition_variables.IS_to_H = SympToHosp(IS, H, transition_type, True)\n        transition_variables.H_to_R = HospToRecovered(H, R, transition_type, True)\n        transition_variables.H_to_D = HospToDead(H, D, transition_type, True)\n\n        return transition_variables\n\n    def create_transition_variable_groups(self) -&gt; sc.objdict:\n        \"\"\"\n        Create all transition variable groups described in docstring (2 transition\n        variable groups total), save in sc.objdict, return\n        \"\"\"\n\n        # Shortcuts for attribute access\n        # NOTE: see the parent class SubpopModel's __init__() --\n        #   create_transition_variable_groups is called after\n        #   self.config is assigned and after\n        #   self.compartments and self.transition_variables are created\n        #   -- so these variables do exist\n        # See similar NOTE in create_transition_variables function\n        transition_type = self.config.transition_type\n        compartments = self.compartments\n        transition_variables = self.transition_variables\n\n        transition_variable_groups = sc.objdict()\n\n        transition_variable_groups.E_out = clt.TransitionVariableGroup(compartments.E,\n                                                                       transition_type,\n                                                                       (transition_variables.E_to_IP,\n                                                                        transition_variables.E_to_IA))\n\n        transition_variable_groups.IS_out = clt.TransitionVariableGroup(compartments.IS,\n                                                                        transition_type,\n                                                                        (transition_variables.IS_to_R,\n                                                                         transition_variables.IS_to_H))\n\n        transition_variable_groups.H_out = clt.TransitionVariableGroup(compartments.H,\n                                                                       transition_type,\n                                                                       (transition_variables.H_to_R,\n                                                                        transition_variables.H_to_D))\n\n        return transition_variable_groups\n\n    def create_epi_metrics(self) -&gt; sc.objdict:\n        \"\"\"\n        Create all epi metric described in docstring (2 state\n        variables total), save in sc.objdict, and return objdict\n        \"\"\"\n\n        epi_metrics = sc.objdict()\n\n        # Shortcuts for attribute access\n        # NOTE: see the parent class SubpopModel's __init__() --\n        #   create_epi_metrics is called after self.transition_variables\n        #   are created -- so this variable exists\n        # See similar NOTE in create_transition_variables\n        #   and create_transition_variable_groups function\n        transition_variables = self.transition_variables\n\n        epi_metrics.pop_immunity_inf = \\\n            PopulationImmunityInf(getattr(self.state, \"pop_immunity_inf\"),\n                                  transition_variables.R_to_S)\n\n        if self.wastewater_enabled:\n            epi_metrics.wastewater = \\\n                Wastewater(getattr(self.state, \"wastewater\"),  # initial value is set to null for now\n                           transition_variables.S_to_E)\n\n        epi_metrics.pop_immunity_hosp = \\\n            PopulationImmunityHosp(getattr(self.state, \"pop_immunity_hosp\"),\n                                   transition_variables.R_to_S)\n\n        return epi_metrics\n\n    def run_model_checks(self,\n                         include_printing=True):\n        \"\"\"\n        Run flu model checks.\n\n        Input checks:\n            - SubpopState and SubpopParams instances should have\n                fields with nonnegative values.\n            - Initial values of compartments should be nonnegative\n                integers.\n            - Population sum of compartments should match\n                total population computed at initialization\n                (user should not change initial values\n                after initialization).\n        \"\"\"\n\n        if include_printing:\n            print(\"&gt;&gt;&gt; Running FluSubpopModel checks... \\n\")\n            print(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\")\n\n        error_counter = 0\n\n        state = self.state\n        params = self.params\n\n        for name, val in list(vars(state).items()) + list(vars(params).items()):\n            if isinstance(val, np.ndarray):\n                flattened_array = val.flatten()\n                for val in flattened_array:\n                    if val &lt; 0:\n                        if include_printing:\n                            print(f\"STOP! INPUT ERROR: {name} should not have negative values.\")\n                        error_counter += 1\n            elif isinstance(val, float):\n                if val &lt; 0:\n                    if include_printing:\n                        print(f\"STOP! INPUT ERROR: {name} should not be negative.\")\n                    error_counter += 1\n\n        compartment_population_sum = np.zeros((self.params.num_age_groups,\n                                               self.params.num_risk_groups))\n\n        for name, compartment in self.compartments.items():\n            compartment_population_sum += compartment.current_val\n            flattened_current_val = compartment.current_val.flatten()\n            for val in flattened_current_val:\n                if val != int(val):\n                    if include_printing:\n                        print(f\"STOP! INPUT ERROR: {name} should not have non-integer values.\")\n                    error_counter += 1\n                if val &lt; 0:\n                    if include_printing:\n                        print(f\"STOP! INPUT ERROR: {name} should not have negative values.\")\n                    error_counter += 1\n\n        if (compartment_population_sum != self.params.total_pop_age_risk).any():\n            if include_printing:\n                print(f\"STOP! INPUT ERROR: sum of population in compartments must \\n\"\n                      f\"match specified total population value. Check \\n\"\n                      f\"\\\"total_pop_age_risk\\\" in model's \\\"params\\\" attribute \\n\"\n                      f\"and check compartments in state variables' init vals JSON.\")\n            error_counter += 1\n\n        if error_counter == 0:\n            if include_printing:\n                print(\"OKAY! FluSubpopModel instance has passed input checks: \\n\"\n                      \"Compartment populations are nonnegative whole numbers \\n\"\n                      \"and add up to \\\"total_pop_age_risk\\\" in model's \\n\"\n                      \"\\\"params attribute.\\\" Fixed parameters are nonnegative.\")\n            return True\n        else:\n            if include_printing:\n                print(f\"Need to fix {error_counter} errors before simulating model.\")\n            return False\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.__init__","title":"<code>__init__(compartments_epi_metrics: dict, params: dict, config: dict, calendar_df: pd.DataFrame, RNG: np.random.Generator, name: str = '', wastewater_enabled: bool = False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>compartments_epi_metrics</code> <code>dict</code> <p>holds current simulation state information, such as current values of epidemiological compartments and epi metrics -- keys and values respectively must match field names and format of FluSubpopState.</p> required <code>params</code> <code>dict</code> <p>holds epidemiological parameter values -- keys and values respectively must match field names and format of FluSubpopParams.</p> required <code>config</code> <code>dict</code> <p>holds configuration values -- keys and values respectively must match field names and format of Config.</p> required <code>calendar_df</code> <code>DataFrame</code> <p>DataFrame with columns \"date\", \"is_school_day\", and \"is_work_day\" -- \"date\" entries are either strings format with \"YYYY-MM-DD\" or datetime.date objects, and \"is_school_day\" and \"is_work_day\" entries are Booleans indicating if that date is a school day or work day</p> required <code>RNG</code> <code>Generator</code> <p>numpy random generator object used to obtain random numbers.</p> required <code>name</code> <code>str</code> <p>unique name of MetapopModel instance.</p> <code>''</code> <code>wastewater_enabled</code> <code>bool</code> <p>if True, includes \"wastewater\" EpiMetric. Otherwise, excludes it.</p> <code>False</code> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def __init__(self,\n             compartments_epi_metrics: dict,\n             params: dict,\n             config: dict,\n             calendar_df: pd.DataFrame,\n             RNG: np.random.Generator,\n             name: str = \"\",\n             wastewater_enabled: bool = False):\n    \"\"\"\n    Args:\n        compartments_epi_metrics (dict):\n            holds current simulation state information,\n            such as current values of epidemiological compartments\n            and epi metrics -- keys and values respectively\n            must match field names and format of FluSubpopState.\n        params (dict):\n            holds epidemiological parameter values -- keys and\n            values respectively must match field names and\n            format of FluSubpopParams.\n        config (dict):\n            holds configuration values -- keys and values\n            respectively must match field names and format of\n            Config.\n        calendar_df (pd.DataFrame):\n            DataFrame with columns \"date\", \"is_school_day\", and\n            \"is_work_day\" -- \"date\" entries are either strings\n            format with \"YYYY-MM-DD\" or datetime.date objects,\n            and \"is_school_day\" and \"is_work_day\" entries are\n            Booleans indicating if that date is a school\n            day or work day\n        RNG (np.random.Generator):\n            numpy random generator object used to obtain\n            random numbers.\n        name (str):\n            unique name of MetapopModel instance.\n        wastewater_enabled (bool):\n            if True, includes \"wastewater\" EpiMetric. Otherwise,\n            excludes it.\n    \"\"\"\n\n    # Assign config, params, and state to model-specific\n    # types of dataclasses that have epidemiological parameter information\n    # and sim state information\n\n    self.wastewater_enabled = wastewater_enabled\n\n    if not all(isinstance(val, datetime.date) for val in calendar_df[\"date\"]):\n        try:\n            calendar_df[\"date\"] = pd.to_datetime(calendar_df[\"date\"], format=\"%Y-%m-%d\").dt.date\n        except ValueError:\n            print(\"Error: The date format should be YYYY-MM-DD.\")\n\n    self.calendar_df = calendar_df\n\n    state = clt.make_dataclass_from_dict(FluSubpopState, compartments_epi_metrics)\n    params = clt.make_dataclass_from_dict(FluSubpopParams, params)\n    config = clt.make_dataclass_from_dict(clt.Config, config)\n\n    # IMPORTANT NOTE: as always, we must be careful with mutable objects\n    #   and generally use deep copies to avoid modification of the same\n    #   object. But in this function call, using deep copies is unnecessary\n    #   (redundant) because the parent class SubpopModel's __init__()\n    #   creates deep copies.\n    super().__init__(state, params, config, RNG, name)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_compartments","title":"<code>create_compartments() -&gt; sc.objdict</code>","text":"<p>Create Compartment instances S-E-IA-IP-IS-H-R-D (7 compartments total),     save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_compartments(self) -&gt; sc.objdict:\n    \"\"\"\n    Create Compartment instances S-E-IA-IP-IS-H-R-D (7 compartments total),\n        save in sc.objdict, and return objdict\n    \"\"\"\n\n    compartments = sc.objdict()\n\n    for name in (\"S\", \"E\", \"IP\", \"IS\", \"IA\", \"H\", \"R\", \"D\"):\n        compartments[name] = clt.Compartment(getattr(self.state, name))\n\n    return compartments\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_dynamic_vals","title":"<code>create_dynamic_vals() -&gt; sc.objdict</code>","text":"<p>Create all DynamicVal instances, save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_dynamic_vals(self) -&gt; sc.objdict:\n    \"\"\"\n    Create all DynamicVal instances, save in sc.objdict, and return objdict\n    \"\"\"\n\n    dynamic_vals = sc.objdict()\n\n    dynamic_vals[\"beta_reduct\"] = BetaReduct(init_val=0.0,\n                                             is_enabled=False)\n\n    return dynamic_vals\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_epi_metrics","title":"<code>create_epi_metrics() -&gt; sc.objdict</code>","text":"<p>Create all epi metric described in docstring (2 state variables total), save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_epi_metrics(self) -&gt; sc.objdict:\n    \"\"\"\n    Create all epi metric described in docstring (2 state\n    variables total), save in sc.objdict, and return objdict\n    \"\"\"\n\n    epi_metrics = sc.objdict()\n\n    # Shortcuts for attribute access\n    # NOTE: see the parent class SubpopModel's __init__() --\n    #   create_epi_metrics is called after self.transition_variables\n    #   are created -- so this variable exists\n    # See similar NOTE in create_transition_variables\n    #   and create_transition_variable_groups function\n    transition_variables = self.transition_variables\n\n    epi_metrics.pop_immunity_inf = \\\n        PopulationImmunityInf(getattr(self.state, \"pop_immunity_inf\"),\n                              transition_variables.R_to_S)\n\n    if self.wastewater_enabled:\n        epi_metrics.wastewater = \\\n            Wastewater(getattr(self.state, \"wastewater\"),  # initial value is set to null for now\n                       transition_variables.S_to_E)\n\n    epi_metrics.pop_immunity_hosp = \\\n        PopulationImmunityHosp(getattr(self.state, \"pop_immunity_hosp\"),\n                               transition_variables.R_to_S)\n\n    return epi_metrics\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_interaction_terms","title":"<code>create_interaction_terms() -&gt; sc.objdict</code>","text":"<p>If there is no associated MetapopModel, then there is no travel model, so do not create ForceOfInfection instance -- there are no interaction terms for this SubpopModel.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_interaction_terms(self) -&gt; sc.objdict:\n    \"\"\"\n    If there is no associated MetapopModel, then\n    there is no travel model, so do not create ForceOfInfection\n    instance -- there are no interaction terms for this\n    SubpopModel.\n    \"\"\"\n\n    if self.metapop_model:\n        interaction_terms = sc.objdict()\n        interaction_terms[\"force_of_infection\"] = ForceOfInfection(self.name)\n        return interaction_terms\n\n    else:\n        return sc.objdict()\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_schedules","title":"<code>create_schedules() -&gt; sc.objdict()</code>","text":"<p>Create all Schedule instances, save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_schedules(self) -&gt; sc.objdict():\n    \"\"\"\n    Create all Schedule instances, save in sc.objdict, and return objdict\n    \"\"\"\n\n    schedules = sc.objdict()\n\n    schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n    schedules[\"flu_contact_matrix\"] = FluContactMatrix(init_val=None,\n                                                       calendar_df=self.calendar_df)\n\n    return schedules\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_transition_variable_groups","title":"<code>create_transition_variable_groups() -&gt; sc.objdict</code>","text":"<p>Create all transition variable groups described in docstring (2 transition variable groups total), save in sc.objdict, return</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_transition_variable_groups(self) -&gt; sc.objdict:\n    \"\"\"\n    Create all transition variable groups described in docstring (2 transition\n    variable groups total), save in sc.objdict, return\n    \"\"\"\n\n    # Shortcuts for attribute access\n    # NOTE: see the parent class SubpopModel's __init__() --\n    #   create_transition_variable_groups is called after\n    #   self.config is assigned and after\n    #   self.compartments and self.transition_variables are created\n    #   -- so these variables do exist\n    # See similar NOTE in create_transition_variables function\n    transition_type = self.config.transition_type\n    compartments = self.compartments\n    transition_variables = self.transition_variables\n\n    transition_variable_groups = sc.objdict()\n\n    transition_variable_groups.E_out = clt.TransitionVariableGroup(compartments.E,\n                                                                   transition_type,\n                                                                   (transition_variables.E_to_IP,\n                                                                    transition_variables.E_to_IA))\n\n    transition_variable_groups.IS_out = clt.TransitionVariableGroup(compartments.IS,\n                                                                    transition_type,\n                                                                    (transition_variables.IS_to_R,\n                                                                     transition_variables.IS_to_H))\n\n    transition_variable_groups.H_out = clt.TransitionVariableGroup(compartments.H,\n                                                                   transition_type,\n                                                                   (transition_variables.H_to_R,\n                                                                    transition_variables.H_to_D))\n\n    return transition_variable_groups\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_transition_variables","title":"<code>create_transition_variables() -&gt; sc.objdict</code>","text":"<p>Create all TransitionVariable instances,     save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_transition_variables(self) -&gt; sc.objdict:\n    \"\"\"\n    Create all TransitionVariable instances,\n        save in sc.objdict, and return objdict\n    \"\"\"\n\n    # NOTE: see the parent class SubpopModel's __init__() --\n    #   create_transition_variables is called after\n    #   self.config is assigned and after self.compartments\n    #   has been created -- so these variables do exist\n    # TODO: there is potentially a better way to design this\n    #   (in SubpopModel) to be more EXPLICIT -- think about this...\n\n    transition_type = self.config.transition_type\n    compartments = self.compartments\n\n    transition_variables = sc.objdict()\n\n    S = compartments.S\n    E = compartments.E\n    IP = compartments.IP\n    IS = compartments.IS\n    IA = compartments.IA\n    H = compartments.H\n    R = compartments.R\n    D = compartments.D\n\n    transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n    transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n    transition_variables.IP_to_IS = PresympToSymp(IP, IS, transition_type)\n    transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n    transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n    transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n    transition_variables.IS_to_R = SympToRecovered(IS, R, transition_type, True)\n    transition_variables.IS_to_H = SympToHosp(IS, H, transition_type, True)\n    transition_variables.H_to_R = HospToRecovered(H, R, transition_type, True)\n    transition_variables.H_to_D = HospToDead(H, D, transition_type, True)\n\n    return transition_variables\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.run_model_checks","title":"<code>run_model_checks(include_printing=True)</code>","text":"<p>Run flu model checks.</p> Input checks <ul> <li>SubpopState and SubpopParams instances should have     fields with nonnegative values.</li> <li>Initial values of compartments should be nonnegative     integers.</li> <li>Population sum of compartments should match     total population computed at initialization     (user should not change initial values     after initialization).</li> </ul> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def run_model_checks(self,\n                     include_printing=True):\n    \"\"\"\n    Run flu model checks.\n\n    Input checks:\n        - SubpopState and SubpopParams instances should have\n            fields with nonnegative values.\n        - Initial values of compartments should be nonnegative\n            integers.\n        - Population sum of compartments should match\n            total population computed at initialization\n            (user should not change initial values\n            after initialization).\n    \"\"\"\n\n    if include_printing:\n        print(\"&gt;&gt;&gt; Running FluSubpopModel checks... \\n\")\n        print(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\")\n\n    error_counter = 0\n\n    state = self.state\n    params = self.params\n\n    for name, val in list(vars(state).items()) + list(vars(params).items()):\n        if isinstance(val, np.ndarray):\n            flattened_array = val.flatten()\n            for val in flattened_array:\n                if val &lt; 0:\n                    if include_printing:\n                        print(f\"STOP! INPUT ERROR: {name} should not have negative values.\")\n                    error_counter += 1\n        elif isinstance(val, float):\n            if val &lt; 0:\n                if include_printing:\n                    print(f\"STOP! INPUT ERROR: {name} should not be negative.\")\n                error_counter += 1\n\n    compartment_population_sum = np.zeros((self.params.num_age_groups,\n                                           self.params.num_risk_groups))\n\n    for name, compartment in self.compartments.items():\n        compartment_population_sum += compartment.current_val\n        flattened_current_val = compartment.current_val.flatten()\n        for val in flattened_current_val:\n            if val != int(val):\n                if include_printing:\n                    print(f\"STOP! INPUT ERROR: {name} should not have non-integer values.\")\n                error_counter += 1\n            if val &lt; 0:\n                if include_printing:\n                    print(f\"STOP! INPUT ERROR: {name} should not have negative values.\")\n                error_counter += 1\n\n    if (compartment_population_sum != self.params.total_pop_age_risk).any():\n        if include_printing:\n            print(f\"STOP! INPUT ERROR: sum of population in compartments must \\n\"\n                  f\"match specified total population value. Check \\n\"\n                  f\"\\\"total_pop_age_risk\\\" in model's \\\"params\\\" attribute \\n\"\n                  f\"and check compartments in state variables' init vals JSON.\")\n        error_counter += 1\n\n    if error_counter == 0:\n        if include_printing:\n            print(\"OKAY! FluSubpopModel instance has passed input checks: \\n\"\n                  \"Compartment populations are nonnegative whole numbers \\n\"\n                  \"and add up to \\\"total_pop_age_risk\\\" in model's \\n\"\n                  \"\\\"params attribute.\\\" Fixed parameters are nonnegative.\")\n        return True\n    else:\n        if include_printing:\n            print(f\"Need to fix {error_counter} errors before simulating model.\")\n        return False\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopParams","title":"<code>FluSubpopParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubpopParams</code></p> <p>Data container for pre-specified and fixed epidemiological parameters in FluModel flu model.</p> <p>Each field of datatype np.ndarray must be |A| x |R|, where |A| is the number of age groups and |R| is the number of risk groups. Note: this means all arrays should be 2D. See FluSubpopState docstring for important formatting note on 2D arrays.</p> TODO <p>when adding multiple strains, need to add subscripts to math of attributes and add strain-specific description</p> <p>Attributes:</p> Name Type Description <code>num_age_groups</code> <code>positive int</code> <p>number of age groups.</p> <code>num_risk_groups</code> <code>positive int</code> <p>number of risk groups.</p> <code>beta_baseline</code> <code>positive float</code> <p>transmission rate.</p> <code>total_pop_age_risk</code> <code>np.ndarray of positive ints</code> <p>total number in population, summed across all age-risk groups.</p> <code>humidity_impact</code> <code>positive float</code> <p>coefficient that determines how much absolute humidity affects beta_baseline.</p> <code>hosp_immune_gain</code> <code>positive float</code> <p>factor by which population-level immunity against hospitalization grows after each case that recovers.</p> <code>inf_immune_gain</code> <code>positive float</code> <p>factor by which population-level immunity against infection grows after each case     that recovers.</p> <code>immune_saturation</code> <code>np.ndarray of positive floats</code> <p>constant(s) modeling saturation of antibody production of individuals.</p> <code>hosp_immune_wane</code> <code>positive float</code> <p>rate at which infection-induced immunity against hospitalization wanes.</p> <code>inf_immune_wane</code> <code>positive float</code> <p>rate at which infection-induced immunity against infection wanes.</p> <code>hosp_risk_reduce</code> <code>positive float in [0,1]</code> <p>reduction in hospitalization risk from infection-induced immunity.</p> <code>inf_risk_reduce</code> <code>positive float in [0,1]</code> <p>reduction in infection risk from infection-induced immunity.</p> <code>death_risk_reduce</code> <code>positive float in [0,1]</code> <p>reduction in death risk from infection-induced immunity.</p> <code>R_to_S_rate</code> <code>positive float</code> <p>rate at which people in R move to S.</p> <code>E_to_I_rate</code> <code>positive float</code> <p>rate at which people in E move to I (both IP and IA, infected pre-symptomatic and infected asymptomatic)</p> <code>IP_to_IS_rate</code> <code>positive float</code> <p>rate a which people in IP (infected pre-symptomatic) move to IS (infected symptomatic)</p> <code>IS_to_R_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to R.</p> <code>IA_to_R_rate</code> <code>positive float</code> <p>rate at which people in IA (infected asymptomatic) move to R</p> <code>IS_to_H_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to H.</p> <code>H_to_R_rate</code> <code>positive float</code> <p>rate at which people in H move to R.</p> <code>H_to_D_rate</code> <code>positive float</code> <p>rate at which people in H move to D.</p> <code>E_to_IA_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>proportion exposed who are asymptomatic based on age-risk groups.</p> <code>IS_to_H_adjusted_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion infected who are hospitalized based on age-risk groups.</p> <code>H_to_D_adjusted_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion hospitalized who die based on age-risk groups.</p> <code>IP_relative_inf</code> <code>positive float</code> <p>relative infectiousness of pre-symptomatic to symptomatic people (IP to IS compartment).</p> <code>IA_relative_inf</code> <code>positive float</code> <p>relative infectiousness of asymptomatic to symptomatic people (IA to IS compartment).</p> <code>viral_shed_peak</code> <code>positive float</code> <p>the peak time of an individual's viral shedding.</p> <code>viral_shed_magnitude</code> <code>positive float</code> <p>magnitude of the viral shedding.</p> <code>viral_shed_duration</code> <code>positive float</code> <p>duration of the viral shedding, must be larger than viral_shed_peak</p> <code>viral_shed_feces_mass</code> <code>positive float</code> <p>average mass of feces (gram)</p> <code>relative_suscept_by_age</code> <code>np.ndarray of positive floats in [0,1]</code> <p>relative susceptibility to infection by age group</p> <code>prop_time_away_by_age</code> <code>np.ndarray of positive floats in [0,1]</code> <p>total proportion of time spent away from home by age group</p> <code>contact_mult_travel</code> <code>positive float in [0,1]</code> <p>multiplier to reduce contact rate of traveling individuals</p> <code>contact_mult_symp</code> <code>positive float in [0,1]</code> <p>multiplier to reduce contact rate of symptomatic individuals</p> <code>total_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>|A| x |A| contact matrix (where |A| is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has</p> <code>school_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>|A| x |A| contact matrix (where |A| is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has at school -- this matrix plus the work_contact_matrix must be less than the total_contact_matrix, element-wise</p> <code>work_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>|A| x |A| contact matrix (where |A| is the number of age groups), where element i,j is the average contacts from age group j that an individual in age group i has at work -- this matrix plus the work_contact_matrix must be less than the total_contact_matrix, element-wise</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>@dataclass\nclass FluSubpopParams(clt.SubpopParams):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in FluModel flu model.\n\n    Each field of datatype np.ndarray must be |A| x |R|,\n    where |A| is the number of age groups and |R| is the number of\n    risk groups. Note: this means all arrays should be 2D.\n    See FluSubpopState docstring for important formatting note\n    on 2D arrays.\n\n    TODO:\n        when adding multiple strains, need to add subscripts\n        to math of attributes and add strain-specific description\n\n    Attributes:\n        num_age_groups (positive int):\n            number of age groups.\n        num_risk_groups (positive int):\n            number of risk groups.\n        beta_baseline (positive float): transmission rate.\n        total_pop_age_risk (np.ndarray of positive ints):\n            total number in population, summed across all\n            age-risk groups.\n        humidity_impact (positive float):\n            coefficient that determines how much absolute\n            humidity affects beta_baseline.\n        hosp_immune_gain (positive float):\n            factor by which population-level immunity\n            against hospitalization grows after each\n            case that recovers.\n        inf_immune_gain (positive float):\n            factor by which population-level immunity\n            against infection grows after each case\n                that recovers.\n        immune_saturation (np.ndarray of positive floats):\n            constant(s) modeling saturation of antibody\n            production of individuals.\n        hosp_immune_wane (positive float):\n            rate at which infection-induced immunity\n            against hospitalization wanes.\n        inf_immune_wane (positive float):\n            rate at which infection-induced immunity\n            against infection wanes.\n        hosp_risk_reduce (positive float in [0,1]):\n            reduction in hospitalization risk from\n            infection-induced immunity.\n        inf_risk_reduce (positive float in [0,1]):\n            reduction in infection risk\n            from infection-induced immunity.\n        death_risk_reduce (positive float in [0,1]):\n            reduction in death risk from infection-induced immunity.\n        R_to_S_rate (positive float):\n            rate at which people in R move to S.\n        E_to_I_rate (positive float):\n            rate at which people in E move to I (both\n            IP and IA, infected pre-symptomatic and infected\n            asymptomatic)\n        IP_to_IS_rate (positive float):\n            rate a which people in IP (infected pre-symptomatic)\n            move to IS (infected symptomatic)\n        IS_to_R_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to R.\n        IA_to_R_rate (positive float):\n            rate at which people in IA (infected asymptomatic)\n            move to R\n        IS_to_H_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to H.\n        H_to_R_rate (positive float):\n            rate at which people in H move to R.\n        H_to_D_rate (positive float):\n            rate at which people in H move to D.\n        E_to_IA_prop (np.ndarray of positive floats in [0,1]):\n            proportion exposed who are asymptomatic based on\n            age-risk groups.\n        IS_to_H_adjusted_prop (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion infected who are hospitalized\n            based on age-risk groups.\n        H_to_D_adjusted_prop (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion hospitalized who die based on\n            age-risk groups.\n        IP_relative_inf (positive float):\n            relative infectiousness of pre-symptomatic to symptomatic\n            people (IP to IS compartment).\n        IA_relative_inf (positive float):\n            relative infectiousness of asymptomatic to symptomatic\n            people (IA to IS compartment).\n        viral_shed_peak (positive float):\n            the peak time of an individual's viral shedding.\n        viral_shed_magnitude (positive float):\n            magnitude of the viral shedding.\n        viral_shed_duration (positive float):\n            duration of the viral shedding,\n            must be larger than viral_shed_peak\n        viral_shed_feces_mass (positive float):\n            average mass of feces (gram)\n        relative_suscept_by_age (np.ndarray of positive floats in [0,1]):\n            relative susceptibility to infection by age group\n        prop_time_away_by_age (np.ndarray of positive floats in [0,1]):\n            total proportion of time spent away from home by age group\n        contact_mult_travel (positive float in [0,1]):\n            multiplier to reduce contact rate of traveling individuals\n        contact_mult_symp (positive float in [0,1]):\n            multiplier to reduce contact rate of symptomatic individuals\n        total_contact_matrix (np.ndarray of positive floats):\n            |A| x |A| contact matrix (where |A| is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has\n        school_contact_matrix (np.ndarray of positive floats):\n            |A| x |A| contact matrix (where |A| is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has at school -- this matrix plus the\n            work_contact_matrix must be less than the\n            total_contact_matrix, element-wise\n        work_contact_matrix (np.ndarray of positive floats):\n            |A| x |A| contact matrix (where |A| is the number\n            of age groups), where element i,j is the average\n            contacts from age group j that an individual in\n            age group i has at work -- this matrix plus the\n            work_contact_matrix must be less than the\n            total_contact_matrix, element-wise\n    \"\"\"\n\n    num_age_groups: Optional[int] = None\n    num_risk_groups: Optional[int] = None\n    beta_baseline: Optional[float] = None\n    total_pop_age_risk: Optional[np.ndarray] = None\n    humidity_impact: Optional[float] = None\n    hosp_immune_gain: Optional[float] = None\n    inf_immune_gain: Optional[float] = None\n    immune_saturation: Optional[np.ndarray] = None\n    hosp_immune_wane: Optional[float] = None\n    inf_immune_wane: Optional[float] = None\n    hosp_risk_reduce: Optional[float] = None\n    inf_risk_reduce: Optional[float] = None\n    death_risk_reduce: Optional[float] = None\n    R_to_S_rate: Optional[float] = None\n    E_to_I_rate: Optional[float] = None\n    IP_to_IS_rate: Optional[float] = None\n    IS_to_R_rate: Optional[float] = None\n    IA_to_R_rate: Optional[float] = None\n    IS_to_H_rate: Optional[float] = None\n    H_to_R_rate: Optional[float] = None\n    H_to_D_rate: Optional[float] = None\n    E_to_IA_prop: Optional[np.ndarray] = None\n    IS_to_H_adjusted_prop: Optional[np.ndarray] = None\n    H_to_D_adjusted_prop: Optional[np.ndarray] = None\n    IP_relative_inf: Optional[float] = None\n    IA_relative_inf: Optional[float] = None\n    viral_shed_peak: Optional[float] = None  # viral shedding parameters\n    viral_shed_magnitude: Optional[float] = None  # viral shedding parameters\n    viral_shed_duration: Optional[float] = None  # viral shedding parameters\n    viral_shed_feces_mass: Optional[float] = None  # viral shedding parameters\n    relative_suscept_by_age: Optional[np.ndarray] = None\n    prop_time_away_by_age: Optional[np.ndarray] = None\n    contact_mult_travel: Optional[float] = None\n    contact_mult_symp: Optional[float] = None\n    total_contact_matrix: Optional[np.ndarray] = None\n    school_contact_matrix: Optional[np.ndarray] = None\n    work_contact_matrix: Optional[np.ndarray] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopState","title":"<code>FluSubpopState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SubpopState</code></p> <p>Data container for pre-specified and fixed set of Compartment initial values and EpiMetric initial values in FluModel flu model.</p> <p>Each field below should be |A| x |R| np.ndarray, where |A| is the number of age groups and |R| is the number of risk groups. Note: this means all arrays should be 2D. Even if there is 1 age group and 1 risk group (no group stratification), each array should be 1x1, which is two-dimensional. For example, np.array([[100]]) is correct -- np.array([100]) is wrong.</p> <p>Attributes:</p> Name Type Description <code>S</code> <code>np.ndarray of positive floats</code> <p>susceptible compartment for age-risk groups -- (holds current_val of Compartment \"S\").</p> <code>E</code> <code>np.ndarray of positive floats</code> <p>exposed compartment for age-risk groups -- (holds current_val of Compartment \"E\").</p> <code>IP</code> <code>np.ndarray of positive floats</code> <p>infected pre-symptomatic compartment for age-risk groups (holds current_val of Compartment \"IP\").</p> <code>IS</code> <code>np.ndarray of positive floats</code> <p>infected symptomatic compartment for age-risk groups (holds current_val of Compartment \"IS\").</p> <code>IA</code> <code>np.ndarray of positive floats</code> <p>infected asymptomatic compartment for age-risk groups (holds current_val of Compartment \"IA\").</p> <code>H</code> <code>np.ndarray of positive floats</code> <p>hospital compartment for age-risk groups (holds current_val of Compartment \"H\").</p> <code>R</code> <code>np.ndarray of positive floats</code> <p>recovered compartment for age-risk groups (holds current_val of Compartment \"R\").</p> <code>D</code> <code>np.ndarray of positive floats</code> <p>dead compartment for age-risk groups (holds current_val of Compartment \"D\").</p> <code>pop_immunity_hosp</code> <code>np.ndarray of positive floats</code> <p>infection-induced population-level immunity against hospitalization, for age-risk groups (holds current_val of EpiMetric \"pop_immunity_hosp\").</p> <code>pop_immunity_inf</code> <code>np.ndarray of positive floats</code> <p>infection-induced population-level immunity against infection, for age-risk groups (holds current_val of EpiMetric \"pop_immunity_inf\").</p> <code>absolute_humidity</code> <code>positive float</code> <p>grams of water vapor per cubic meter g/m^3, used as seasonality parameter that influences transmission rate beta_baseline.</p> <code>flu_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>|A| x |A| array, where |A| is the number of age groups -- element (a, a') corresponds to the number  of contacts that a person in age group a has with people in age-risk group a'.</p> <code>beta_reduct</code> <code>float in [0, 1]</code> <p>starting value of DynamicVal \"beta_reduct\" on starting day of simulation -- this DynamicVal emulates a simple staged-alert policy</p> <code>wastewater</code> <code>np.ndarray of positive floats</code> <p>wastewater viral load</p> <code>force_of_infection</code> <code>np.ndarray of positive floats</code> <p>total force of infection from movement within home location, travel to other locations, and visitors from other locations</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>@dataclass\nclass FluSubpopState(clt.SubpopState):\n    \"\"\"\n    Data container for pre-specified and fixed set of\n    Compartment initial values and EpiMetric initial values\n    in FluModel flu model.\n\n    Each field below should be |A| x |R| np.ndarray, where\n    |A| is the number of age groups and |R| is the number of risk groups.\n    Note: this means all arrays should be 2D. Even if there is\n    1 age group and 1 risk group (no group stratification),\n    each array should be 1x1, which is two-dimensional.\n    For example, np.array([[100]]) is correct --\n    np.array([100]) is wrong.\n\n    Attributes:\n        S (np.ndarray of positive floats):\n            susceptible compartment for age-risk groups --\n            (holds current_val of Compartment \"S\").\n        E (np.ndarray of positive floats):\n            exposed compartment for age-risk groups --\n            (holds current_val of Compartment \"E\").\n        IP (np.ndarray of positive floats):\n            infected pre-symptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IP\").\n        IS (np.ndarray of positive floats):\n            infected symptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IS\").\n        IA (np.ndarray of positive floats):\n            infected asymptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IA\").\n        H (np.ndarray of positive floats):\n            hospital compartment for age-risk groups\n            (holds current_val of Compartment \"H\").\n        R (np.ndarray of positive floats):\n            recovered compartment for age-risk groups\n            (holds current_val of Compartment \"R\").\n        D (np.ndarray of positive floats):\n            dead compartment for age-risk groups\n            (holds current_val of Compartment \"D\").\n        pop_immunity_hosp (np.ndarray of positive floats):\n            infection-induced population-level immunity against\n            hospitalization, for age-risk groups (holds current_val\n            of EpiMetric \"pop_immunity_hosp\").\n        pop_immunity_inf (np.ndarray of positive floats):\n            infection-induced population-level immunity against\n            infection, for age-risk groups (holds current_val\n            of EpiMetric \"pop_immunity_inf\").\n        absolute_humidity (positive float):\n            grams of water vapor per cubic meter g/m^3,\n            used as seasonality parameter that influences\n            transmission rate beta_baseline.\n        flu_contact_matrix (np.ndarray of positive floats):\n            |A| x |A| array, where |A| is the number of age\n            groups -- element (a, a') corresponds to the number \n            of contacts that a person in age group a\n            has with people in age-risk group a'.\n        beta_reduct (float in [0,1]):\n            starting value of DynamicVal \"beta_reduct\" on\n            starting day of simulation -- this DynamicVal\n            emulates a simple staged-alert policy\n        wastewater (np.ndarray of positive floats):\n            wastewater viral load\n        force_of_infection (np.ndarray of positive floats):\n            total force of infection from movement within\n            home location, travel to other locations,\n            and visitors from other locations\n    \"\"\"\n\n    S: Optional[np.ndarray] = None\n    E: Optional[np.ndarray] = None\n    IP: Optional[np.ndarray] = None\n    IS: Optional[np.ndarray] = None\n    IA: Optional[np.ndarray] = None\n    H: Optional[np.ndarray] = None\n    R: Optional[np.ndarray] = None\n    D: Optional[np.ndarray] = None\n    pop_immunity_hosp: Optional[np.ndarray] = None\n    pop_immunity_inf: Optional[np.ndarray] = None\n    absolute_humidity: Optional[float] = None\n    flu_contact_matrix: Optional[np.ndarray] = None\n    beta_reduct: Optional[float] = 0.0\n    wastewater: Optional[np.ndarray] = None  # wastewater viral load\n    force_of_infection: Optional[np.ndarray] = None\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.ForceOfInfection","title":"<code>ForceOfInfection</code>","text":"<p>               Bases: <code>InteractionTerm</code></p> <p>InteractionTerm-derived class for modeling S_to_E transition rate     for a given subpopulation, which depends on the     subpopulation's contact matrix, population-level immunity,     travel dynamics across subpopulations, and also     the states of other subpopulations.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class ForceOfInfection(clt.InteractionTerm):\n    \"\"\"\n    InteractionTerm-derived class for modeling S_to_E transition rate\n        for a given subpopulation, which depends on the\n        subpopulation's contact matrix, population-level immunity,\n        travel dynamics across subpopulations, and also\n        the states of other subpopulations.\n    \"\"\"\n\n    def __init__(self,\n                 subpop_name: str):\n        super().__init__()\n        self.subpop_name = subpop_name\n\n    def update_current_val(self,\n                           inter_subpop_repo: FluInterSubpopRepo,\n                           subpop_params: FluSubpopParams) -&gt; None:\n        subpop_name = self.subpop_name\n        subpop_names_mapping = inter_subpop_repo.subpop_names_mapping\n\n        self.current_val = \\\n            inter_subpop_repo.force_of_infection_array[subpop_names_mapping[subpop_name]]\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.HospToDead","title":"<code>HospToDead</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"H\" to \"D\" compartment. The functional form is the same across subpopulations.</p> <p>Each HospToDead instance forms a TransitionVariableGroup with a corresponding HospToRecovered instance (these two transition variables are jointly distributed).</p> <p>The rate of HospToDead decreases as population-level immunity against hospitalization increases.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class HospToDead(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"H\" to \"D\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each HospToDead instance forms a TransitionVariableGroup with\n    a corresponding HospToRecovered instance (these two\n    transition variables are jointly distributed).\n\n    The rate of HospToDead decreases as population-level immunity\n    against hospitalization increases.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n\n        death_risk_reduce = params.death_risk_reduce\n        proportional_risk_reduction = death_risk_reduce / (1 - death_risk_reduce)\n\n        return np.asarray(params.H_to_D_adjusted_prop * params.H_to_D_rate /\n                          (1 + proportional_risk_reduction * state.pop_immunity_hosp))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.HospToRecovered","title":"<code>HospToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"H\" to \"R\" compartment. The functional form is the same across subpopulations.</p> <p>Each HospToRecovered instance forms a TransitionVariableGroup with a corresponding HospToDead instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class HospToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"H\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each HospToRecovered instance forms a TransitionVariableGroup with\n    a corresponding HospToDead instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       (1 - params.H_to_D_adjusted_prop) * params.H_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.PopulationImmunityHosp","title":"<code>PopulationImmunityHosp</code>","text":"<p>               Bases: <code>EpiMetric</code></p> <p>EpiMetric-derived class for population-level immunity from hospitalization.</p> <p>Population-level immunity increases as people move from \"R\" to \"S\" -- this is a design choice intended to avoid \"double-counting.\" People in \"R\" cannot be infected at all. People who move from \"R\" to \"S\"  are susceptible again, but these recently-recovered people  should have partial immunity. To handle this phenomenon, the population-level immunity epi metric increases as people move from \"R\" to \"S.\" </p> <p>Parameters:</p> Name Type Description Default <code>R_to_S</code> <code>RecoveredToSusceptible</code> <p>RecoveredToSusceptible TransitionVariable in the SubpopModel -- it is an attribute because the population-level immunity increases as people move from \"R\" to \"S\".</p> required <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class PopulationImmunityHosp(clt.EpiMetric):\n    \"\"\"\n    EpiMetric-derived class for population-level immunity\n    from hospitalization.\n\n    Population-level immunity increases as people move\n    from \"R\" to \"S\" -- this is a design choice intended\n    to avoid \"double-counting.\" People in \"R\" cannot be\n    infected at all. People who move from \"R\" to \"S\" \n    are susceptible again, but these recently-recovered people \n    should have partial immunity. To handle this phenomenon,\n    the population-level immunity epi metric increases as\n    people move from \"R\" to \"S.\" \n\n    Params:\n        R_to_S (RecoveredToSusceptible):\n            RecoveredToSusceptible TransitionVariable\n            in the SubpopModel -- it is an attribute\n            because the population-level immunity\n            increases as people move from \"R\" to \"S\".\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self, init_val, R_to_S):\n        super().__init__(init_val)\n        self.R_to_S = R_to_S\n\n    def get_change_in_current_val(self,\n                                  state: FluSubpopState,\n                                  params: FluSubpopParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        pop_immunity_hosp = state.pop_immunity_hosp\n\n        immunity_gain_numerator = params.hosp_immune_gain * self.R_to_S.current_val\n        immunity_gain_denominator = params.total_pop_age_risk * \\\n                                    (1 + params.immune_saturation * pop_immunity_hosp)\n\n        immunity_gain = immunity_gain_numerator / immunity_gain_denominator\n        immunity_loss = params.hosp_immune_wane * state.pop_immunity_hosp\n\n        final_change = (immunity_gain - immunity_loss) / num_timesteps\n\n        return np.asarray(final_change, dtype=np.float64)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.PopulationImmunityInf","title":"<code>PopulationImmunityInf</code>","text":"<p>               Bases: <code>EpiMetric</code></p> <p>EpiMetric-derived class for population-level immunity from infection.</p> <p>Analogous to PopulationImmunityHosp -- see that class's docstring for more information. Update formula is the  same except for inf_immune_gain and inf_immune_wane. </p> <p>Parameters:</p> Name Type Description Default <code>R_to_S</code> <code>RecoveredToSusceptible</code> <p>RecoveredToSusceptible TransitionVariable in the SubpopModel -- it is an attribute because the population-level immunity increases as people move from \"R\" to \"S\".</p> required <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class PopulationImmunityInf(clt.EpiMetric):\n    \"\"\"\n    EpiMetric-derived class for population-level immunity\n    from infection.\n\n    Analogous to PopulationImmunityHosp -- see that class's\n    docstring for more information. Update formula is the \n    same except for inf_immune_gain and\n    inf_immune_wane. \n\n    Params:\n        R_to_S (RecoveredToSusceptible):\n            RecoveredToSusceptible TransitionVariable\n            in the SubpopModel -- it is an attribute\n            because the population-level immunity\n            increases as people move from \"R\" to \"S\".\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self, init_val, R_to_S):\n        super().__init__(init_val)\n        self.R_to_S = R_to_S\n\n    def get_change_in_current_val(self,\n                                  state: FluSubpopState,\n                                  params: FluSubpopParams,\n                                  num_timesteps: int):\n        pop_immunity_inf = np.float64(state.pop_immunity_inf)\n\n        immunity_gain_numerator = params.inf_immune_gain * self.R_to_S.current_val\n        immunity_gain_denominator = params.total_pop_age_risk * \\\n                                    (1 + params.immune_saturation * pop_immunity_inf)\n\n        immunity_gain = immunity_gain_numerator / immunity_gain_denominator\n        immunity_loss = params.inf_immune_wane * state.pop_immunity_inf\n\n        final_change = (immunity_gain - immunity_loss) / num_timesteps\n\n        return np.asarray(final_change, dtype=np.float64)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.PresympToSymp","title":"<code>PresympToSymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IP\" to \"IS\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class PresympToSymp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IP\" to \"IS\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.IP_to_IS_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.RecoveredToSusceptible","title":"<code>RecoveredToSusceptible</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"R\" to \"S\" compartment. The functional form is the same across subpopulations.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class RecoveredToSusceptible(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"R\" to \"S\" compartment. The functional form is the same across\n    subpopulations.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       params.R_to_S_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.SusceptibleToExposed","title":"<code>SusceptibleToExposed</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"S\" to \"E\" compartment. The functional form is the same across subpopulations.</p> <p>The rate depends on the corresponding subpopulation's contact matrix, transmission rate beta, number infected (symptomatic, asymptomatic, and pre-symptomatic), and population-level immunity against infection, among other parameters.</p> <p>This is the most complicated transition variable in the flu model. If using metapopulation model (travel model), then the rate depends on an ForceOfInfection instance that is a function of other subpopulations' states and parameters, and travel between subpopulations.</p> <p>If there is no metapopulation model, then there is no ForceOfInfection InteractionTerm instance, and the rate is much simpler.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class SusceptibleToExposed(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"S\" to \"E\" compartment. The functional form is the same across\n    subpopulations.\n\n    The rate depends on the corresponding subpopulation's\n    contact matrix, transmission rate beta, number\n    infected (symptomatic, asymptomatic, and pre-symptomatic),\n    and population-level immunity against infection,\n    among other parameters.\n\n    This is the most complicated transition variable in the\n    flu model. If using metapopulation model (travel model), then\n    the rate depends on an ForceOfInfection instance that is\n    a function of other subpopulations' states and parameters,\n    and travel between subpopulations.\n\n    If there is no metapopulation model, then there is no\n    ForceOfInfection InteractionTerm instance, and the rate\n    is much simpler.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n\n        # If there is no ForceOfInfection InteractionTerm instance,\n        #   then there is no travel model -- so, simulate\n        #   this subpopulation entirely independently and\n        #   use the simplified transition rate that does not\n        #   depend on travel dynamics\n\n        if state.force_of_infection is not None:\n            return state.force_of_infection\n        else:\n            wtd_presymp_asymp = compute_wtd_presymp_asymp(state, params)\n\n            return compute_common_coeff_force_of_infection(state, params) * \\\n                   np.matmul(state.flu_contact_matrix,\n                             np.divide(state.IS + wtd_presymp_asymp,\n                                       compute_pop_by_age(params)))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.SympToHosp","title":"<code>SympToHosp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IS\" to \"H\" compartment. The functional form is the same across subpopulations.</p> <p>Each SympToHosp instance forms a TransitionVariableGroup with a corresponding SympToRecovered instance (these two transition variables are jointly distributed).</p> <p>The rate of SympToHosp decreases as population-level immunity against hospitalization increases.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class SympToHosp(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IS\" to \"H\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each SympToHosp instance forms a TransitionVariableGroup with\n    a corresponding SympToRecovered instance (these two\n    transition variables are jointly distributed).\n\n    The rate of SympToHosp decreases as population-level immunity\n    against hospitalization increases.\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n\n        hosp_risk_reduce = params.hosp_risk_reduce\n        proportional_risk_reduction = hosp_risk_reduce / (1 - hosp_risk_reduce)\n\n        return np.asarray(params.IS_to_H_rate * params.IS_to_H_adjusted_prop /\n                          (1 + proportional_risk_reduction * state.pop_immunity_hosp))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.SympToRecovered","title":"<code>SympToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> <p>TransitionVariable-derived class for movement from the \"IS\" to \"R\" compartment. The functional form is the same across subpopulations.</p> <p>Each SympToRecovered instance forms a TransitionVariableGroup with a corresponding SympToHosp instance (these two transition variables are jointly distributed).</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class SympToRecovered(clt.TransitionVariable):\n    \"\"\"\n    TransitionVariable-derived class for movement from the\n    \"IS\" to \"R\" compartment. The functional form is the same across\n    subpopulations.\n\n    Each SympToRecovered instance forms a TransitionVariableGroup with\n    a corresponding SympToHosp instance (these two\n    transition variables are jointly distributed).\n    \"\"\"\n\n    def get_current_rate(self,\n                         state: FluSubpopState,\n                         params: FluSubpopParams) -&gt; np.ndarray:\n        return np.full((params.num_age_groups, params.num_risk_groups),\n                       (1 - params.IS_to_H_adjusted_prop) * params.IS_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.Wastewater","title":"<code>Wastewater</code>","text":"<p>               Bases: <code>EpiMetric</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class Wastewater(clt.EpiMetric):\n\n    def __init__(self, init_val, S_to_E):\n        super().__init__(init_val)\n        self.S_to_E = S_to_E\n        # preprocess\n        self.flag_preprocessed = False\n        self.viral_shedding = []\n        self.viral_shed_duration = None\n        self.viral_shed_magnitude = None\n        self.viral_shed_peak = None\n        self.viral_shed_feces_mass = None\n        self.S_to_E_len = 5000  # preset to match the simulation time horizon\n        self.S_to_E_history = np.zeros(self.S_to_E_len)\n        self.cur_time_stamp = -1\n        self.num_timesteps = None\n        self.val_list_len = None\n        self.current_val_list = None\n        self.cur_idx_timestep = -1\n\n    def get_change_in_current_val(self,\n                                  state: FluSubpopState,\n                                  params: FluSubpopParams,\n                                  num_timesteps: int):\n        if not self.flag_preprocessed:  # preprocess the viral shedding function if not done yet\n            self.val_list_len = num_timesteps\n            self.current_val_list = np.zeros(self.val_list_len)\n            self.preprocess(params, num_timesteps)\n        return 0\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Adds change_in_current_val attribute to current_val attribute\n            in-place.\n        \"\"\"\n        # record number of exposed people per day\n        self.cur_time_stamp += 1\n        self.S_to_E_history[self.cur_time_stamp] = np.sum(self.S_to_E.current_val)\n        current_val = 0\n\n        # attribute access shortcut\n        cur_time_stamp = self.cur_time_stamp\n\n        # discrete convolution\n        len_duration = self.viral_shed_duration * self.num_timesteps\n\n        if self.cur_time_stamp &gt;= len_duration - 1:\n            current_val = self.S_to_E_history[\n                          (cur_time_stamp - len_duration + 1):(cur_time_stamp + 1)] @ self.viral_shedding\n        else:\n            current_val = self.S_to_E_history[\n                          :(cur_time_stamp + 1)] @ self.viral_shedding[-(cur_time_stamp + 1):]\n\n        self.current_val = current_val\n        self.cur_idx_timestep += 1\n        self.current_val_list[self.cur_idx_timestep] = current_val\n\n    def preprocess(self,\n                   params: FluSubpopParams,\n                   num_timesteps: int):\n        # store the parameters locally\n        self.viral_shed_duration = copy.deepcopy(params.viral_shed_duration)\n        self.viral_shed_magnitude = copy.deepcopy(params.viral_shed_magnitude)\n        self.viral_shed_peak = copy.deepcopy(params.viral_shed_peak)\n        self.viral_shed_feces_mass = copy.deepcopy(params.viral_shed_feces_mass)\n        self.num_timesteps = copy.deepcopy(num_timesteps)\n        num_timesteps = np.float64(num_timesteps)\n        self.viral_shedding = []\n        # trapezoidal integral\n        for time_idx in range(int(params.viral_shed_duration * self.num_timesteps)):\n            cur_time_point = time_idx / num_timesteps\n            next_time_point = (time_idx + 1) / num_timesteps\n            next_time_log_viral_shedding = params.viral_shed_magnitude * next_time_point / \\\n                                           (params.viral_shed_peak ** 2 + next_time_point ** 2)\n            if time_idx == 0:\n                interval_viral_shedding = params.viral_shed_feces_mass * 0.5 * (\n                        10 ** next_time_log_viral_shedding) / num_timesteps\n            else:\n                cur_time_log_viral_shedding = params.viral_shed_magnitude * cur_time_point / \\\n                                              (params.viral_shed_peak ** 2 + cur_time_point ** 2)\n                interval_viral_shedding = params.viral_shed_feces_mass * 0.5 \\\n                                          * (\n                                                  10 ** cur_time_log_viral_shedding + 10 ** next_time_log_viral_shedding) / num_timesteps\n            self.viral_shedding.append(interval_viral_shedding)\n        self.viral_shedding.reverse()\n        self.viral_shedding = np.array(self.viral_shedding)\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves daily viral load (accumulated during one day) to history by appending current_val attribute\n            to history_vals_list in place\n\n        \"\"\"\n        daily_viral_load = np.sum(self.current_val_list)\n        self.history_vals_list.append(daily_viral_load)\n        # reset the index of current_val_list\n        self.cur_idx_timestep = -1\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets history_vals_list attribute to empty list.\n        \"\"\"\n        self.flag_preprocessed = False\n        self.viral_shedding = []\n        self.viral_shed_duration = None\n        self.viral_shed_magnitude = None\n        self.viral_shed_peak = None\n        self.viral_shed_feces_mass = None\n        self.S_to_E_len = 5000  # preset to match the simulation time horizon\n        self.S_to_E_history = np.zeros(self.S_to_E_len)\n        self.cur_time_stamp = -1\n        self.num_timesteps = None\n        self.val_list_len = None\n        self.current_val_list = None\n        self.cur_idx_timestep = -1\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.Wastewater.reset","title":"<code>reset() -&gt; None</code>","text":"<p>Resets history_vals_list attribute to empty list.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets history_vals_list attribute to empty list.\n    \"\"\"\n    self.flag_preprocessed = False\n    self.viral_shedding = []\n    self.viral_shed_duration = None\n    self.viral_shed_magnitude = None\n    self.viral_shed_peak = None\n    self.viral_shed_feces_mass = None\n    self.S_to_E_len = 5000  # preset to match the simulation time horizon\n    self.S_to_E_history = np.zeros(self.S_to_E_len)\n    self.cur_time_stamp = -1\n    self.num_timesteps = None\n    self.val_list_len = None\n    self.current_val_list = None\n    self.cur_idx_timestep = -1\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.Wastewater.save_history","title":"<code>save_history() -&gt; None</code>","text":"<p>Saves daily viral load (accumulated during one day) to history by appending current_val attribute     to history_vals_list in place</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves daily viral load (accumulated during one day) to history by appending current_val attribute\n        to history_vals_list in place\n\n    \"\"\"\n    daily_viral_load = np.sum(self.current_val_list)\n    self.history_vals_list.append(daily_viral_load)\n    # reset the index of current_val_list\n    self.cur_idx_timestep = -1\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.Wastewater.update_current_val","title":"<code>update_current_val() -&gt; None</code>","text":"<p>Adds change_in_current_val attribute to current_val attribute     in-place.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Adds change_in_current_val attribute to current_val attribute\n        in-place.\n    \"\"\"\n    # record number of exposed people per day\n    self.cur_time_stamp += 1\n    self.S_to_E_history[self.cur_time_stamp] = np.sum(self.S_to_E.current_val)\n    current_val = 0\n\n    # attribute access shortcut\n    cur_time_stamp = self.cur_time_stamp\n\n    # discrete convolution\n    len_duration = self.viral_shed_duration * self.num_timesteps\n\n    if self.cur_time_stamp &gt;= len_duration - 1:\n        current_val = self.S_to_E_history[\n                      (cur_time_stamp - len_duration + 1):(cur_time_stamp + 1)] @ self.viral_shedding\n    else:\n        current_val = self.S_to_E_history[\n                      :(cur_time_stamp + 1)] @ self.viral_shedding[-(cur_time_stamp + 1):]\n\n    self.current_val = current_val\n    self.cur_idx_timestep += 1\n    self.current_val_list[self.cur_idx_timestep] = current_val\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.absolute_humidity_func","title":"<code>absolute_humidity_func(current_date: datetime.date) -&gt; float</code>","text":"<p>Note: this is a dummy function loosely based off of the absolute humidity data from Kaiming and Shraddha's new burden averted draft.</p> <p>TODO: replace this function with real humidity function</p> <p>The following calculation is used to achieve the correct     upside-down parabola with the right min and max     values and location     max_value = 12.5     0.00027 = (max_value - k) / ((0 - h) ** 2)</p> <p>Parameters:</p> Name Type Description Default <code>current_date</code> <code>date</code> <p>datetime.date object corresponding to real-world date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>nonnegative float between 3.4 and 12.5 corresponding to absolute humidity that day of the year</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def absolute_humidity_func(current_date: datetime.date) -&gt; float:\n    \"\"\"\n    Note: this is a dummy function loosely based off of\n    the absolute humidity data from Kaiming and Shraddha's\n    new burden averted draft.\n\n    TODO: replace this function with real humidity function\n\n    The following calculation is used to achieve the correct\n        upside-down parabola with the right min and max\n        values and location\n        max_value = 12.5\n        0.00027 = (max_value - k) / ((0 - h) ** 2)\n\n    Args:\n        current_date (datetime.date):\n            datetime.date object corresponding to\n            real-world date\n\n    Returns:\n        float:\n            nonnegative float between 3.4 and 12.5\n            corresponding to absolute humidity\n            that day of the year\n    \"\"\"\n\n    # Convert datetime.date to integer between 1 and 365\n    #   corresponding to day of the year\n    day_of_year = current_date.timetuple().tm_yday\n\n    # Minimum humidity occurs in January and December\n    # Maximum humidity occurs in July\n    return 12.5 - 0.00027 * (day_of_year % 365 - 180) ** 2\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.compute_beta_humidity_adjusted","title":"<code>compute_beta_humidity_adjusted(subpop_state: FluSubpopState, subpop_params: FluSubpopParams) -&gt; float</code>","text":"<p>Computes and returns humidity-adjusted beta.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def compute_beta_humidity_adjusted(subpop_state: FluSubpopState,\n                                   subpop_params: FluSubpopParams) -&gt; float:\n    \"\"\"\n    Computes and returns humidity-adjusted beta.\n    \"\"\"\n\n    # We subtract absolute_humidity because higher humidity means less transmission\n    return (1 - subpop_state.absolute_humidity * subpop_params.humidity_impact) \\\n           * subpop_params.beta_baseline\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.compute_common_coeff_force_of_infection","title":"<code>compute_common_coeff_force_of_infection(subpop_state: FluSubpopState, subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Computes a coefficient that shows up repeatedly in travel model calculations.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: |A| x |R| array -- where |A| is the number of age groups and |R| is the number of risk groups -- representing a kind of baseline transmission rate, adjusted for population-level immunity -- used as the coefficient of many computations</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def compute_common_coeff_force_of_infection(subpop_state: FluSubpopState,\n                                            subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Computes a coefficient that shows up repeatedly in\n    travel model calculations.\n\n    Returns:\n        np.ndarray:\n            |A| x |R| array -- where |A| is the number of age groups\n            and |R| is the number of risk groups -- representing\n            a kind of baseline transmission rate, adjusted for\n            population-level immunity -- used as the coefficient of\n            many computations\n    \"\"\"\n\n    beta = compute_beta_humidity_adjusted(subpop_state, subpop_params)\n    relative_suscept_by_age = subpop_params.relative_suscept_by_age\n    immunity_force = compute_immunity_force(subpop_state, subpop_params)\n\n    return beta * np.divide(relative_suscept_by_age, immunity_force)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.compute_immunity_force","title":"<code>compute_immunity_force(subpop_state: FluSubpopState, subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Computes a denominator that shows up repeatedly in travel model calculations.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>|A| x |R| array -- where |A| is the number of age groups</p> <code>ndarray</code> <p>and |R| is the number of risk groups -- representing</p> <code>ndarray</code> <p>the force of population-level immunity against infection</p> <code>ndarray</code> <p>-- used in the denominator of many computations</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def compute_immunity_force(subpop_state: FluSubpopState,\n                           subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Computes a denominator that shows up repeatedly in\n    travel model calculations.\n\n    Returns:\n        |A| x |R| array -- where |A| is the number of age groups\n        and |R| is the number of risk groups -- representing\n        the force of population-level immunity against infection\n        -- used in the denominator of many computations\n    \"\"\"\n\n    inf_risk_reduce = subpop_params.inf_risk_reduce\n    proportional_risk_reduction = inf_risk_reduce / (1 - inf_risk_reduce)\n\n    return 1 + (proportional_risk_reduction *\n                subpop_state.pop_immunity_inf)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.compute_pop_by_age","title":"<code>compute_pop_by_age(subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: |A| x 1 array -- where |A| is the number of age groups -- where ith element corresponds to total population (across all compartments, including \"D\", and across all risk groups) in age group i</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def compute_pop_by_age(subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns:\n        np.ndarray:\n            |A| x 1 array -- where |A| is the number of age groups --\n            where ith element corresponds to total population\n            (across all compartments, including \"D\", and across all risk groups)\n            in age group i\n    \"\"\"\n\n    return np.sum(subpop_params.total_pop_age_risk, axis=1, keepdims=True)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.compute_wtd_presymp_asymp","title":"<code>compute_wtd_presymp_asymp(subpop_state: FluSubpopState, subpop_params: FluSubpopParams) -&gt; np.ndarray</code>","text":"<p>Returns weighted sum of IP and IA compartment for     subpopulation with given state and parameters.     IP and IA are weighted by their relative infectiousness     respectively, and then summed over risk groups.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: |A| x 1 array -- where |A| is the number of age groups -- the ith element corresponds to the weighted sum of presymptomatic and asymptomatic individuals, also summed across all risk groups, for age group i.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def compute_wtd_presymp_asymp(subpop_state: FluSubpopState,\n                              subpop_params: FluSubpopParams) -&gt; np.ndarray:\n    \"\"\"\n    Returns weighted sum of IP and IA compartment for\n        subpopulation with given state and parameters.\n        IP and IA are weighted by their relative infectiousness\n        respectively, and then summed over risk groups.\n\n    Returns:\n        np.ndarray:\n            |A| x 1 array -- where |A| is the number of age\n            groups -- the ith element corresponds to the\n            weighted sum of presymptomatic and asymptomatic\n            individuals, also summed across all risk groups,\n            for age group i.\n    \"\"\"\n\n    # sum over risk groups\n    wtd_IP = \\\n        subpop_params.IP_relative_inf * np.sum(subpop_state.IP, axis=1, keepdims=True)\n    wtd_IA = \\\n        subpop_params.IA_relative_inf * np.sum(subpop_state.IA, axis=1, keepdims=True)\n\n    return wtd_IP + wtd_IA\n</code></pre>"},{"location":"flu_components_walkthrough/","title":"Flu Model Creation Walkthrough","text":"<p>This page is getting updated, please check back soon! </p>"},{"location":"flu_input_requirements/","title":"Flu Model Input Requirements","text":"<p> \\(\\def\\rateRtoS{\\sigma^{R\\rightarrow S}}\\) \\(\\def\\rateEtoI{\\sigma^{E \\rightarrow [IP, IA]}}\\) \\(\\def\\rateIPtoIS{\\sigma^{IP \\rightarrow IS}}\\) \\(\\def\\rateIStoH{\\sigma^{IS\\rightarrow H}}\\) \\(\\def\\rateHtoD{\\sigma^{H\\rightarrow D}}\\) \\(\\def\\rateIAtoR{\\gamma^{IA\\rightarrow R}}\\) \\(\\def\\rateHtoR{\\gamma^{H\\rightarrow R}}\\) \\(\\def\\rateIStoR{\\gamma^{IS\\rightarrow R}}\\) \\(\\def\\totalforceofinfection{\\lambda^{(\\ell), \\text{total}}_{a,r}(t)}\\) \\(\\def\\propIA{\\pi^{IA}}\\) \\(\\def\\propH{\\pi^H}\\) \\(\\def\\propD{\\pi^D}\\) \\(\\def\\adjustedpropH{\\tilde{\\pi}^H}\\) \\(\\def\\adjustedpropD{\\tilde{\\pi}^D}\\) </p> <p>Written by LP, updated 02/26/2025 (work in progress) </p> <p>Important note: we are updating this page with wastewater inputs -- check back soon.</p> <p>Here, we document input requirements for creating a <code>FluSubpopModel</code> instance and a <code>FluMetapopModel</code> instance, as well as provide mappings between the input variable names in the code and the mathematical variables in the mathematical formulation. For users to customize the values (not the structure) of the flu model given in <code>flu_components.py</code>, they must abide by certain input specifications.</p> <p>Recall that the class <code>FluSubpopModel</code> simulates the flu model given by this mathematical formulation for a specific subpopulation. Multiple <code>FluSubpopModel</code> instances can be combined as input into a <code>FluMetapopModel</code> instance to simulate multiple subpopulations and travel between these subpopulations. </p> <p>Each <code>FluSubpopModel</code> instance requires user-specified inputs for demographics and initial values of compartments and epi metrics, values of fixed parameters, experiment configuration details, and a school-work calendar. Each <code>FluMetapopModel</code> instance requires data for pairwise travel proportions (the proportion of people in subpopulation \\(\\ell\\) who travel to a different subpopulation \\(k\\).) Depending on the type of input, these inputs may be read from <code>JSON</code> or <code>CSV</code> files, or defined directly in code as a <code>dict</code> or <code>pd.DataFrame</code>.</p> <p>As a concrete example, we refer the user to <code>flu_demo.py</code> and its input folder <code>flu_demo_input_files</code>. The demo model has two subpopulations with the exact same inputs. The folder contains 4 <code>JSON</code> input files used to run <code>flu_demo.py</code>: <code>compartments_epi_metrics_init_vals.json</code>, <code>fixed_params.json</code>, <code>config.json</code>, and <code>travel_proportions.json</code>. These input files respectively are used to initialize a <code>FluSubpopState</code> instance, <code>FluSubpopParams</code> instance, <code>Config</code> instance, and <code>FluInterSubpopRepo</code> instance. The folder also contains a file <code>school_work_calendar.csv</code> that provides necessary calendar data (indicating if a date is a school or work day). In general, for an arbitrary number of subpopulations with different inputs, the user should have 5 input files per <code>FluSubpopModel</code> instance (4 are the aforementioned <code>JSON</code> files and 1 is the aforementioned <code>CSV</code> file).</p> <p>The file <code>travel_proportions.JSON</code> provides pairwise travel proportions between subpopulations. This is used for travel computations in the <code>FluMetapopModel</code> instance that contains the subpopulations. This file is not required if only one <code>FluSubpopModel</code> is used (so there is no metapopulation model or travel model).</p> <p>In the following sections we discuss the input requirements for: for demographics and initial values of compartments and epi metrics (for each <code>FluSubpopModel</code>), values of fixed parameters (for each <code>FluSubpopModel</code>), experiment configuration details (for each <code>FluSubpopModel</code>), school-work calendars (for each <code>FluSubpopModel</code>), and travel proportions (for each <code>FluMetapopModel</code>).</p>"},{"location":"flu_input_requirements/#demographics-and-initial-values-of-state-variables","title":"Demographics and initial values of state variables","text":"<p>The table below has a variable name to math variable mapping for the <code>JSON</code> file used to initialize <code>FluSubpopState</code> instances. This file specifies initial conditions for <code>StateVariable</code> objects (which includes <code>Compartment</code>, <code>EpiMetric</code>, <code>Schedule</code>, and <code>DynamicVal</code> objects). </p> <p>Important notes:</p> <ul> <li> <p><code>Schedule</code> instances get their values deterministically updated according to a schedule. At every simulation day <code>t</code>, their values are well-defined (taken from a schedule calendar), regardless of the initial value. Therefore, the initial value does not matter, so they are excluded from inputs. However, these objects are indeed updated and used in the simulation. Similar logic applies to <code>DynamicVal</code> instances.</p> </li> <li> <p>Currently, <code>beta_reduct</code> is not a part of the mathematical formulation. In the code, <code>beta_reduct</code> is a <code>DynamicVal</code> that decreases <code>beta_baseline</code> when a certain simulation state is triggered. This emulates a very simple staged-alert policy. In <code>flu_components.py</code>, <code>beta_reduct</code> is automatically disabled, so that the simple staged-alert policy is not in effect during default flu model runs. When enabled, <code>beta_reduct</code> has a value of <code>0.5</code> (corresponding to a \\(50\\%\\) decrease in transmission rates) when more than \\(5\\%\\) of the population is infected, and it has a value of <code>0.0</code> otherwise. Again, these values are \"toy\" values for the sake of demonstration.</p> </li> </ul> <p>Note that there is one <code>FluSubpopState</code> for each <code>SubpopModel</code> instance. The following matrices are for a specific subpopulation. But here we remove the superscript \\((\\ell)\\) for subpopulation \\(\\ell\\) for readability ease. </p> Name Math Variable Dimension <code>S</code> \\(\\boldsymbol{S}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>E</code> \\(\\boldsymbol{E}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IP</code> \\(\\boldsymbol{IP}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IS</code> \\(\\boldsymbol{IS}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IA</code> \\(\\boldsymbol{IA}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>H</code> \\(\\boldsymbol{H}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>R</code> \\(\\boldsymbol{R}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>D</code> \\(\\boldsymbol{D}(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>population_immunity_inf</code> \\(\\boldsymbol{M}^I(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>population_immunity_hosp</code> \\(\\boldsymbol{M}^H(0)\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\)"},{"location":"flu_input_requirements/#simulation-configuration","title":"Simulation configuration","text":"<p>The table below describes the <code>JSON</code> file used to initialize <code>Config</code> instances. These values specify the simulation experiment configuration. </p> Name Explanation Format <code>timesteps_per_day</code> number of discretized timesteps per day -- larger values may increase accuracy of approximation to continuous time but slow down simulation positive <code>int</code> <code>transition_type</code> specifies distribution of stochastic or deterministic population transitions between compartments -- see mathematical definition of transition types for specific formulas <code>str</code>, must have value in <code>TransitionTypes</code> to be valid <code>start_real_date</code> real-world date corresponding to start of simulation <code>str</code>, must have format <code>\"YYYY-MM-DD\"</code> <code>save_daily_history</code> indicates if daily history is saved on <code>Compartment</code> instances -- may want to strategically turn off to save time during performance runs <code>bool</code>"},{"location":"flu_input_requirements/#fixed-parameters","title":"Fixed parameters","text":"<p>The table below has a variable name to math variable mapping for the <code>JSON</code> file used to initialize <code>FluSubpopParams</code> instances. We can think of this file as the \"Greek letter file\" -- it specifies values such as transition rates as well as number of age groups and risk groups. We assume that these values do not change throughout the course of the simulation.  </p> <p>Notes</p> <ul> <li>There is one <code>FluSubpopParams</code> instance for each <code>SubpopModel</code> instance. </li> <li>The following variables are for a specific subpopulation, although many of these variables will be the same across subpopulations in practice. The mathematical formulation for the flu model assumes that only \\(\\boldsymbol{N}^{(\\ell)}\\) and \\(\\beta_0^{(\\ell)}\\) are different across subpopulations, although it is straightforward to generalize the notation and relax this assumption. Here in the table below we remove the superscript \\((\\ell)\\) for subpopulation \\(\\ell\\) for readability ease. </li> <li>Variables that are positive scalars can be generalized to be age or risk dependent.</li> </ul> Name Math Variable Dimension <code>num_age_groups</code> \\(\\lvert \\mathcal A \\rvert\\) positive <code>int</code> <code>num_risk_groups</code> \\(\\lvert \\mathcal R \\rvert\\) positive <code>int</code> <code>beta_baseline</code> \\(\\beta_0\\) positive scalar <code>total_pop_age_risk</code> \\(\\boldsymbol{N}\\) \\(\\lvert \\mathcal A \\rvert\\) <code>humidity_impact</code> \\(\\xi\\) scalar <code>hosp_immune_gain</code> \\(g^H\\) scalar <code>inf_immune_gain</code> \\(g^I\\) scalar <code>immune_saturation</code> \\(\\boldsymbol{O}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>hosp_immune_wane</code> \\(w^H\\) positive scalar <code>inf_immune_wane</code> \\(w^I\\) positive scalar <code>hosp_risk_reduce</code> \\(\\boldsymbol{K}^H\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>inf_risk_reduce</code> \\(\\boldsymbol{K}^I\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>death_risk_reduce</code> \\(\\boldsymbol{K}^D\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>R_to_S_rate</code> \\(\\rateRtoS\\) positive scalar <code>E_to_I_rate</code> \\(\\rateEtoI\\) positive scalar <code>IP_to_IS_rate</code> \\(\\rateIPtoIS\\) positive scalar <code>IS_to_R_rate</code> \\(\\rateIStoR\\) positive scalar <code>IA_to_R_rate</code> \\(\\rateIAtoR\\) positive scalar <code>IS_to_H_rate</code> \\(\\rateIStoH\\) positive scalar <code>H_to_R_rate</code> \\(\\rateHtoR\\) positive scalar <code>H_to_D_rate</code> \\(\\rateHtoD\\) positive scalar <code>E_to_IA_prop</code> \\(\\propIA\\) scalar in \\([0,1]\\) <code>H_to_D_adjusted_prop</code> \\(\\boldsymbol{\\adjustedpropD}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IS_to_H_adjusted_prop</code> \\(\\boldsymbol{\\adjustedpropH}\\) \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) <code>IP_relative_inf</code> \\(r_{IP}\\) positive scalar <code>IA_relative_inf</code> \\(r_{IA}\\) positive scalar <code>relative_suscept_by_age</code> \\(\\psi\\) \\(\\lvert \\mathcal A \\rvert \\times 1\\) <code>prop_time_away_by_age</code> \\(c\\) \\(\\lvert \\mathcal A \\rvert \\times 1\\) <code>contact_mult_travel</code> \\(h_{\\text{travel}}\\) scalar <code>contact_mult_symp</code> \\(h_{\\text{symp}}\\) scalar <code>total_contact_matrix</code> see contact matrix below \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <code>school_contact_matrix</code> see contact matrix below \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\) <code>work_contact_matrix</code> see contact matrix below \\(\\lvert \\mathcal A \\rvert \\times \\lvert A \\rvert\\)"},{"location":"flu_input_requirements/#contact-matrix-and-school-work-calendar-csv","title":"Contact matrix and school-work calendar CSV","text":"<p>Let \\(\\phi^{(\\ell), \\text{total}}\\), \\(\\phi^{(\\ell), \\text{work}}\\), and \\(\\phi^{(\\ell), \\text{school}}\\) represent the <code>total_contact_matrix</code>, <code>school_contact_matrix</code>, and <code>work_contact_matrix</code> respectively for subpopulation \\(\\ell\\).</p> <p>The school-work calendar CSV must have 3 columns with names: <code>\"date\"</code>, <code>\"is_school_day\"</code>, and <code>\"is_work_day\"</code>. The <code>\"date\"</code> column contains strings corresponding to dates, in the format <code>\"YYYY-MM-DD\"</code>. The other two columns are Booleans indicating if the real-world date is a school day or work day. </p> <p>Then the contact matrix for the subpopulation at time \\(t\\) is $$ \\phi^{(\\ell)}(t) := \\phi^{(\\ell), \\text{total}} - d_{\\text{work}}(t) \\phi^{(\\ell), \\text{work}} - d_{\\text{school}}(t) \\phi^{(\\ell), \\text{school}} $$ where \\(d_{\\text{work}}(t)\\) is \\(1\\) if the real-world date corresponding to simulation time \\(t\\) is a work day and \\(0\\) otherwise, specified by the school-work calendar input CSV, and \\(d_{\\text{school}}(t)\\) is defined analogously, but for school days.</p>"},{"location":"flu_input_requirements/#travel-models-travel-proportions-json","title":"Travel model's travel proportions JSON","text":"<p>The travel proportions <code>JSON</code> must have the following fields</p> Name Math Variable Dimension <code>subpop_names_mapping</code> N/A <code>dict</code> <code>travel_proportions_array</code> \\(v^{\\ell \\rightarrow k}\\) \\(\\lvert \\mathcal L \\rvert \\times \\lvert \\mathcal L \\rvert\\) <p>The field <code>subpop_names_mapping</code> must be a dictionary where</p> <ul> <li>Keys are strings that match the names of each associated <code>FluSubpopModel</code> instance.</li> <li>Values are integers in \\(\\{0, 1, \\dots, \\lvert \\mathcal L \\rvert\\}\\).</li> </ul> <p>This dictionary provides a mapping between the <code>FluSubpopModel</code> instance (its name) and the index it occupies in the <code>travel_proportions_array</code>.</p> <p>The field <code>travel_proportions_array</code> must be a list of \\(\\lvert \\mathcal L \\rvert\\) lists, each of length \\(\\lvert \\mathcal L \\rvert\\). Recall that <code>JSON</code> does not support <code>numpy</code> arrays natively, but the base model code is able to convert lists to <code>numpy</code> arrays for use. The \\((\\ell, k)\\)th element of <code>travel_proportions_array</code> corresponds to the proportion of people in subpopulation \\(\\ell\\) who travel to subpopulation \\(k\\). Again, the mapping between indices and subpopulations is given in <code>subpop_names_mapping</code>.</p>"},{"location":"flu_model_code_overview/","title":"Flu Model Code Overview","text":"<p>Written by LP, updated 1/23/2025 (work in progress)</p>"},{"location":"flu_model_code_overview/#overview-assumptions","title":"Overview &amp; Assumptions","text":"<p>The module <code>flu_components.py</code> extends the base classes of <code>base_components.py</code> to implement a compartmental model with a specific structure. This model is given by the mathematical formulation of the flu model with a few simplifying assumptions. The script <code>flu_demo.py</code> runs the flu model with input data given in <code>flu_demo_input_files</code>. Note that this input data gives \"toy\" values. For a realistic model, we would estimate or calibrate these values using real-world historical data. </p> <p>The simplifying assumptions of <code>flu_components.py</code> include:</p> <ul> <li>We model only one immunity inducing event (say, H1N1).<ul> <li>As a result, we model only one strain (and thus disregard prevalence) and we do not model vaccination. </li> <li>Matrices that would otherwise have \\(4\\) indices for subpopulation, age, risk, and immunity-inducing event (e.g. \\(\\boldsymbol{M}_{a, r, H1}^{(\\ell), H(t)}\\) because they are \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert \\times \\lvert \\mathcal I \\rvert\\)) only have \\(3\\) indices in the code (for subpopulation and age-risk group). In other words, for a given subpopulation, these matrices are now only \\(\\lvert \\mathcal A \\rvert \\times \\lvert \\mathcal R \\rvert\\) and we drop the immunity-inducing event dimension entirely.</li> <li>Population-level immunity against infection and population-level immunity against hospitalization is modeled only for H1N1, and not for H3N2 or vaccination. </li> </ul> </li> </ul> <p>A more comprehensive model relaxing these simplifying assumptions is coming soon!</p>"},{"location":"flu_model_code_overview/#documentation","title":"Documentation","text":"<p>Follow the links below for code readme's, tutorials, and other resources.</p> Name Explanation Flu Model Demo Must-read. Explanation of <code>flu_demo.py</code> and basic simulation functionality. Helps user get started with a concrete simulation right away. Flu Input Requirements Must-read. Explanation of <code>flu_demo_input_files</code> and the required specifications and formats for customizing flu model values. Flu Components Walkthrough Advanced. Must-read for users who want to create a custom model structure. Explains <code>flu_components.py</code> subclasses to demonstrate how to create custom subclasses for a customized flu model or another model."},{"location":"flu_model_demo/","title":"Flu Model Demo","text":"<p>Written by LP, updated 02/13/2025 (work in progress) </p> <p>In this tutorial, we work through <code>flu_demo.py,</code> which is a toy implementation of the flu model mathematically formulated here and coded in the <code>flu_model</code> module. Inputs are given by the contents of <code>flu_demo_input_files.</code></p> <p>First, we import necessary packages and modules. Recall that the <code>clt_base</code> module has the building blocks for creating compartmental models. The <code>flu_model</code> module has subclasses of <code>clt_base</code> classes, customized to create a flu model with a specific functional form. To work within the given functional form but edit values such as initial population values and fixed parameters (among other details), we only need to edit input files, which we will do here. </p> <pre><code>from pathlib import Path\nimport numpy as np\nimport pandas as pd\n\n# Import city-level transmission base components module\nimport clt_base as clt\n\n# Import flu model module, which contains customized subclasses\nimport flu_model as flu\n</code></pre> <p>Next, we obtain our filepaths. Note that all our input files we want to use here are located in <code>flu_demo_input_files.</code></p> <pre><code># Obtain path to folder with JSON input files\nbase_path = Path(__file__).parent / \"flu_demo_input_files\"\n\n# Get filepaths for initial values of compartments and epi metrics, fixed parameters, configuration, and travel proportions\ncompartments_epi_metrics_init_vals_filepath = base_path / \"compartments_epi_metrics_init_vals.json\"\nparams_filepath = base_path / \"common_params.json\"\nconfig_filepath = base_path / \"config.json\"\ntravel_proportions_filepath = base_path / \"travel_proportions.json\"\n\n# Get filepaths for school-work calendar CSV \ncalendar_filepath = base_path / \"school_work_calendar.csv\"\n</code></pre> <p>To create a <code>SubpopModel</code>, we need 5 inputs: (1) a dictionary of initial values for compartments and epi metrics, which will set up a  SubpopState<code>instance, (2) a dictionary of fixed parameters, which will be set up a</code>SubpopParams<code>instance, (3) a dictionary of experiment configurations, which will set up a</code>Config<code>instance, (4) a</code>DataFrame<code>with school-work calendar information, and (5) a</code>DataFrame` with travel proportions between subpopulations. </p> <p>Details on input file requirements are given here.</p> <pre><code># Read in files as dictionaries and dataframes\n# Note that we can also create these dictionaries directly\n#   rather than reading from a predefined input data file\nstate_dict = clt.load_json_new_dict(compartments_epi_metrics_init_vals_filepath)\nparams_dict = clt.load_json_new_dict(params_filepath)\nconfig_dict = clt.load_json_new_dict(config_filepath)\ntravel_proportions = clt.load_json_new_dict(travel_proportions_filepath)\n\ncalendar_df = pd.read_csv(calendar_filepath, index_col=0)\n</code></pre> <p>Note that responsible random number generation means using the proper Generator objects, not using something like <code>np.random.seed(123)</code>. For more information, read the official Python <code>numpy.random</code> documentation. </p> <pre><code># Create two independent bit generators\nbit_generator = np.random.MT19937(88888)\njumped_bit_generator = bit_generator.jumped(1)\n</code></pre> <p>Here we show an example with two subpopulation models. Note that we can create as many subpopulation models as we would like. If we wanted the two subpopulation models to have different demographics and initial values, fixed parameters, and school-work calendars, we could use different dictionaries and dataframes when creating each subpopulation model. </p> <pre><code># Create two subpopulation models, one for the north\n#   side of the city and one for the south side of the city\n# In this case, these two (toy) subpopulations have the\n#   same demographics, initial compartment and epi metric values,\n#   fixed parameters, and school-work calendar.\n# If we wanted the \"north\" subpopulation and \"south\"\n#   subpopulation to have different aforementioned values,\n#   we could read in two separate sets of files -- one\n#   for each subpopulation\nnorth = flu.FluSubpopModel(state_dict,\n                           params_dict,\n                           config_dict,\n                           calendar_df,\n                           np.random.Generator(bit_generator),\n                           name=\"north\")\n\nsouth = flu.FluSubpopModel(state_dict,\n                           params_dict,\n                           config_dict,\n                           calendar_df,\n                           np.random.Generator(jumped_bit_generator),\n                           name=\"south\")\n</code></pre> <p>We can access the <code>SubpopParams</code> instance that lives on each <code>SubpopModel</code> using <code>.</code>-notation (for attribute access). Recall that API documentation on attributes can be found here and here.</p> <pre><code># The structure of the code allows us to access\n#   the current state and fixed parameters of each\n#   subpopulation model.\n# For example, here we print out the fixed parameter\n#   value for beta_baseline for the \"south\" subpopulation\nprint(south.params.beta_baseline)\n# 1\n</code></pre> <p>If our two subpopulation models have fixed parameters in common but some different fixed parameters, we could initialize each subpopulation model from the same dictionary of (common) parameters, then make adjustments to the subpopulation model after the fact, like below. Similar logic applies to demographics and initial values, fixed parameters, and school-work calendars. </p> <pre><code># We can also manually change a fixed parameter value\n#   after we have created a SubpopModel -- like so...\n# Note that this is quite a large and unrealistic value of\n#   beta_baseline, but we'll use this to create\n#   a dramatic difference between the two subpopulations\nsouth.params.beta_baseline = 10\n</code></pre> <p>Recall that <code>MetapopModel</code> instances are made up of the <code>SubpopModel</code> instances that comprise the travel model. <code>FluMetapopModel</code> is a subclass of the base <code>MetapopModel</code>. <code>FluSubpopModel</code> is a subclass of the base <code>SubpopModel</code>, customized for a specific functional form (with pre-specified) state variables and transition variables. Below, we create a metapopulation model that is comprised of our two previously defined subpopulation models.</p> <p>To start, we create a <code>FluInterSubpopRepo</code>, a subclass of the base <code>InterSubpopRepo</code>, which manages inter-subpopulation interactions. For our flu metapopulation model, we model travel between subpopulations. <code>FluInterSubpopRepo</code> allows easy querying of subpopulation states and has functions to compute complicated quantities used to model travel.</p> <pre><code># Create FluInterSubpopRepo instance that manages the subpopulation models\n#   and the travel dynamics that link them together\nflu_inter_subpop_repo = flu.FluInterSubpopRepo({\"north\": north, \"south\": south},\n                                               travel_proportions[\"subpop_names_mapping\"],\n                                               travel_proportions[\"travel_proportions_array\"])\n\n# Combine two subpopulations into one metapopulation model (travel model)\nflu_demo_model = flu.FluMetapopModel(flu_inter_subpop_repo)\n</code></pre> <p>It is vital to check that our model inputs are sensible. Below, we display our model and also run model checks. </p> <pre><code># Display written forms of both subpopulation models\n# Check that model inputs are properly formatted and sensible\nflu_demo_model.display()\nflu_demo_model.run_model_checks()\n</code></pre> <p>Simulating the flu model is simple. The following command simulates the model from the current simulation day to the end day specified. </p> <pre><code># Simulate for 50 days\nflu_demo_model.simulate_until_day(50)\n</code></pre> <p>Here's how we access the current simulation day and current real date: </p> <pre><code># Get the current real date of the simulation and the\n#   current simulation day\nprint(flu_demo_model.current_simulation_day)\nprint(flu_demo_model.current_real_date)\n# 50\n# 2022-11-16\n</code></pre> <p>We can start and stop the <code>MetapopModel</code> simulation at any time.  <pre><code># Simulate for another 50 days, from where we last left off\nflu_demo_model.simulate_until_day(100)\n</code></pre></p> <p>Keeping track of the many moving parts in the model is straightforward. We can combine and process these values after we simulate to create our own plots and own analysis. </p> <pre><code># We can \"unpack\" our flu model and access the current state\n#   of each subpopulation -- here's an example with the \"north\"\n#   subpopulation -- this is the state after we have simulated\n#   our 100 days\nprint(flu_demo_model.subpop_models.north.state)\n# FluSubpopState(S=array([[ 72151.],\n#       [130084.]]), E=array([[227819.],\n#       [211647.]]), IP=array([[29671.],\n#       [27533.]]), IS=array([[90178.],\n#       [84027.]]), IA=array([[33146.],\n#       [30962.]]), H=array([[67980.],\n#       [64266.]]), R=array([[439039.],\n#       [414192.]]), D=array([[40016.],\n#       [37289.]]), pop_immunity_hosp=array([[0.53893985],\n#       [0.53592074]]), pop_immunity_inf=array([[0.46572628],\n#       [0.46331838]]), absolute_humidity=7.28333, flu_contact_matrix=array([[4. , 1.5],\n#       [2. , 2. ]]), beta_reduct=0.0, wastewater=None, infection_force=array([[0.71292875],\n#       [0.38677235]]))\n</code></pre> <pre><code># Remember that we can easily access the objects that\n#   make up our subpopulation model -- here's an \n#   example of accessing the \"north\" subpopulation's\n#   compartments\n# See API references for more attribute access syntax\nprint(flu_demo_model.subpop_models.north.compartments)\n#0. 'S':  &lt;clt_base.base_components.Compartment object at 0x17333d0d0&gt;\n#1. 'E':  &lt;clt_base.base_components.Compartment object at 0x17333c910&gt;\n#2. 'IP': &lt;clt_base.base_components.Compartment object at 0x17333cfd0&gt;\n#3. 'IS': &lt;clt_base.base_components.Compartment object at 0x173387f90&gt;\n#4. 'IA': &lt;clt_base.base_components.Compartment object at 0x173387f50&gt;\n#5. 'H':  &lt;clt_base.base_components.Compartment object at 0x173387f10&gt;\n#6. 'R':  &lt;clt_base.base_components.Compartment object at 0x173387ed0&gt;\n#7. 'D':  &lt;clt_base.base_components.Compartment object at 0x173387e90&gt;\n</code></pre> <p>Finally, we can generate different types of plots for the flu model after we have simulated it. Here's a simple compartment history plot. Note that the \"south\" subpopulation has a higher exposed curve and a larger number of infections, which makes sense since we jacked up its baseline transmission rate <code>beta_baseline</code> to \\(10\\).  <pre><code># Generate simple compartment history plot for flu model\nclt.plot_metapop_basic_compartment_history(flu_demo_model, \"basic_compartment_history.png\")\n</code></pre></p> <p></p> <p>We can reset the simulation and run another replication. </p> <pre><code># Reset the simulation\n# Note -- does NOT reset the RNG! Only clears each object's\n#   history, resets the simulation day/date to the starting\n#   day/date, and returns state variables to their initial values.\nflu_demo_model.reset_simulation()\n</code></pre> <p>Note that the previous compartment history graphs had some interesting periodicity. This is because of the school contact matrix and the work contact matrix, and the school-work calendar. To demonstrate, we after resetting the simulation model, we set the school and work contact matrices to be zero matrices for both subpopulations. After re-running the simulation for 100 days and plotting, we see that the periodicity is gone. </p> <pre><code># Set school and work contact matrices to zero matrices for both\n#   subpopulations and demonstrate that this removes the calendar-induced\n#   periodicity\nnum_age_groups = flu_demo_model.subpop_models.north.params.num_age_groups\n\nfor subpop_model in flu_demo_model.subpop_models.values():\n    subpop_model.params.school_contact_matrix = np.zeros((num_age_groups, num_age_groups))\n    subpop_model.params.work_contact_matrix = np.zeros((num_age_groups, num_age_groups))\n\nflu_demo_model.simulate_until_day(100)\n\nclt.plot_metapop_basic_compartment_history(flu_demo_model,\n                                           \"basic_compartment_history_no_periodicity.png\")\n</code></pre> <p></p>"},{"location":"math_flu_components/","title":"Flu Model Mathematical Formulation","text":"<p> \\(\\def\\rateRtoS{\\sigma^{R\\rightarrow S}}\\) \\(\\def\\rateEtoI{\\sigma^{E \\rightarrow [IP, IA]}}\\) \\(\\def\\rateIPtoIS{\\sigma^{IP \\rightarrow IS}}\\) \\(\\def\\rateIStoH{\\sigma^{IS\\rightarrow H}}\\) \\(\\def\\rateHtoD{\\sigma^{H\\rightarrow D}}\\) \\(\\def\\rateIAtoR{\\gamma^{IA\\rightarrow R}}\\) \\(\\def\\rateHtoR{\\gamma^{H\\rightarrow R}}\\) \\(\\def\\rateIStoR{\\gamma^{IS\\rightarrow R}}\\) \\(\\def\\totalforceofinfection{\\lambda^{(\\ell), \\text{total}}_{a,r}(t)}\\) \\(\\def\\propIA{\\pi^{IA}}\\) \\(\\def\\propH{\\pi^H}\\) \\(\\def\\propD{\\pi^D}\\) \\(\\def\\adjustedpropH{\\tilde{\\pi}^H}\\) \\(\\def\\adjustedpropD{\\tilde{\\pi}^D}\\) \\(\\def\\proptravelelltok{v^{\\ell \\rightarrow k}}\\) \\(\\def\\proptravelktoell{v^{k \\rightarrow \\ell}}\\) \\(\\def\\LambdaIIlocagerisktime{\\Lambda^{(\\ell), I, I}_{a,r}(t)}\\) \\(\\def\\LambdaHHlocagerisktime{\\Lambda^{(\\ell), H, H}_{a,r}(t)}\\) \\(\\def\\LambdaDHlocagerisktime{\\Lambda^{(\\ell), D, H}_{a,r}(t)}\\) \\(\\def\\locagerisk{^{(\\ell)}_{a, r}}\\) \\(\\def\\locagerisktime{\\locagerisk(t)}\\) \\(\\def\\locationell{^{(\\ell)}}\\) \\(\\def\\locationk{^{(k)}}\\) \\(\\def\\agerisk{_{a, r}}\\) \\(\\def\\agerisktime{_{a, r}(t)}\\) \\(\\def\\ageprimeriskprime{_{a^\\prime, r^\\prime}}\\) \\(\\def\\locageprimeriskprime{^{(\\ell)}_{a^\\prime, r^\\prime}}\\) \\(\\def\\Nlocagerisk{N^{(\\ell)}_{a,r}}\\) \\(\\def\\effectiveNlocagerisktime{\\tilde{N}^{(\\ell)}_{a,r}(t)}\\) \\(\\def\\effectiveNlocageprimeriskprimetime{\\tilde{N}^{(\\ell)}_{a^\\prime,r^\\prime}(t)}\\) \\(\\def\\multipliertravel{h_{\\text{travel}}}\\) \\(\\def\\multipliersymptom{h_{\\text{symp}}}\\) \\(\\def\\tvarloc{y^{(\\ell)}}\\) \\(\\def\\jointtvarloc{y^{(\\ell) *}}\\) \\(\\def\\simstate{\\boldsymbol{\\Xi}_t}\\) \\(\\def\\agegroups{\\mathcal A}\\) \\(\\def\\riskgroups{\\mathcal R}\\) \\(\\def\\numagegroups{\\lvert \\agegroups \\rvert}\\) \\(\\def\\numriskgroups{\\lvert \\riskgroups \\rvert}\\) </p> <p>Updated 02/26/2025 (work in progress)</p> <p>Written by LP. Travel model formulated by Remy. </p> <p>Important notes: we are updating this page to include wastewater viral load (from Sonny) -- check back soon. Also, please report any typos!</p>"},{"location":"math_flu_components/#flu-model-diagram","title":"Flu model: diagram","text":""},{"location":"math_flu_components/#flu-model-deterministic-differential-equations","title":"Flu model: deterministic differential equations","text":"<ul> <li>\\(t \\in \\mathbb N\\): current simulation day</li> <li>\\(\\ell\\): location, i.e. subpopulation, \\(\\mathcal L\\): set of all locations/subpopulations</li> <li>\\(a\\): age group, \\(\\agegroups\\): set of all age groups</li> <li>\\(r\\): risk group, \\(\\riskgroups\\): set of all risk groups</li> <li>\\(i\\): type of immunity-inducing event, \\(\\mathcal{I} := \\left\\{\\text{H1}, \\text{H3}, \\text{V}\\right\\}\\): the set of all types of immunity-inducing events: infection by H1N1, infection by H3N2, and vaccination, respectively.</li> <li>\\(\\boldsymbol{O}\\): \\(\\numagegroups \\times \\numriskgroups \\times \\lvert \\mathcal{I} \\rvert\\) matrix, where the \\((a, r, i)\\)th element is the positive constant modeling the saturation of antibody production in individuals in age group \\(a\\) and risk group \\(r\\) who had immunity-inducing event \\(i\\).</li> </ul> <p>Population-level immunity against infection (derived from H1N1 infections, H3N2 infections, and vaccinations respectively)</p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\):</p> \\[\\begin{align*} \\frac{dM^{(\\ell), I}_{a, r, H1}(t)}{dt} &amp;= \\frac{g^I_{H1} p_{H1}(t) \\rateRtoS(t) R\\locagerisktime}{N\\locagerisk \\left(1 + \\sum_{i \\in \\mathcal I} O_{a, r, i} M^{(\\ell), I}_{a, r, i}(t)\\right)} - w^I_{H1} M^{(\\ell), I}_{a, r, H1}(t) \\\\ \\frac{dM^{(\\ell), I}_{a, r, H3}(t)}{dt} &amp;= \\frac{g^I_{H3} p_{H3}(t) \\rateRtoS(t) R\\locagerisktime}{N\\locagerisk \\left(1 + \\sum_{i \\in \\mathcal I} O_{a, r, i} M^{(\\ell), I}_{a, r, i}(t)\\right)} - w^I_{H3} M^{(\\ell), I}_{a, r, H3}(t) \\\\ \\frac{dM^{(\\ell), I}_{a, r, V}(t)}{dt} &amp;= g^I_V V^{(\\ell)}(t - \\delta) - w^I_V M^{(\\ell), I}_{a, r, V}(t). \\end{align*}\\] <p>where</p> <ul> <li>\\(\\rateRtoS\\): rate at which recovered individuals become susceptible, so that \\(1/\\rateRtoS\\) is the average number of days a person is totally immune from reinfection until being susceptible again.</li> <li>\\(\\boldsymbol{N}^{(\\ell)}\\): \\(\\numagegroups \\times \\numriskgroups\\) matrix corresponding to total population in location \\(\\ell \\in \\mathcal L\\), where element \\(N\\locagerisk\\) is the total population of age group \\(a\\) and risk group \\(\\ell\\) in location \\(\\ell\\).</li> <li>\\(V^{(\\ell)}(t)\\): number of vaccine doses administered at time \\(t\\) to individuals residing in location \\(\\ell \\in \\mathcal L\\).</li> <li>\\(\\boldsymbol{p} = \\boldsymbol{p}(t) = [p_{H1}(t)\\), \\(p_{H3}(t)]\\): where elements correspond to prevalence of H1N1, H3N2 respectively.</li> <li>\\(\\delta\\): number of days after dose for vaccine to become effective.</li> <li>\\(g^I_{H1}\\): factor by which population-level immunity against infection grows after each H1N1 case that recovers.</li> <li>\\(g^I_{H3}\\): factor by which population-level immunity against infection grows after each H3N2 case that recovers.</li> <li>\\(g^I_V\\): factor by which population-level immunity against infection grows after each vaccination.</li> <li>\\(w^I_{H1}\\): rate at which H1N1 infection-induced immunity against infection wanes.</li> <li>\\(w^I_{H3}\\): rate at which H3N2 infection-induced immunity against infection wanes.</li> <li>\\(w^I_V\\): rate at which vaccine-induced immunity against infection wanes.</li> </ul> <p>Population-level immunity against hospitalization (derived from H1N1 infections, H3N2 infections, and vaccinations respectively)</p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\):</p> \\[\\begin{align} \\frac{dM^{(\\ell), H}_{a, r, H1}(t)}{dt} &amp;= \\frac{g^H_{H1} p_{H1}(t) \\rateRtoS(t) R\\locagerisktime}{N\\locagerisk \\left(1 + \\sum_{i \\in \\mathcal I} O_{a, r, i} M^{(\\ell), H}_{a, r, i}(t)\\right)} - w^H_{H1} M^{(\\ell), H}_{a, r, H1}(t) \\\\ \\frac{dM^{(\\ell), H}_{a, r, H3}(t)}{dt} &amp;= \\frac{g^H_{H3} p_{H3}(t) \\rateRtoS(t) R\\locagerisktime}{N\\locagerisk \\left(1 + \\sum_{i \\in \\mathcal I} O_{a, r, i} M^{(\\ell), H}_{a, r, i}(t)\\right)} - w^H_{H3} M^{(\\ell), H}_{a, r, H3}(t) \\\\ \\frac{dM^{(\\ell), H}_{a, r, V}(t)}{dt} &amp;= g^H_V V(t - \\delta) - w^H_V M^{(\\ell), H}_{a, r, V}(t). \\end{align}\\] <p>where</p> <ul> <li>\\(\\rateRtoS\\), \\(\\boldsymbol{N}^{(\\ell)}\\), \\(p_{H1}(t)\\), \\(p_{H3}(t)\\), \\(V^{(\\ell)}(t)\\), \\(\\delta\\): see above.</li> <li>\\(g^H_{H1}\\): factor by which population-level immunity against hospitalization grows after each H1N1 case that recovers.</li> <li>\\(g^H_{H3}\\): factor by which population-level immunity against hospitalization grows after each H3N2 case that recovers.</li> <li>\\(g^H_V\\): factor by which population-level immunity against hospitalization grows after each vaccination.</li> <li>\\(w^H_{H1}\\): rate at which H1N1 infection-induced immunity against hospitalization wanes.</li> <li>\\(w^H_{H3}\\): rate at which H3N2 infection-induced immunity against hospitalization wanes.</li> <li>\\(w^H_V\\): rate at which vaccine-induced immunity against hospitalization wanes.</li> </ul> <p>Compartment equations</p> <p>To simplify notation, we have the following terms that characterize the effect of population-level immunities for a given subpopulation \\(\\ell\\), age \\(a\\), and risk \\(r\\):</p> \\[\\begin{align} \\LambdaIIlocagerisktime &amp;= \\left[\\frac{K_{a,r}^{I}(p(t))}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times \\lvert \\mathcal L \\rvert} - K_{a,r}^{I}(p(t))}\\right]^T M_{a,r}^{(\\ell), I}(t) \\\\ \\LambdaHHlocagerisktime &amp;= \\left[\\frac{K_{a,r}^{H}(p(t))}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times \\lvert \\mathcal L \\rvert} - K_{a,r}^{H}(p(t))}\\right]^T M_{a,r}^{(\\ell), H}(t) \\\\ \\LambdaDHlocagerisktime &amp;= \\left[\\frac{K_{a,r}^{D}(p(t))}{\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times \\lvert \\mathcal L \\rvert} - K_{a,r}^{D}(p(t))}\\right]^T M_{a,r}^{(\\ell), H}(t) \\end{align}\\] <p>where \\(\\boldsymbol{1}_{\\lvert \\mathcal L \\rvert \\times \\lvert \\mathcal L \\rvert}\\) is an \\(\\lvert \\mathcal L \\rvert \\times \\lvert \\mathcal L \\rvert\\) matrix of \\(1\\)'s and the fraction notation indicates element-wise division. </p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\), we have the following equations that characterize transitions between compartments:</p> \\[\\begin{align} \\frac{dS\\locagerisktime}{dt} &amp;= \\underbrace{\\rateRtoS R\\locagerisktime}_{\\text{$R$ to $S$}}  -\\underbrace{S\\locagerisktime \\frac{\\beta^{(\\ell)}(t) \\cdot \\totalforceofinfection}{\\left(1 + \\LambdaIIlocagerisktime\\right)}}_{\\text{$S$ to $E$}} \\\\[1.5em] \\frac{dE\\locagerisktime}{dt} &amp;= \\underbrace{S\\locagerisktime \\frac{\\beta^{(\\ell)}(t) \\cdot \\totalforceofinfection}{\\left(1 + \\LambdaIIlocagerisktime\\right)}}_{\\text{$S$ to $E$}}  - \\underbrace{\\rateEtoI (1-\\propIA) E\\locagerisktime}_{\\text{$E$ to $IP$}} \\\\[1em] &amp;\\quad\\quad\\quad - \\underbrace{\\rateEtoI \\propIA E\\locagerisktime}_{\\text{$E$ to $IA$}} \\\\[1.5em] \\frac{dIP\\locagerisktime}{dt} &amp;= \\underbrace{\\rateEtoI (1-\\propIA) E\\locagerisktime}_{\\text{$E$ to $IP$}}  - \\underbrace{\\rateIPtoIS IP\\locagerisktime}_{\\text{$IP$ to $IS$}} \\\\[1.5em] \\frac{dIS\\locagerisktime}{dt} &amp;= \\underbrace{\\rateIPtoIS IP\\locagerisktime}_{\\text{$IP$ to $IS$}}  - \\underbrace{(1-\\adjustedpropH_{a, r})\\rateIStoR IS\\locagerisktime}_{\\text{$IS$ to $R$}}  - \\underbrace{\\frac{\\rateIStoH \\adjustedpropH_{a, r} IS\\locagerisktime}{1 + \\LambdaHHlocagerisktime}}_{\\text{$IS$ to $H$}} \\\\[1.5em] \\frac{dIA\\locagerisktime}{dt} &amp;= \\underbrace{\\rateEtoI \\propIA E\\locagerisktime}_{\\text{$E$ to $IA$}}  - \\underbrace{\\rateIAtoR IA\\locagerisktime}_{\\text{$IA$ to $R$}} \\\\[1.5em] \\frac{dH\\locagerisktime}{dt} &amp;= \\underbrace{\\frac{\\rateIStoH \\adjustedpropH_{a, r} IS\\locagerisktime}{1 + \\LambdaHHlocagerisktime}}_{\\text{$IS$ to $H$}}  - \\underbrace{(1-\\adjustedpropD_{a, r})\\rateHtoR H\\locagerisktime}_{\\text{$H$ to $R$}}  - \\underbrace{\\frac{\\rateHtoD \\adjustedpropD_{a, r} H\\locagerisktime}{1 + \\LambdaHHlocagerisktime}}_{\\text{$H$ to $D$}} \\\\[1.5em] \\frac{dR\\locagerisktime}{dt} &amp;= \\underbrace{(1-\\adjustedpropH_{a, r}) \\rateIStoR IS\\locagerisktime}_{\\text{$IS$ to $R$}}  + \\underbrace{\\rateIAtoR IA\\locagerisktime}_{\\text{$IA$ to $R$}}  + \\underbrace{(1-\\adjustedpropD_{a, r})\\rateHtoR H\\locagerisktime}_{\\text{$H$ to $R$}} \\\\[1em] &amp;\\quad\\quad\\quad - \\underbrace{\\rateRtoS R\\locagerisktime}_{\\text{$R$ to $S$}} \\\\[1.5em] \\frac{dD\\locagerisktime}{dt} &amp;= \\underbrace{\\frac{\\rateHtoD \\adjustedpropD_{a, r} H\\locagerisktime}{1 + \\LambdaDHlocagerisktime}}_{\\text{$H$ to $D$}}.  \\end{align}\\] <p>where</p> <ul> <li>The \\(\\lambda\\)-terms are location/subpopulation mixing terms that we define in the next section on the travel model. </li> <li>\\(\\beta^{(\\ell)}(t) = \\beta^{(\\ell)}_0 (1 + q(t))\\): time-dependent transmission rate per day for individuals residing in location \\(\\ell \\in \\mathcal L\\). </li> <li>\\(q(t)\\): seasonality parameter based on absolute humidity, where \\(q(t)\\) is a function of historical absolute humidity data times \\(\\xi\\), a humidity impact factor.</li> <li>\\(\\propIA\\): proportion exposed who are completely asymptomatic when infectious.</li> <li>\\(r_{IP}\\), \\(r_{IA}\\): relative infectiousness (compared to infected symptomatic people) of infected presymptomatic and infected asymptomatic people respectively. </li> <li>\\(\\rateIStoR, \\rateHtoR, \\rateIAtoR\\): recovery rates for infected symptomatic (\\(IS\\)),  hospital (\\(H\\)), and infected asymptomatic (\\(IA\\)) compartments respectively, so that \\(1/\\gamma\\) is the average number of days it takes for an infected person not in the hospital to recover, and \\(1/\\rateHtoR\\) is analogous, but for an infected person in the hospital. </li> <li>\\(\\rateEtoI\\): infection rate (both exposed to infected presymptomatic transition rate and exposed to infected asymptomatic transition rate), so that \\(1/\\rateEtoI\\) is the average number of days after exposure before a person becomes infectious.</li> <li>\\(\\rateIPtoIS\\): infected presymptomatic to infected symptomatic transition rate, so that \\(1/\\rateIPtoIS\\) is the average number of days that an infected person is presymptomatic before becoming symptomatic. </li> <li>\\(\\rateIStoH\\): hospitalization rate (infected to hospital transition rate), so that \\(1/\\rateIStoH\\) is the average number of days a person is infected before going to the hospital.</li> <li>\\(\\rateHtoD\\): death rate from hospital, so that \\(1/\\rateHtoD\\) is the average number of days a person spends in the hospital before dying.</li> <li>\\(\\boldsymbol{\\adjustedpropH}\\), where \\(\\adjustedpropH_{a, r} = \\frac{\\propH_{a, r}\\gamma}{\\rateIStoH - \\propH_{a, r}(\\rateIStoH-\\rateIStoR)}\\): adjusted proportion hospitalized based on age-risk group \\(a, r\\) group actually used in model -- this adjustment is necessary to ensure actual proportion hospitalized recapitulates \\([\\propH_{a, r}]\\).</li> <li>\\(\\boldsymbol{\\propH}\\): \\(\\numagegroups \\times \\numriskgroups\\) proportion hospitalized based on age-risk group \\(a, r\\).</li> <li>\\(\\boldsymbol{\\adjustedpropD}\\), where \\(\\adjustedpropD_{a, r} = \\frac{\\propD_{a, r} \\rateHtoR}{\\rateHtoD - \\propD_{a, r} (\\rateIStoH-\\rateHtoR)}\\): adjusted in-hospital mortality rate (as in, proportion who die in the hospital based on age group) actually used in model -- this adjustment is necessary to ensure actual proportion who die in the hospital recapitulates \\([\\propD_{a, r} ]\\).</li> <li>\\(\\boldsymbol{\\propD}\\): \\(\\numagegroups \\times \\numriskgroups\\) in-hospital mortality rate (proportion who die based on age-risk group \\(a, r\\)).</li> </ul> <p>Note that the following are all \\(\\numagegroups \\times \\numriskgroups \\times \\lvert \\mathcal I \\rvert\\) matrices:</p> <ul> <li>\\(\\boldsymbol{K}^I(\\boldsymbol{p}) = [\\boldsymbol{K}^I_{H1}(p_{H1}), \\boldsymbol{K}^I_{H3}(p_{H3}), \\boldsymbol{K}^I_{V}]\\): reduction in infection risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^{H}(\\boldsymbol{p}) = [\\boldsymbol{K}^H_{H1}(p_{H1}), \\boldsymbol{K}^H_{H3}(p_{H3}), \\boldsymbol{K}^H_{V}]\\): reduction in hospitalization risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^D(\\boldsymbol{p}) = [\\boldsymbol{K}^D_{H1}(p_{H1}), \\boldsymbol{K^D}_{H3}(p_{H3}), \\boldsymbol{K}^D_{V}]\\): reduction in death risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{M}^{(\\ell), I} = \\boldsymbol{M}^{(\\ell), I}(t) = [\\boldsymbol{M}^{(\\ell), I}_{H1}(t), \\boldsymbol{M}^{(\\ell), I}_{H3}(t), \\boldsymbol{M}^{(\\ell), I}_{V}(t)]\\): location \\(\\ell \\in \\mathcal L\\) population-level immunity from infection (induced by H1 infection, H3 infection, vaccination respectively).  </li> <li>\\(\\boldsymbol{M}^{(\\ell), H} = \\boldsymbol{M}^{(\\ell), H}(t) = [\\boldsymbol{M}^{(\\ell), H}_{H1}(t), \\boldsymbol{M}^{(\\ell), H}_{H3}(t), \\boldsymbol{M}^{(\\ell), H}_{V}(t)]\\): location \\(\\ell \\in \\mathcal L\\) population-level immunity from hospitalization (induced by H1 infection, H3 infection, vaccination respectively).</li> </ul> <p>Note that prevalence is time-dependent, but we use \\(\\boldsymbol{p} = \\boldsymbol{p}(t)\\) for notation simplicity. </p>"},{"location":"math_flu_components/#flu-model-travel-model","title":"Flu model: travel model","text":"<p>For each \\(\\ell \\in \\mathcal L\\), \\(k \\in \\mathcal L \\setminus \\{\\ell\\}\\), \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\), we have</p> \\[\\begin{align*} \\totalforceofinfection &amp;= \\lambda^{(\\ell), \\ell \\rightarrow \\ell}_{a, r}(t) + \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\left(\\lambda^{(\\ell), k \\rightarrow \\ell}_{a, r}(t) + \\lambda^{(\\ell), \\ell \\rightarrow k}_{a, r}(t)\\right) \\\\[1.5em] \\lambda^{(\\ell), \\ell \\rightarrow \\ell}_{a, r}(t) &amp;= \\psi_a \\left(1 - c_a \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\proptravelelltok \\right) \\\\ &amp;\\quad\\quad\\quad \\cdot \\sum \\limits_{a^\\prime \\in \\agegroups} \\phi^{(\\ell)}_{a,a^\\prime}(t) \\frac{\\sum_{r^\\prime \\in \\riskgroups} \\left[IS\\locageprimeriskprime(t) + r_{IP} IP\\locageprimeriskprime(t) + r_{IA} IA\\locageprimeriskprime(t)\\right]}{\\sum_{r^\\prime \\in \\riskgroups} \\effectiveNlocageprimeriskprimetime} \\\\[1.5em] \\lambda_{a,r}^{(\\ell), k \\rightarrow \\ell}(t) &amp;= \\psi_a \\cdot \\multipliertravel \\cdot \\proptravelktoell \\\\ &amp;\\quad \\cdot \\sum\\limits_{a^\\prime \\in \\agegroups} c_{a^\\prime} \\cdot \\phi^{(\\ell)}_{a, a^\\prime}(t) \\frac{\\sum_{r^\\prime \\in \\riskgroups}\\left[\\multipliersymptom IS\\locationk\\ageprimeriskprime(t) + r_{IP} IP\\locationk\\ageprimeriskprime(t) + r_{IA} IA\\locationk\\ageprimeriskprime(t)\\right]}{\\sum_{r^\\prime \\in \\riskgroups} \\effectiveNlocageprimeriskprimetime} \\\\[1.5em] \\lambda_{a,r}^{(\\ell), \\ell \\rightarrow k}(t) &amp;= \\psi_a \\cdot \\multipliertravel \\cdot \\proptravelelltok  \\cdot c_a \\\\ &amp;\\quad\\quad\\quad \\cdot \\sum\\limits_{a^\\prime \\in \\agegroups} \\phi^{(\\ell)}_{a, a^\\prime}(t) \\frac{\\sum_{r^\\prime \\in \\riskgroups} \\left[IS\\locationk\\ageprimeriskprime(t) + r_{IP} IP\\locationk\\ageprimeriskprime(t) + r_{IA} IA\\locationk\\ageprimeriskprime(t)\\right]}{\\sum_{r^\\prime \\in \\riskgroups} \\tilde{N}^{(k)}_{a^\\prime, r^\\prime} (t)} \\end{align*}\\] <p>where</p> \\[\\begin{align*} \\effectiveNlocagerisktime &amp;= \\Nlocagerisk + c_a \\cdot \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\proptravelktoell \\cdot (N^{(k)}_{a, r} - (1-\\multipliersymptom) IS^{(k)}_{a,r}(t) - H^{(k)}_{a,r}(t)) \\\\ &amp;\\quad\\quad\\quad - c_a \\cdot \\sum_{k \\in \\mathcal L \\setminus \\{\\ell\\}} \\proptravelelltok  \\cdot (N\\locagerisk - (1-\\multipliersymptom) IS\\locagerisktime - H^{(\\ell)}_{a,r}(t)) \\end{align*}\\] <p>is the effective population in location \\(\\ell \\in \\mathcal L\\) and age-risk group \\(a \\in \\agegroups\\), \\(r \\in \\riskgroups\\) at time \\(t\\), and where</p> <ul> <li>\\(\\phi_{a, a^\\prime}^{(\\ell)}(t)\\): the number of contacts that individuals in age group \\(a \\in \\agegroups\\) residing in location \\(\\ell \\in \\mathcal L\\) have with other individuals (regardless of location) in age group \\(a^\\prime \\in \\agegroups\\). </li> <li>\\(\\psi_a \\in [0, 1]\\): relative susceptibility of individuals in age group \\(a \\in \\agegroups\\).</li> <li>\\(\\proptravelktoell\\): proportion of population in location \\(k \\in \\mathcal L\\) that travels to location \\(\\ell \\in \\mathcal L\\).</li> <li>\\(c_a\\): proportion of time individuals in age group \\(a \\in \\agegroups\\) spend away from home region when traveling. </li> <li>\\(\\multipliertravel \\in [0,1]\\): multiplier to reduce contact rate of traveling individuals. </li> <li>\\(\\multipliersymptom \\in [0,1]\\): multiplier to reduce contact rate of symptomatic individuals.</li> </ul> <p>Note that the decompositions model the following phenomenon:</p> <ul> <li>\\(\\lambda^{(\\ell), k \\rightarrow \\ell}\\agerisktime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(k\\) but travel to location \\(\\ell\\) (note: this contact occurs in location \\(\\ell\\)).</li> <li>\\(\\lambda^{(\\ell), \\ell \\rightarrow k}\\agerisktime\\): rate at which individuals in location \\(\\ell\\) get exposed to infected people who live in location \\(k\\), due to individuals who live in location \\(\\ell\\) traveling to location \\(k\\) (note: this contact occurs in location \\(k\\)).</li> </ul>"},{"location":"math_flu_components/#flu-model-discretized-stochastic-implementation","title":"Flu model: discretized stochastic implementation","text":"<p>To actually implement/simulate this compartmental model, we discretize the deterministic differential equations and treat transitions between compartments as stochastic to model uncertainty. We extend the notation from the deterministic differential equations to capture the stochastic elements.</p> <p>Let \\(\\boldsymbol{\\mathcal X}(t) = \\left\\{\\boldsymbol{S}(t), \\boldsymbol{E}(t), \\boldsymbol{I}(t), \\boldsymbol{H}(t), \\boldsymbol{R}(t), \\boldsymbol{D}(t), \\boldsymbol{M}^I(t), \\boldsymbol{M}^H(t), q(t), \\boldsymbol{\\phi}(t), \\boldsymbol{p}(t), V^{(\\ell)}(t)\\right\\}\\) be the \"simulate state\" at time \\(t\\). \\(\\boldsymbol{\\mathcal X}(t)\\) is a set of matrices. </p> <p>Let \\(\\boldsymbol{\\Theta} = \\left\\{\\boldsymbol{O}, \\boldsymbol{N}, \\boldsymbol{g}^I, \\boldsymbol{w}^I, \\boldsymbol{g}^H, \\boldsymbol{w^H}, \\beta_0, \\gamma, \\rateHtoR, \\rateEtoI, \\boldsymbol{\\propH}, \\rateIStoH, \\boldsymbol{\\propD}, \\rateHtoD, \\rateRtoS \\right\\}\\) be the set of fixed parameters. We define notation \\(\\boldsymbol{g}^I = [g^I_{H1}, g^I_{H3}, g^I_V]\\),  \\(\\boldsymbol{w}^I = [w^I_{H1}, w^I_{H3}, w^I_V]\\), \\(\\boldsymbol{g}^H = [g^H_{H1}, g^H_{H3}, g^H_V]\\), and \\(\\boldsymbol{w}^H = [w^H_{H1}, w^H_{H3}, w^H_V]\\). </p> <p>Then given initial state \\(\\boldsymbol{\\mathcal X}_0 = \\boldsymbol{\\mathcal X}(0)\\), we can formulate our discretized stochastic implementation as</p> \\[ \\boldsymbol{\\mathcal X}(t + \\Delta t) = \\boldsymbol{\\mathcal X}(t) + f\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega; \\boldsymbol{\\Theta}\\right) \\quad \\text{for} \\quad t \\ge 0, \\] <p>where \\(f\\) is parametrized by \\(\\boldsymbol{\\Theta}\\), and depends on the step size of discretization \\(\\Delta t\\) and a sample path \\(\\omega\\). We assume that each sample path \\(\\omega\\) is realized from a random process that does not depend on \\(\\boldsymbol{\\mathcal X}(t)\\) or \\(\\Delta t\\) for each \\(t\\). When we are discussing a single model with a fixed set of parameters \\(\\boldsymbol{\\Theta}\\), we drop the \\(\\boldsymbol{\\Theta}\\) notation for simplicity.  </p> <p>Now we formulate how we implement discretized stochastic transitions. We assume that \\(q(t)\\), \\(\\boldsymbol{\\phi}(t)\\), \\(\\boldsymbol{p}(t)\\), and \\(V^{(\\ell)}(t)\\)  are updated deterministically according to some \"schedule.\"  </p> <p>We model stochastic transitions between compartments using \"transition variables.\" Transition variables correspond to incoming and outgoing flows of epidemiological compartments (see the compartment equations above). </p> <p>Below we formulate the discretized stochastic transitions. For brevity, we omit the update formulas for \\(\\boldsymbol{M}^H(t)\\) since it is analogous to the discretized update for \\(\\boldsymbol{M}^I(t)\\). Note that the population-level immunity variables behave as aggregate epidemiological metrics. They are deterministic functions of the simulation state and transitions between compartments.</p> <p>IMPORTANT NOTE_: all \\(y\\) and \\(y^*\\)-variables depend on \\(\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). For notation simplicity, we define \\(\\simstate := \\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and write \\(y\\) and \\(y^*\\)-variables as functions of \\(\\simstate\\).</p> <p>For each \\(\\ell \\in \\mathcal L\\), \\(a \\in \\agegroups\\), and \\(r \\in \\riskgroups\\):</p> \\[\\begin{align} M_{a, r, H1}^{(\\ell), I}(t + \\Delta t) &amp;= M_{a, r, H1}^{(\\ell), I}(t) \\\\[1em] &amp;\\quad\\quad\\quad + \\left[\\frac{g^I_{H1} p_{H1}(t) \\cdot \\overbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}^{\\text{$R$ to $S$}}}{N_{a,r} \\left(1 + \\sum_{i \\in \\mathcal I} O_{a,r, i} M^I_{a,r, i}(t)\\right)} - w^I_{H1} M^I_{a,r,H1}(t)\\right] \\Delta t \\\\ M_{a, r, H3}^{(\\ell), I}(t + \\Delta t) &amp;= M_{a, r, H3}^{(\\ell), I}(t) + \\\\[1em] &amp;\\quad\\quad\\quad \\left[\\frac{g^I_{H3} p_{H3}(t) \\cdot \\overbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}^{\\text{$R$ to $S$}}}{N_{a,r} \\left(1 + \\sum_{i \\in \\mathcal I} O_{a,r, i} M^I_{a,r, i}(t)\\right)} - w^I_{H3} M^I_{a,r,H3}(t)\\right] \\Delta t \\\\ M_{a,r,V}^{(\\ell), I}(t + \\Delta t) &amp;= M_{a,r,V}^{(\\ell), I}(t) + \\left[g^I_V V(t - \\delta) - w^I_V M^I_{a,r,V}(t)\\right] \\Delta t \\end{align}\\] \\[ \\vdots \\] \\[\\begin{align} S\\locagerisk(t + \\Delta t) &amp;= S_{a, r}^{(\\ell)}(t) + \\underbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}_{\\text{$R$ to $S$}} - \\underbrace{\\tvarloc_{S\\rightarrow E, a, r}(\\Xi_t)}_{\\text{$S$ to $E$}} \\\\ E\\locagerisk(t + \\Delta t) &amp;= E_{a, r}^{(\\ell)}(t) + \\underbrace{\\tvarloc_{S\\rightarrow E, a, r}(\\Xi_t)}_{\\text{$S$ to $E$}} - \\underbrace{\\jointtvarloc_{E\\rightarrow IP, a, r}(\\Xi_t)}_{\\text{$E$ to $IP$}} - \\underbrace{\\jointtvarloc_{E\\rightarrow IA, a, r}(\\Xi_t)}_{\\text{$E$ to $IA$}} \\\\ IP\\locagerisk(t + \\Delta t) &amp;= IP\\locagerisktime + \\underbrace{\\jointtvarloc_{E\\rightarrow IP, a, r}(\\Xi_t)}_{\\text{$E$ to $IP$}} - \\underbrace{\\tvarloc_{IP \\rightarrow IS, a, r}(\\Xi_t)}_{\\text{$IP$ to $IS$}} \\\\ IA_{a, r}^{(\\ell)}(t + \\Delta t) &amp;= IA_{a, r}^{(\\ell)}(t) + \\underbrace{\\jointtvarloc_{E\\rightarrow IA, a, r}(\\Xi_t)}_{\\text{$E$ to $IA$}} - \\underbrace{\\tvarloc_{IA \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IA$ to $R$}} \\\\ IS\\locagerisk(t + \\Delta t) &amp;= IS_{a, r}^{(\\ell)}(t) + \\underbrace{\\tvarloc_{E \\rightarrow IS, a, r}(\\Xi_t)}_{\\text{$E$ to $IP$}} - \\underbrace{\\jointtvarloc_{IS \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IS$ to $R$}} - \\underbrace{\\jointtvarloc_{IS \\rightarrow H, a, r}(\\Xi_t)}_{\\text{$IS$ to $H$}} \\\\ H\\locagerisk(t + \\Delta t) &amp;= H_{a, r}^{(\\ell)}(t) + \\underbrace{\\jointtvarloc_{IS \\rightarrow H, a, r}(\\Xi_t)}_{\\text{$IS$ to $H$}} - \\underbrace{\\jointtvarloc_{H\\rightarrow R, a, r}(\\Xi_t)}_{\\text{$H$ to $R$}} - \\underbrace{\\jointtvarloc_{H\\rightarrow D, a, r}(\\Xi_t)}_{\\text{$H$ to $D$}} \\\\ R\\locagerisk(t + \\Delta t) &amp;= R_{a, r}^{(\\ell)}(t) + \\underbrace{\\jointtvarloc_{IS \\rightarrow R, a, r}(\\Xi_t)}_{\\text{$IS$ to $R$}} + \\underbrace{\\jointtvarloc_{H\\rightarrow R, a, r}(\\Xi_t)}_{\\text{$H$ to $R$}} - \\underbrace{\\tvarloc_{R\\rightarrow S, a, r}(\\Xi_t)}_{\\text{$R$ to $S$}} \\\\ D\\locagerisk(t + \\Delta t) &amp;= D_{a, r}^{(\\ell)}(t) + \\underbrace{\\tvarloc_{H\\rightarrow D, a, r}(\\Xi_t)}_{\\text{$H$ to $D$}}.  \\end{align}\\] <p>IMPORTANT NOTE: the \"\\(*\\)\" superscript indicates that the transition variable has a joint distribution with another transition variable. In general, if a compartment has more than one outgoing transition variable, these transition variables must be modeled jointly. </p> <p>Consider the two transitions out of the infected symptomatic compartment, for example. Given that a patient is infected and symptomatic, exactly one outcome occurs: they recover (from home) or they go to the hospital. Since one and only one of these outcomes must occur, we must model these two transition variables jointly. Joint distribution derivation details are provided in the next section on transition types.</p> <p>Each transition variable depends on a \"base count\" and a \"rate\" (which both depend on the current state of the system). This decomposition is displayed in the table below. Note that these transitions are for a given location \\(\\ell \\in \\mathcal L\\).</p> Transition Transition variable Base count Rate \\(R\\) to \\(S\\) \\(\\tvarloc_{R \\rightarrow S, a, r}(\\simstate)\\) \\(R_{a, r}^{(\\ell)}(t)\\) \\(\\rateRtoS\\) \\(S\\) to \\(E\\) \\(\\tvarloc_{S \\rightarrow E, a, r}(\\simstate)\\) \\(S_{a, r}^{(\\ell)}(t)\\) \\(\\totalforceofinfection\\) \\(E\\) to \\(IP\\) \\(\\jointtvarloc_{E \\rightarrow IP, a, r}(\\simstate)\\) \\(E_{a, r}^{(\\ell)}(t)\\) \\(\\rateEtoI (1 - \\propIA)\\) \\(E\\) to \\(IA\\) \\(\\jointtvarloc_{E \\rightarrow IA, a, r}(\\simstate)\\) \\(E_{a, r}^{(\\ell)}(t)\\) \\(\\rateEtoI \\propIA\\) \\(IP\\) to \\(IS\\) \\(\\tvarloc_{IP \\rightarrow IS, a, r}(\\simstate)\\) \\(IP_{a, r}^{(\\ell)}(t)\\) \\(\\rateIPtoIS\\) \\(IS\\) to \\(R\\) \\(\\jointtvarloc_{IS \\rightarrow R, a, r}(\\simstate)\\) \\(IS_{a, r}^{(\\ell)}(t)\\) \\((1-\\adjustedpropH_{a,r})\\gamma\\) \\(IS\\) to \\(H\\) \\(\\jointtvarloc_{IS \\rightarrow H, a, r}(\\simstate)\\) \\(IS_{a, r}^{(\\ell)}(t)\\) \\(\\frac{\\rateIStoH \\adjustedpropH_{a,r} IS\\locagerisktime}{1 + \\LambdaHHlocagerisktime}\\) \\(IA\\) to \\(R\\) \\(\\tvarloc_{IA \\rightarrow R, a, r}(\\simstate)\\) \\(IA_{a, r}^{(\\ell)}(t)\\) \\(\\rateIAtoR IA\\locagerisktime\\) \\(H\\) to \\(R\\) \\(\\jointtvarloc_{H \\rightarrow R, a, r}(\\simstate)\\) \\(H_{a, r}^{(\\ell)}(t)\\) \\((1-\\adjustedpropD_{a,r})\\rateHtoR\\) \\(H\\) to \\(D\\) \\(\\jointtvarloc_{H \\rightarrow D, a, r}(\\simstate)\\) \\(H_{a, r}^{(\\ell)}(t)\\) \\(\\frac{\\rateHtoD \\adjustedpropD_{a,r} H\\locagerisktime}{1 + \\LambdaHHlocagerisktime}\\) <p>The base count and rate of a transition variable parameterize the distribution that defines its realization. </p> <p>See this page for mathematical formulations of marginal and joint stochastic transitions between compartments. </p>"},{"location":"math_flu_components/#general-model-discretized-stochastic-implementation","title":"General model: discretized stochastic implementation","text":"<p>We make the important note that the flu model's discretized stochastic implementation can be generalized to models with different structures. More broadly, we let \\(\\boldsymbol{\\mathcal C}(t)\\) be a model's set of epidemiological compartments, \\(\\boldsymbol{\\mathcal M}(t)\\) its set of aggregate epidemiological metrics, and \\(\\boldsymbol{S (t)}\\) its set of schedule-dependent (time-dependent) deterministic values. Then the above formulation still holds.</p> <p>In fact, in our code, we model \\(\\boldsymbol{\\mathcal C(t)}\\) using an <code>Compartment</code> class, \\(\\boldsymbol{\\mathcal M}(t)\\) using an <code>EpiMetric</code> class, and \\(\\boldsymbol{\\mathcal S(t)}\\) using a <code>Schedule</code> class. We handle stochastic transitions using <code>TransitionVariable</code> and <code>TransitionVariableGroup</code> classes. These classes form some of the building blocks of the base model code. </p>"},{"location":"math_transitions/","title":"Stochastic Transitions","text":"<p>Written by LP, updated 01/30/2025 </p>"},{"location":"math_transitions/#marginal-transition-types","title":"Marginal transition types","text":"<p>Our codebase currently implements six types of transitions: three stochastic transitions and three deterministic counterparts.</p> <p>First we consider marginal (not joint) transition variables. For the following table, consider \\(y_{\\texttt{C}\\rightarrow\\texttt{C}^\\prime, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) from compartment \\(\\texttt{C}\\) to \\(\\texttt{C}^\\prime\\). Let \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t)\\) be its current value of its base count and \\(\\texttt{r} = \\texttt{r}_{a, \\ell}(t)\\) be its current value of its rate. Then depending on its transition type, its distribution (or deterministic value) is given below.</p> <p>Note that \\(\\alpha\\) is a function that converts a \"rate\" into a probability. It is given by: $$ \\alpha(\\texttt{r}, \\Delta t) = 1 - \\exp(-\\texttt{r} \\cdot \\Delta t) $$ and corresponds to the probability that a Poisson process with rate \\(\\texttt{r}\\) produces at least one event in an interval of length \\(\\Delta t\\). </p> <p>The following table provides the mathematical distribution or deterministic output for each transition type. </p> Output Binomial \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\alpha(\\texttt{r}, \\Delta t)\\right)\\) Binomial  Taylor Approx \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\texttt{r} \\cdot \\Delta t\\right)\\) Poisson \\(\\sim \\text{Poisson}\\left(\\lambda = \\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\right)\\) Binomial Deterministic \\(\\texttt{b} \\cdot \\alpha(\\texttt{r}, \\Delta t)\\) Binomial Taylor Approx Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\) Poisson Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\)"},{"location":"math_transitions/#joint-transition-types","title":"Joint transition types","text":"<p>Here we describe joint transition variables. For the following table, consider a compartment \\(\\texttt{C}_0\\) with two outgoing compartments, \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). We describe \\(2\\) transition variables: \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). They respectively correspond to the number of people that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_1\\) and the number that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_2\\) at a given simulate state. Let their rates be \\(\\texttt{r}_1\\) and \\(\\texttt{r}_2\\) respectively.  </p> <p>We can also write the number that remain in \\(\\texttt{C}_0\\) explicitly as  \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) = \\texttt{C}_{0, a, \\ell}(t) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). Note that this quantity is purely for parametrizing multinomial distributions (which needs to have its probability parameters sum to \\(1\\)) and does not need to be literally modeled as a transition variable either mathematically or in code. </p> <p>Let \\(\\alpha\\) be defined as in the previous section on marginal transition types.</p> <p>The following table gives the parameters for multinomial transitions when \\(\\texttt{C}_0\\) has two outgoing compartments \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). The values \\([y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)]\\) are sampled jointly, using \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t) = \\texttt{C}_{0, a, \\ell}(t)\\) as the \"number of trials\" parameter \\(n\\) in a multinomial distribution.</p> Transition  Variable Group (Jointly Sampled) Multinomial Probability Parameter Multinomial with Taylor Approx Probability Parameter \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_1}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_1 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_2}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_2 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(1 - \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(1 - (\\texttt{r}_1 + \\texttt{r}_2) \\Delta t\\)"},{"location":"math_transitions/#important-notes","title":"Important notes","text":"<ul> <li> <p>The transition variable group table formulas generalize to an arbitrary number of outgoing compartments -- however, this is not shown here.</p> </li> <li> <p>Note that Poisson is not included in the above table. Recall the splitting property of Poisson processes. If the total outflow (going to either compartment, \\(\\texttt{C}_1\\) or \\(\\texttt{C}_2\\)) is Poisson, we can split the process into two independent Poisson processes. So joint sampling is not actually needed. </p> </li> <li> <p>In contrast, the binomial distribution does not have such a splitting property. If the total outflow is binomial with parameters \\(n\\) and \\(p\\), then we cannot use a similar Poisson splitting technique to create two independent binomial random variables with the same number of trial parameters \\(n\\). Thus, joint sampling is needed. </p> </li> <li> <p>An advantage of binomial/multinomial transition variables (with joint sampling when there are multiple outflows from a compartment) is that we cannot have more people leaving the origin compartment than are actually in the compartment. We set the \"number of trials\" parameter in the multinomial distribution to be the current number of people in the compartment. This is NOT the case for Poisson transition variables, which are unbounded! Thus, we recommend using binomial/multinomial transition types.</p> </li> <li> <p>For the binomial/multinomial Taylor approximation transition type, if the simulation discretization parameter \\(\\Delta t\\) is too large, then it is possible for the \"probability parameter\" to be nonsensical. For example, in the table above, it is possible for \\(r_1 \\Delta t &gt; 1\\) or \\(r_2 \\Delta t &gt; 1\\) if \\(\\Delta t\\) is not sufficiently small. Similarly, it is possible for \\(1 - (r_1 + r_2) \\Delta t &lt; 0\\) if \\(\\Delta t\\) is not sufficiently small. Thus, we cannot use these values as probabilities input for the binomial distribution. As a result, we recommend using the binomial transition type with no Taylor approximation. This transition type converts rates into probabilities that are always between \\([0,1]\\) and thus always well-defined to be input as a probability parameter in a binomial distribution.</p> </li> </ul>"},{"location":"old/","title":"Old","text":"<p>In this section, we provide an explanation of how the flu model (in <code>flu_components.py</code>) is created from the base model components (in <code>base_components.py</code>). In doing so, we also demonstrate how to create other customized models from the base model components. We also provide justification for design choices, in a way intended to educate users on some of the implementation and computation challenges in writing scalable and adaptable compartmental models. </p> <p>Writing code to create a customized compartmental model requires correct use of inheritance, composition, and abstract base classes. We strongly recommend reading this tutorial for a good primer on those subjects. We also recommend learning about the <code>dataclass</code> decorator in Python (see this blogpost, for example).</p>"},{"location":"old/#creating-a-model-from-base-components-details","title":"Creating a model from base components: details","text":"<p>Creating a compartment model requires the following steps.</p> <ol> <li> <p>Formulate the compartment model mathematically, and write down all <code>EpiCompartment</code>, <code>TransitionVariable</code>, <code>TransitionVariableGroup</code> (jointly sampled sets of transition variables), and <code>StateVariable</code> objects needed for the model. </p> </li> <li> <p>Create a new file that imports the <code>base_components</code> module. We import this module as <code>base</code>. </p> </li> <li> <p>Create two <code>JSON</code> files: one for fixed parameters and one for initial values of state variables. </p> <p>a. For the fixed parameters <code>JSON</code> file, required fields are <code>\"num_age_groups\"</code>, <code>\"num_risk_groups\"</code>, and <code>\"total_population_val\"</code>. All other fields must correspond to fixed parameters in the model -- these are used throughout model computation.</p> <ul> <li>See <code>flu_demo_input_files / fixed_params.json</code>.</li> </ul> <p>b. For the initial values of state variables <code>JSON</code> file, there must be a field for each <code>StateVariable</code> object used in the model. These values correspond to the initial values of these state variables. For example, this file contains initial populations of each <code>EpiCompartment</code>, expressed as a list of lists corresponding to age groups and risk groups. Similarly, this file contains starting values for each <code>EpiMetric</code>. We also need fields for all <code>DynamicVal</code> and <code>Schedule</code> objects in the model, although their values can be set to <code>null</code> since their initial state will be updated automatically (either according to a deterministic calendar or a simulate state trigger). We just need to include their names for bookkeeping purposes. </p> <ul> <li>See <code>flu_demo_input_files / state_variables_init_vals.json</code>.</li> </ul> </li> <li> <p>Create subclasses to hold data. </p> <p>a. Create a subclass of <code>base.FixedParams</code> to hold the model's fixed parameters. For each name in the fixed parameters <code>JSON</code> file, there should be a corresponding attribute (with the same name) in this subclass.</p> <ul> <li>See <code>FluFixedParams</code> in <code>flu_components.py</code>.</li> </ul> <p>b. Create a subclass of <code>base.SimState</code> to hold the model's simulation state. For each name in the initial values of state variables <code>JSON</code> file, there should be a corresponding attribute (with the same name) in this subclass. </p> <ul> <li>See <code>FluSimState</code> in <code>flu_components.py</code>.</li> </ul> </li> <li> <p>For each transition in the model, create a subclass of <code>base.TransitionVariable</code> and provide a concrete implementation of the abstract method <code>get_current_rate</code>. The function <code>get_current_rate</code> returns the value of the current rate, and is a function of a <code>FluSimState</code> instance and a <code>FluFixedParams</code> instance. These arguments allow us to access various values needed for the computation. </p> <ul> <li>See <code>SusceptibleToExposed</code> subclass in <code>flu_components.py</code>. The function <code>get_current_rate</code> implements the formula for computing the current rate that people transition from the susceptible to exposed compartment. For example, <code>get_current_rate</code> grabs <code>sim_state.IS</code>, <code>sim_state.IP</code>, and <code>sim_state.IA</code>, because the current values of the symptomatic, pre-symptomatic, and asymptomatic infectious compartments are needed for the rate computation.</li> </ul> </li> <li> <p>For each dynamic value in the model, create a subclass of <code>base.DynamicVal</code> and provide a concrete implementation of the abstract method <code>update_current_val</code>. The function <code>update_current_val</code> also takes a <code>FluSimState</code> instances and <code>FluFixedParams</code> instance as arguments, analogously to <code>TransitionVariable</code> subclasses. It updates the <code>current_val</code> attribute in-place.</p> <ul> <li>See <code>BetaReduct</code> in <code>flu_components.py</code>. Note here we have also customized the <code>_init_</code> method and added an attribute <code>permanent_lockdown</code>, to accommodate additional functionality. </li> </ul> </li> <li> <p>For each schedule in the model, create a subclass of <code>base.Schedule</code> and provide a concrete implementation of the abstract method <code>update_current_val</code>, which should be a function of the current date (a <code>datetime.date</code> instance). This function updates the <code>current_val</code> attribute in place.  </p> <ul> <li>See <code>AbsoluteHumidity</code> in <code>flu_components.py</code>. Note we update the current value using the helper function <code>absolute_humidity_func</code>.   </li> </ul> </li> <li> <p>Create a subclass of <code>base.ModelConstructor</code>. Customize the <code>_init_</code> function and provide concrete implementations for the six abstract methods (listed below). </p> <ul> <li>See <code>FluModelConstructor</code> in <code>flu_components.py</code>.</li> </ul> <p>a. Customize the <code>_init_</code> function.</p> <ul> <li>See <code>_init_</code> in <code>FluModelConstructor</code>. This method first calls <code>super()._init_()</code>, which runs the initialization method of the parent class. Importantly, the parent class initialization creates dictionaries that hold our objects (for example, it creates the attribute <code>compartment_lookup</code>). Then we assign the <code>config</code>, <code>fixed_params</code>, and <code>sim_state</code> attributes according to the contents of user-specified <code>JSON</code> files.</li> </ul> <p>b. Provide a concrete implementation of <code>setup_epi_compartments</code>. Specifically, for every compartment, create an entry in <code>compartment_lookup</code>, with the name as the key and the value as the corresponding <code>EpiCompartment</code> instance. Names should match the compartment names in the initial values of state variables <code>JSON</code>.</p> <p>c. Provide a concrete implementation of <code>setup_dynamic_vals</code>. Specifically, for every dynamic value, create an entry in <code>dynamic_val_lookup</code>, with the name as the key and the value as the corresponding <code>DynamicVal</code> instance. Names should match the dynamic value names in the initial values of state variables <code>JSON</code>.</p> <ul> <li>In <code>FluModelConstructor</code>, we create an entry in <code>dynamic_val_lookup</code> with the key of <code>\"beta_reduct\"</code> and the value of a properly initialized <code>BetaReduct</code> instance. Note that <code>BetaReduct</code> is a <code>DynamicVal</code>, but we cannot use <code>DynamicVal</code> directly, as it is an abstract class. We have to use the relevant concretely implemented subclass.</li> </ul> <p>d. Provide a concrete implementation of <code>setup_schedules</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).</p> <p>e. Provide a concrete implementation of <code>setup_transition_variables</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).</p> <p>f. Provide a concrete implementation of <code>setup_transition_variable_groups</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).      </p> <p>g. Provide a concrete implementation of <code>setup_epi_metrics</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).  </p> </li> </ol>"},{"location":"old/#creating-a-model-from-base-components-checklist","title":"Creating a model from base components: checklist","text":"<p>Here we provide a brief outline of steps for creating a compartment model, intended as a reminder checklist. Please see the previous section for explanatory details. </p> <ol> <li> <p>Formulate the compartment model.</p> </li> <li> <p>Create a new file that imports the <code>base_components</code> module. We import this module as <code>base</code>. </p> </li> <li> <p>Create two <code>JSON</code> files: one for fixed parameters and one for initial values of state variables. </p> <ul> <li>Initial values for schedules and dynamic values can be left as <code>null</code>, but they still must have a field in the <code>JSON</code> file. </li> </ul> </li> <li> <p>Create subclasses to hold data: a subclass of <code>base.FixedParams</code> and a subclass of <code>base.SimState</code>. </p> <ul> <li>Note that there should be a one-to-one mapping between the fixed parameters <code>JSON</code> file and the attributes of <code>base.FixedParams</code>, and similarly for the initial values of state variables <code>JSON</code> and the attributes of <code>base.SimState</code>. </li> </ul> </li> <li> <p>For each transition variable in the model, create a unique subclass of <code>base.TransitionVariable</code> corresponding to that transition and provide a concrete implementation of <code>get_current_rate</code>.</p> </li> <li> <p>For each dynamic value in the model, create a subclass of <code>base.DynamicVal</code> and provide a concrete implementation of <code>update_current_val</code>.</p> </li> <li> <p>For each schedule in the model, create a subclass of <code>base.Schedule</code> and provide a concrete implementation of <code>update_current_val</code>.</p> </li> <li> <p>Create a subclass of <code>base.ModelConstructor</code>. Customize the <code>_init_</code> function, making sure to assign the <code>config</code>, <code>fixed_params</code>, and <code>sim_state</code> attributes to instances of <code>base.Config</code>, <code>base.FixedParams</code>, and <code>base.SimState</code>. Provide concrete implementations of <code>setup_epi_compartments</code>, <code>setup_dynamic_vals</code>, <code>setup_schedules</code>, <code>setup_transition_variables</code>, <code>setup_transition_variable_groups</code>, and <code>setup_epi_metrics</code>. </p> </li> </ol> <p>Note: figures below were generated with older flu model version without presymptomatic and asymptomatic infected compartments -- figures generated with updated code will look slightly different. </p> <p>Here we provide a quickstart tutorial to help users immediately start playing with the flu model in <code>flu_components.py</code> with \"toy\" inputs given by <code>JSON</code> files in <code>flu_demo_input_files</code>. Recall that the structure (functional form) of the flu model is specified in <code>flu_components.py</code>, and the input files simply specify fixed parameter values and initial values for state variables.  See this page for the mathematical formulation of the flu model. For creating their own custom input files, users should refer to tables on this page that map code variable names to their respective math variables and specify variable dimensions. </p> <p>The code snippet below is from <code>flu_demo.py</code>. The script can be run directly from the terminal using </p> <pre><code>python flu_demo.py\n</code></pre> <p>Here\u2019s the basic procedure to populate the flu model using input files:</p> <ol> <li> <p>Create a <code>FluModelConstructor</code> instance that takes three file paths as input: the configuration file path, fixed parameter values file path, and initial values file path (all in <code>JSON</code> format).</p> </li> <li> <p>Use this constructor to create a <code>TransmissionModel</code> instance whose functional form is specified by <code>flu_components.py</code> and whose fixed parameter values and initial values are specified in the three aforementioend files.</p> </li> </ol> <p>After this, we can simulate the model and plot its behavior. Below, we simulate 300 days. </p> <pre><code>import numpy as np\nfrom pathlib import Path\n\nfrom flu_components import FluModelConstructor\nfrom plotting import create_basic_compartment_history_plot\n\n# Obtain path to folder with JSON input files\nbase_path = Path(__file__).parent / \"flu_demo_input_files\"\n\n# Get filepaths for configuration, fixed parameter values, and\n#   initial values of state variables\nconfig_filepath = base_path / \"config.json\"\nfixed_params_filepath = base_path / \"fixed_params.json\"\nstate_vars_init_vals_filepath = base_path / \"state_variables_init_vals.json\"\n\n# Create a constructor using these filepaths\nflu_demo_constructor = \\\n    FluModelConstructor(config_filepath,\n                        fixed_params_filepath,\n                        state_vars_init_vals_filepath)\n\n# Create TransmissionModel instance from the constructor,\n#   using a random number generator with starting seed 888888\n#   to generate random variables\nflu_demo_model = flu_demo_constructor.create_transmission_model(888888)\n\n# Simulate 300 days\nflu_demo_model.simulate_until_time_period(300)\n\n# Plot\ncreate_basic_compartment_history_plot(flu_demo_model,\n                                      \"flu_demo_model.png\")\n</code></pre> <p></p> <p>The following code snippets and outputs below replicate the experience of working in a Python interactive console.</p> <p>After simulating 300 days, the <code>current_simulation_day</code> counter indeed is 300, and the attribute <code>current_real_date</code> gives us the corresponding real-world date associated with the simulation day counter.</p> <pre><code>flu_demo_model.current_simulation_day\n# 300\n\nflu_demo_model.current_real_date\n# datetime.date(2023, 6, 4)\n</code></pre> <p>Note that subsequent <code>simulate_until_time_period</code> calls will start from where the simulation last ended, and its argument <code>last_simulation_day</code> must be greater than the model's <code>current_simulation_day</code>. For example, after running <code>flu_demo_model.simulate_until_time_period(300)</code>, a command like <code>flu_demo_model.simulate_until_time_period(100)</code> is invalid (we cannot simulate backwards in time), but <code>flu_demo_model.simulate_until_timeperiod(305)</code> starts from day 300 and continues.</p> <p><code>TransmissionModel</code> instances have a <code>StateVariableManager</code> that manages and holds StateVariables (EpiCompartments, EpiMetrics, DynamicVals, and Schedules). Using the command below, we can access the state of the simulation after we simulated the model for 300 days. </p> <pre><code>flu_demo_model.sim_state\n# FluSimState(S=array([[306539.],\n#       [261363.]]), E=array([[31501.],\n#       [36027.]]), I=array([[105991.],\n#       [114542.]]), H=array([[ 98354.],\n#       [104663.]]), R=array([[175885.],\n#       [186626.]]), D=array([[281730.],\n#       [296779.]]), population_immunity_hosp=array([[0.11555325],\n#       [0.12078151]]), population_immunity_inf=array([[0.11555325],\n#       [0.12078151]]), absolute_humidity=12.31748, \n#       flu_contact_matrix=array([[[[2.], [0.5]]], [[[1.95], [1.4]]]]))\n</code></pre> <p>We can also use our model's built-in dictionary to look up simulation objects (any StateVariable, as well as any TransitionVariable and TransitionVariableGroup) by name. Here, <code>S</code> is an <code>EpiCompartment</code> instance, and we can see its current value at the current day of the simulation. </p> <pre><code>flu_demo_model.lookup_by_name[\"S\"]\n# &lt;base_components.EpiCompartment object at 0x174a79750&gt;\n\nflu_demo_model.lookup_by_name[\"S\"].current_val\n# array([[306539.],\n#        [261363.]])\n</code></pre> <p>We can also access a StateVariable's history with the attribute <code>history_vals_list</code>. For example, <code>flu_demo_model.lookup_by_name[\"S\"].history_vals_list</code> gives a list of all the previous current values of the \"Susceptible\" compartment. The \\(i\\)th element in the list holds the compartment's value at the end of simulation day \\(i\\). </p> <p>Next, we look at the current value (most recent realization) of the TransitionVariable <code>new_dead.</code> We also look at its <code>current_rate</code> attribute, which is the rate that generated the most recent realization. </p> <pre><code>flu_demo_model.lookup_by_name[\"new_dead\"].current_val\n# array([[406.],\n#        [435.]])\n\nflu_demo_model.lookup_by_name[\"new_dead\"].current_rate\n# array([[0.00823744],\n#        [0.00820603]])\n</code></pre> <p>We can reset the simulation to restart the simulation or clear the simulation's state and history to run a new replication on the same model, with the same initial conditions. Important note: resetting the simulation does NOT reset the random number generator -- random numbers will continue where the generator last left off. <pre><code>flu_demo_model.reset_simulation()\n</code></pre></p> <p>Notice that the current simulation day has returned to 0 and the simulation state has returned to its initial state. Each StateVariable's history has also been cleared. <pre><code>flu_demo_model.current_simulation_day\n# 0\n\nflu_demo_model.sim_state\n# FluSimState(S=array([[980000.],\n#       [980000.]]), E=array([[10000.],\n#       [10000.]]), I=array([[10000.],\n#       [10000.]]), H=array([[0.],\n#       [0.]]), R=array([[0.],\n#       [0.]]), D=array([[0.],\n#       [0.]]), population_immunity_hosp=array([[0.5],\n#       [0.5]]), population_immunity_inf=array([[0.5],\n#       [0.5]]), absolute_humidity=None, flu_contact_matrix=None)\n\nflu_demo_model.lookup_by_name[\"S\"].history_vals_list\n# []\n</code></pre></p> <p>To reset the random number generator, we must use the <code>modify_random_seed</code> method -- and pass the initial random seed. This resets the numpy RNG object to a state given by this seed. We can also use the <code>modify_random_seed</code> method to handle random number generation more broadly, and ensure that each simulation replication uses independent random numbers. To handle random number generation responsibly, refer to these two links here and here.</p> <p>Suppose that we want to modify configuration values, values of fixed parameters, or initial values. We can modify these values on our model constructor, and then create a new model instance. For example, below we change the transition type to \"binomial_deterministic\" and the beta baseline value to be \\(0\\). By changing <code>beta_baseline</code> to \\(0\\), no transmission occurs, and the plot verifies this. </p> <pre><code>flu_demo_constructor.config.transition_type = \"binomial_deterministic\"\nflu_demo_constructor.fixed_params.beta_baseline = 0\n\nflu_demo_model_beta_baseline_zero = \\\n    flu_demo_constructor.create_transmission_model(999999)\n\ncreate_basic_compartment_history_plot(flu_demo_model_beta_baseline_zero,\n                                      \"flu_demo_model_beta_baseline_zero.png\")\n</code></pre> <p></p>"},{"location":"python_resources/","title":"Python Resources for Modelers","text":"<p>Written by LP, updated 02/19/2025 (work in progress) </p> <p>Here we provide a list of fundamental concepts to know to responsibly create, collaborate on, and interact with responsible and reproducible Python code. We have outlined this somewhat like a syllabus for self-directed learning, with links to resources to get started. The reader should make sure they understand all key concepts in the checklist, and read more otherwise. </p> <p>Note: we particularly like Real Python, which has many free and thorough tutorials on various Python subjects!</p>"},{"location":"python_resources/#coding-correctly","title":"Coding correctly","text":"<p>Clean code matters for academic research with high standards.</p> <p>Recommended textbooks (PDF links are unaffiliated with epi-ENGAGE):</p> <ul> <li>***MUST READ: \"The Art of Readable Code\" by Boswell &amp; Foucher</li> <li>\"A Philosophy of Software Design\" by Ousterhout</li> <li>\"Refactoring: Improving the Design of Existing Code\" by Fowler &amp; Beck</li> <li>\"Clean Code: A Handbook of Agile Software Craftsmanship\" by Martin</li> </ul> <p>Key concepts</p> <ul> <li>\"The Fundamental Theorem of Readability: Code should be written to minimize the time it would take for someone else to understand it.\" (Boswell &amp; Foucher)</li> <li>Function and variable names should be specific and precise -- ChatGPT is great at helping brainstorm names!</li> <li>DOT -- DO ONE THING -- \"Functions should do one thing. They should do it well. They should do it only.\" And \"functions should do something, or answer something, but not both.\" (Martin) -- nice articles here and here.</li> <li>DRY -- DON'T REPEAT YOURSELF (Hunt &amp; Thomas) -- example resources here and here.</li> <li>Tactical instead of strategic programming leads to technical debt -- \"Complexity comes from an accumulation of dependencies and obscurities. As complexity increases, it leads to change amplification, a high cognitive load, and unknown unknowns.\" (Ousterhout) </li> </ul> <p>Advanced concepts</p> <ul> <li>For classes -- \"Single Responsibility Principle\" (Martin) -- example resources here and here.</li> </ul>"},{"location":"python_resources/#test-test-test","title":"Test, test, test!","text":"<p>Key concepts</p> <ul> <li>Any time a user changes code or adds code, they should add new tests and also make sure that all the old tests still pass. </li> <li>Unit testing is critical to ensuring code behaves as intended and ensuring that changes/updates do not add new bugs or break existing functionality. If we haven't tested it, we shouldn't trust it. We should prove our code works! Check out this great MIT lecture on testing here.</li> <li>Testing should have good coverage and handle different edge cases -- bugs often occur \"on the boundaries\" of inputs. </li> <li>The CLT Base Model code uses <code>pytest</code> for easy management of unit testing -- here's an in-depth tutorial. </li> <li>We must also implement higher-level tests such as integration tests and acceptance tests, to make sure the whole shebang works.</li> <li>One crucial reason to write modular code (and functions that do one thing only) is to allow for testing of specific modules and functions (Boswell &amp; Foucher). If the code is not easy to test, we cannot easily guarantee its quality.</li> </ul> <p>Bonus articles on testing</p> <ul> <li>Check out these nice articles on unit testing here and here.  And here is a nice overview of TDD -- Test-Driven Development (Martin).</li> </ul>"},{"location":"python_resources/#python-modules-and-imports-ides-and-running-python-scripts","title":"Python modules and imports, IDEs, and running Python scripts","text":"<p>Key concepts</p> <ul> <li>Jupyter notebooks are for exploration, NOT for collaborative software development. Nature wrote a blog post warning about Jupyter notebooks: \"computational notebooks can also be confusing and foster poor coding practices. And they are difficult to share, collaborate on and reproduce. A 2019 study found that just 24% of 863,878 publicly available Jupyter notebooks on GitHub could be successfully re-executed, and only 4% produced the same results\" -- blog post link here and conference paper here. </li> <li>As programs grow in size, they should be split into smaller files and organized -- modules and importing are key here. Here's a quick tutorial and a more in-depth tutorial.</li> <li>Interactive Developer Environments (IDEs) are ideal for working with Python modules. We recommend Pycharm -- the community edition here is free to download.</li> <li>Python can be run in many different ways -- users should understand the difference between running a script in an IDE Console and from the command line -- here's a guide.</li> <li>We recommend pip or conda for Python package management. There can sometimes be some issues with mixing pip and conda, so it may be helpful to consistently only use one or the other. </li> <li>Users should be comfortable reading API documentation such as the CLT Base Model Code's  references or numpy's references -- there is no need to try to memorize syntax -- and similarly there should not be an over-reliance on tutorials. Users should be comfortable parsing the technical details of classes and methods, customizing default arguments, and playtesting parts of the package for themselves. </li> </ul> <p>More reading</p> <ul> <li>Jupyter notebooks have issues with hidden states -- read more here.</li> </ul>"},{"location":"python_resources/#documentation-and-version-control","title":"Documentation and version control","text":"<p>Key concepts</p> <ul> <li> <p>[HIGH PRIORITY] The CLT Base Model Code is hosted on github -- users should be familiar with git. We strongly recommend this nice guide on github collaboration here.</p> <ul> <li>Specifically, users should know the following concepts in git: cloning a repo, local and remote repos, committing and pushing, pull requests, pulling, merging.</li> </ul> </li> <li> <p>Collaborators should never push to main -- they should create a pull request (after adding tests and checking all tests) to request the main branch incorporate any new changes.</p> </li> <li> <p>Users should STOP the common practice of saving versions like <code>simulation_v3.2_final_final_01302025</code> -- this is horrible for many reasons. Users should instead use git version control and intentional git commit messages to keep track of their code versions.</p> </li> <li> <p>Users should add <code>.txt</code> and <code>.md</code> files documenting any mathematical parameters to their repo and make this a part of their version control setup. This way, users can keep track of WHY and WHEN certain parameter values were changed. </p> </li> <li> <p>The CLT Base Model Code documentation on this website is generated using <code>mkdocs</code>, and automatically populates code references hosted on this website from the code. The code docstrings must follow a specific format, outlined here.</p> </li> <li>Users should always write proper function signatures in their code -- specifying data input and return types is very important. This article here is a starting point to learn more.  </li> </ul>"},{"location":"python_resources/#other-important-points","title":"Other important points...","text":"<p>Key concepts</p> <ul> <li>[HIGH PRIORITY] The CLT Base Model code uses object-oriented programming (OOP), which may be new to some modelers. The coding structure is similar to StarSim and TACC's Pandemic Simulator -- it is a tried and tested strategy. We strongly recommend this tutorial for those new to OOP.<ul> <li>Specifically, users should know the following concepts: inheritance, attributes, abstract base classes, abstract methods.</li> </ul> </li> <li>[HIGH PRIORITY] We need to be responsible with random number generation. Please, stop using <code>np.random.seed</code>! Use generators instead! Here is a superb article outlining some dangers with misusing <code>numpy</code> random number generation, with links to the relevant numpy documentation. </li> <li>For-loops are horrible for efficiency and vectorized operations are better. Often, mathematical computations should be written in matrix multiplication form instead of for-loops. Here is a tutorial on the essentials of <code>numpy</code> and vectorized operations on <code>numpy</code> arrays.</li> <li>The <code>dataclasses</code> module makes storing data very easy -- here's a quick tutorial.</li> <li>Users should understand interfaces and duck typing in Python -- here's a short overview.</li> <li>Parallel processing and cluster job submission (elaboration and resources coming soon...)</li> </ul>"}]}