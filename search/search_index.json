{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"City-level Transmission (CLT) Base Model","text":"<p>The CLT base model is a mathematical framework and modular Python codebase for scalable compartmental models of respiratory virus transmission in a city. This model is written by the Meyers Lab and epiENGAGE center.</p> <p>Please visit this website for mathematical formulations, code documentation including tutorials, and code API references. </p> <p>The mathematical framework is inspired by the immunoSEIRS model of the Meyers Lab (see Bi and Bandekar et al. 2023, Bi et al. 2022 and Bouchnita et al. 2021 for some related recent publications).</p> <p>Documentation is created by Linda Pei (\"LP\"). Base model code is created by LP in collaboration with Shuotao \"Sonny\" Diao, Remy Pasco, and Emily Javan, and with supervision from Dave Morton and Lauren Meyers. Special thanks to Cary Murray for generous guidance on software engineering design. Special credit to Sonny for his ideas about updating compartments analogously to pushing flow on a graph and creating simulation logic that works for arbitrarily many compartments and transition variables. </p>"},{"location":"#setup","title":"Setup","text":"<p>The CLT base model code is written in Python 3.11.0.</p> <p>To download the latest code release, run the following in Terminal: <pre><code>git clone https://github.com/LP-relaxation/CLT_BaseModel.git\n</code></pre></p> <p>Packages used <pre><code>numpy==1.24.3\npandas==1.5.3\npytest==8.3.3\n</code></pre></p>"},{"location":"#codebase-overview","title":"Codebase Overview","text":"<p>Below is an overview of the files in the CLT base model code.</p> <pre><code>base_components.py      # Base classes used to create a compartmental model.\n\nflu_components.py       # A specific S-E-I-H-R-D model for influenza.\n\nflu_tests.py            # Suite of pytest tests for flu_components.py.\n\nflu_demo.py             # Demo implementation of flu_components.py\n                          flu model for tutorial and testing purposes.\n\nflu_demo_input_files    # Collection of .json and .csv files used as \n                          input values for flu_demo.py. These values are\n                          \"toy\" predefined values for demo purposes only. \n                          Realistic applications will use estimation \n                          and calibration from real-world data.\n</code></pre> <p>To execute the simple flu demo model, run <pre><code>python flu_demo.py\n</code></pre></p> <p>To execute the flu model tests, run <pre><code>pytest -v flu_tests.py\n</code></pre></p>"},{"location":"base_components_reference/","title":"Base Components Code API Reference","text":"<p>Docstrings and references for <code>base_components.py</code>.</p>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Compartment","title":"<code>Compartment</code>","text":"<p>               Bases: <code>StateVariable</code></p> <p>Class for epidemiological compartments (e.g. Susceptible,     Exposed, Infected, etc...).</p> <p>Inherits attributes from StateVariable.</p> <p>Attributes:</p> Name Type Description <code>current_val</code> <code>ndarray</code> <p>same size as init_val, holds current value of Compartment for age-risk groups.</p> <code>current_inflow</code> <code>ndarray</code> <p>same size as current_val, used to sum up all transition variable realizations incoming to this compartment for age-risk groups.</p> <code>current_outflow</code> <code>ndarray</code> <p>same size of current_val, used to sum up all transition variable realizations outgoing from this compartment for age-risk groups.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of current_val, holds history of compartment states for age-risk groups -- element t corresponds to previous current_val value at end of simulation day t.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class Compartment(StateVariable):\n    \"\"\"\n    Class for epidemiological compartments (e.g. Susceptible,\n        Exposed, Infected, etc...).\n\n    Inherits attributes from StateVariable.\n\n    Attributes:\n        current_val (np.ndarray):\n            same size as init_val, holds current value of Compartment\n            for age-risk groups.\n        current_inflow (np.ndarray):\n            same size as current_val, used to sum up all\n            transition variable realizations incoming to this compartment\n            for age-risk groups.\n        current_outflow (np.ndarray):\n            same size of current_val, used to sum up all\n            transition variable realizations outgoing from this compartment\n            for age-risk groups.\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of current_val, holds\n            history of compartment states for age-risk groups --\n            element t corresponds to previous current_val value at\n            end of simulation day t.\n    \"\"\"\n\n    def __init__(self,\n                 init_val):\n        super().__init__(init_val)\n\n        self.current_inflow = np.zeros(np.shape(init_val))\n        self.current_outflow = np.zeros(np.shape(init_val))\n\n        self.history_vals_list = []\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Updates current_val attribute in-place by adding\n            current_inflow (sum of all incoming transition variables'\n            realizations) and subtracting current outflow (sum of all\n            outgoing transition variables' realizations)\n        \"\"\"\n        self.current_val += self.current_inflow - self.current_outflow\n\n    def reset_inflow(self) -&gt; None:\n        \"\"\"\n        Resets current_inflow attribute to np.ndarray of zeros.\n        \"\"\"\n        self.current_inflow = np.zeros(np.shape(self.current_inflow))\n\n    def reset_outflow(self) -&gt; None:\n        \"\"\"\n        Resets current_outflow attribute to np.ndarray of zeros.\n        \"\"\"\n        self.current_outflow = np.zeros(np.shape(self.current_outflow))\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending current_val attribute\n            to history_vals_list in place\n\n        NOTE:\n            deep copying is CRUCIAL because current_val is a mutable\n            np.ndarray -- without deep copying, history_vals_list would\n            have the same value for all elements\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def clear_history(self) -&gt; None:\n        \"\"\"\n        Resets history_vals_list attribute to empty list.\n        \"\"\"\n\n        self.history_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Compartment.clear_history","title":"<code>clear_history()</code>","text":"<p>Resets history_vals_list attribute to empty list.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def clear_history(self) -&gt; None:\n    \"\"\"\n    Resets history_vals_list attribute to empty list.\n    \"\"\"\n\n    self.history_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Compartment.reset_inflow","title":"<code>reset_inflow()</code>","text":"<p>Resets current_inflow attribute to np.ndarray of zeros.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset_inflow(self) -&gt; None:\n    \"\"\"\n    Resets current_inflow attribute to np.ndarray of zeros.\n    \"\"\"\n    self.current_inflow = np.zeros(np.shape(self.current_inflow))\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Compartment.reset_outflow","title":"<code>reset_outflow()</code>","text":"<p>Resets current_outflow attribute to np.ndarray of zeros.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset_outflow(self) -&gt; None:\n    \"\"\"\n    Resets current_outflow attribute to np.ndarray of zeros.\n    \"\"\"\n    self.current_outflow = np.zeros(np.shape(self.current_outflow))\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Compartment.save_history","title":"<code>save_history()</code>","text":"<p>Saves current value to history by appending current_val attribute     to history_vals_list in place</p> NOTE <p>deep copying is CRUCIAL because current_val is a mutable np.ndarray -- without deep copying, history_vals_list would have the same value for all elements</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending current_val attribute\n        to history_vals_list in place\n\n    NOTE:\n        deep copying is CRUCIAL because current_val is a mutable\n        np.ndarray -- without deep copying, history_vals_list would\n        have the same value for all elements\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Compartment.update_current_val","title":"<code>update_current_val()</code>","text":"<p>Updates current_val attribute in-place by adding     current_inflow (sum of all incoming transition variables'     realizations) and subtracting current outflow (sum of all     outgoing transition variables' realizations)</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Updates current_val attribute in-place by adding\n        current_inflow (sum of all incoming transition variables'\n        realizations) and subtracting current outflow (sum of all\n        outgoing transition variables' realizations)\n    \"\"\"\n    self.current_val += self.current_inflow - self.current_outflow\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Config","title":"<code>Config</code>","text":"<p>Stores simulation configuration values.</p> <p>Attributes:</p> Name Type Description <code>timesteps_per_day</code> <code>int</code> <p>number of discretized timesteps within a simulation day -- more timesteps_per_day mean smaller discretization time intervals, which may cause the model to run slower.</p> <code>transition_type</code> <code>str</code> <p>valid value must be from TransitionTypes, specifying the probability distribution of transitions between compartments.</p> <code>start_real_date</code> <code>date</code> <p>actual date that aligns with the beginning of the simulation.</p> <code>save_daily_history</code> <code>bool</code> <p>True if each StateVariable saves state to history after each simulation day -- set to False if want speedier performance.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"\n    Stores simulation configuration values.\n\n    Attributes:\n        timesteps_per_day (int):\n            number of discretized timesteps within a simulation\n            day -- more timesteps_per_day mean smaller discretization\n            time intervals, which may cause the model to run slower.\n        transition_type (str):\n            valid value must be from TransitionTypes,\n            specifying the probability distribution of transitions between\n            compartments.\n        start_real_date (datetime.date):\n            actual date that aligns with the beginning of the simulation.\n        save_daily_history (bool):\n            True if each StateVariable saves state to history after each simulation\n            day -- set to False if want speedier performance.\n    \"\"\"\n\n    timesteps_per_day: int = 7\n    transition_type: str = TransitionTypes.BINOMIAL\n    start_real_date: datetime.time = datetime.datetime.strptime(\"2024-10-31\",\n                                                                \"%Y-%m-%d\").date()\n    save_daily_history: bool = True\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.DataClassProtocol","title":"<code>DataClassProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>class DataClassProtocol(Protocol):\n    __dataclass_fields__: dict\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.DynamicVal","title":"<code>DynamicVal</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that dynamically adjust their values based the current values of other StateVariable instances.</p> <p>This class should model social distancing (and more broadly, staged-alert policies). For example, if we consider a case where transmission rates decrease when number infected increase above a certain level, we can create a subclass of DynamicVal that models a coefficient that modifies transmission rates, depending on the epi compartments corresponding to infected people.</p> <p>Inherits attributes from StateVariable.</p> <p>Attributes:</p> Name Type Description <code>history_vals_list</code> <code>list[ndarrays]</code> <p>each element is the same size of current_val, holds history of transition variable realizations for age-risk groups -- element t corresponds to previous current_val value at end of simulation day t.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class DynamicVal(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that dynamically adjust\n    their values based the current values of other StateVariable instances.\n\n    This class should model social distancing (and more broadly,\n    staged-alert policies). For example, if we consider a\n    case where transmission rates decrease when number infected\n    increase above a certain level, we can create a subclass of\n    DynamicVal that models a coefficient that modifies transmission\n    rates, depending on the epi compartments corresponding to\n    infected people.\n\n    Inherits attributes from StateVariable.\n\n    Attributes:\n        history_vals_list (list[np.ndarrays]):\n            each element is the same size of current_val, holds\n            history of transition variable realizations for age-risk\n            groups -- element t corresponds to previous current_val value\n            at end of simulation day t.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[Union[np.ndarray, float]] = None,\n                 is_enabled: Optional[bool] = False):\n        \"\"\"\n\n        Args:\n            init_val (Optional[Union[np.ndarray, float]]):\n                starting value(s) at the beginning of the simulation\n            is_enabled (Optional[bool]):\n                if False, this dynamic value does not get updated\n                during the simulation and defaults to its init_val.\n                This is designed to allow easy toggling of\n                simulations with or without staged alert policies\n                and other interventions.\n        \"\"\"\n\n        super().__init__(init_val)\n        self.is_enabled = is_enabled\n        self.history_vals_list = []\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending current_val attribute\n            to history_vals_list in place\n\n        Deep copying is CRUCIAL because current_val is a mutable\n            np.ndarray -- without deep copying, history_vals_list would\n            have the same value for all elements\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def clear_history(self) -&gt; None:\n        self.history_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.DynamicVal.__init__","title":"<code>__init__(init_val=None, is_enabled=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[Union[ndarray, float]]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>is_enabled</code> <code>Optional[bool]</code> <p>if False, this dynamic value does not get updated during the simulation and defaults to its init_val. This is designed to allow easy toggling of simulations with or without staged alert policies and other interventions.</p> <code>False</code> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[Union[np.ndarray, float]] = None,\n             is_enabled: Optional[bool] = False):\n    \"\"\"\n\n    Args:\n        init_val (Optional[Union[np.ndarray, float]]):\n            starting value(s) at the beginning of the simulation\n        is_enabled (Optional[bool]):\n            if False, this dynamic value does not get updated\n            during the simulation and defaults to its init_val.\n            This is designed to allow easy toggling of\n            simulations with or without staged alert policies\n            and other interventions.\n    \"\"\"\n\n    super().__init__(init_val)\n    self.is_enabled = is_enabled\n    self.history_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.DynamicVal.save_history","title":"<code>save_history()</code>","text":"<p>Saves current value to history by appending current_val attribute     to history_vals_list in place</p> <p>Deep copying is CRUCIAL because current_val is a mutable     np.ndarray -- without deep copying, history_vals_list would     have the same value for all elements</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending current_val attribute\n        to history_vals_list in place\n\n    Deep copying is CRUCIAL because current_val is a mutable\n        np.ndarray -- without deep copying, history_vals_list would\n        have the same value for all elements\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.EpiMetric","title":"<code>EpiMetric</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for epi metrics in epidemiological model.</p> <p>This is intended for variables that are aggregate deterministic functions of the simulation state (including epi compartment values, other parameters, and time.)</p> <p>For example, population-level immunity variables should be modeled as a EpiMetric subclass, with a concrete implementation of the abstract method get_change_in_current_val.</p> <p>Inherits attributes from StateVariable.</p> <p>Attributes:</p> Name Type Description <code>current_val</code> <code>ndarray</code> <p>same size as init_val, holds current value of State Variable for age-risk groups.</p> <code>change_in_current_val</code> <p>(np.ndarray): initialized to None, but during simulation holds change in current value of EpiMetric for age-risk groups (size A x L, where A is number of risk groups and L is number of age groups).</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of current_val, holds history of transition variable realizations for age-risk groups -- element t corresponds to previous current_val value at end of simulation day t.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class EpiMetric(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for epi metrics in epidemiological model.\n\n    This is intended for variables that are aggregate deterministic functions of\n    the simulation state (including epi compartment values, other parameters,\n    and time.)\n\n    For example, population-level immunity variables should be\n    modeled as a EpiMetric subclass, with a concrete\n    implementation of the abstract method get_change_in_current_val.\n\n    Inherits attributes from StateVariable.\n\n    Attributes:\n        current_val (np.ndarray):\n            same size as init_val, holds current value of State Variable\n            for age-risk groups.\n        change_in_current_val : (np.ndarray):\n            initialized to None, but during simulation holds change in\n            current value of EpiMetric for age-risk groups\n            (size A x L, where A is number of risk groups and L is number\n            of age groups).\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of current_val, holds\n            history of transition variable realizations for age-risk\n            groups -- element t corresponds to previous current_val value\n            at end of simulation day t.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val):\n        \"\"\"\n        Args:\n            init_val (np.ndarray):\n                2D array that contains nonnegative floats,\n                corresponding to initial value of dynamic val,\n                where i,jth entry corresponds to age group i and\n                risk group j.\n        \"\"\"\n\n        super().__init__(init_val)\n\n        self.change_in_current_val = None\n        self.history_vals_list = []\n\n    @abstractmethod\n    def get_change_in_current_val(self,\n                                  sim_state: SimState,\n                                  fixed_params: FixedParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns change in current value of dynamic val,\n        based on current state of the simulation and epidemiological parameters.\n        ***NOTE: OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n        Output should be a numpy array of size A x L, where A\n        is number of age groups and L is number of risk groups.\n\n        Args:\n            sim_state (SimState):\n                holds simulation state (current values of StateVariable\n                instances).\n            fixed_params (FixedParams):\n                holds values of epidemiological parameters.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size A x L, where A is number of age groups and\n                L is number of risk groups.\n        \"\"\"\n        pass\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Adds change_in_current_val attribute to current_val attribute\n            in-place.\n        \"\"\"\n\n        self.current_val += self.change_in_current_val\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending current_val attribute\n            to history_vals_list in place\n\n        Deep copying is CRUCIAL because current_val is a mutable\n            np.ndarray -- without deep copying, history_vals_list would\n            have the same value for all elements\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def clear_history(self) -&gt; None:\n        \"\"\"\n        Resets history_vals_list attribute to empty list.\n        \"\"\"\n\n        self.history_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.EpiMetric.__init__","title":"<code>__init__(init_val)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>ndarray</code> <p>2D array that contains nonnegative floats, corresponding to initial value of dynamic val, where i,jth entry corresponds to age group i and risk group j.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             init_val):\n    \"\"\"\n    Args:\n        init_val (np.ndarray):\n            2D array that contains nonnegative floats,\n            corresponding to initial value of dynamic val,\n            where i,jth entry corresponds to age group i and\n            risk group j.\n    \"\"\"\n\n    super().__init__(init_val)\n\n    self.change_in_current_val = None\n    self.history_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.EpiMetric.clear_history","title":"<code>clear_history()</code>","text":"<p>Resets history_vals_list attribute to empty list.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def clear_history(self) -&gt; None:\n    \"\"\"\n    Resets history_vals_list attribute to empty list.\n    \"\"\"\n\n    self.history_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.EpiMetric.get_change_in_current_val","title":"<code>get_change_in_current_val(sim_state, fixed_params, num_timesteps)</code>","text":"<p>Computes and returns change in current value of dynamic val, based on current state of the simulation and epidemiological parameters. ***NOTE: OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS. Output should be a numpy array of size A x L, where A is number of age groups and L is number of risk groups.</p> <p>Parameters:</p> Name Type Description Default <code>sim_state</code> <code>SimState</code> <p>holds simulation state (current values of StateVariable instances).</p> required <code>fixed_params</code> <code>FixedParams</code> <p>holds values of epidemiological parameters.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size A x L, where A is number of age groups and L is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@abstractmethod\ndef get_change_in_current_val(self,\n                              sim_state: SimState,\n                              fixed_params: FixedParams,\n                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns change in current value of dynamic val,\n    based on current state of the simulation and epidemiological parameters.\n    ***NOTE: OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n    Output should be a numpy array of size A x L, where A\n    is number of age groups and L is number of risk groups.\n\n    Args:\n        sim_state (SimState):\n            holds simulation state (current values of StateVariable\n            instances).\n        fixed_params (FixedParams):\n            holds values of epidemiological parameters.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size A x L, where A is number of age groups and\n            L is number of risk groups.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.EpiMetric.save_history","title":"<code>save_history()</code>","text":"<p>Saves current value to history by appending current_val attribute     to history_vals_list in place</p> <p>Deep copying is CRUCIAL because current_val is a mutable     np.ndarray -- without deep copying, history_vals_list would     have the same value for all elements</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending current_val attribute\n        to history_vals_list in place\n\n    Deep copying is CRUCIAL because current_val is a mutable\n        np.ndarray -- without deep copying, history_vals_list would\n        have the same value for all elements\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.EpiMetric.update_current_val","title":"<code>update_current_val()</code>","text":"<p>Adds change_in_current_val attribute to current_val attribute     in-place.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Adds change_in_current_val attribute to current_val attribute\n        in-place.\n    \"\"\"\n\n    self.current_val += self.change_in_current_val\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.FixedParams","title":"<code>FixedParams</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Stores epidemiological parameters.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@dataclass\nclass FixedParams(ABC):\n    \"\"\"\n    Stores epidemiological parameters.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.JointTransitionTypes","title":"<code>JointTransitionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class JointTransitionTypes(str, Enum):\n    MULTINOMIAL = \"multinomial\"\n    MULTINOMIAL_DETERMINISTIC = \"multinomial_deterministic\"\n    MULTINOMIAL_TAYLOR_APPROX = \"multinomial_taylor_approx\"\n    MULTINOMIAL_TAYLOR_APPROX_DETERMINISTIC = \"multinomial_taylor_approx_deterministic\"\n    POISSON = \"poisson\"\n    POISSON_DETERMINISTIC = \"poisson_deterministic\"\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Schedule","title":"<code>Schedule</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that are functions of real-world dates -- for example, contact matrices (which depend on the day of the week and whether the current day is a holiday), historical vaccination data, and seasonality.</p> <p>Inherits attributes from StateVariable.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@dataclass\nclass Schedule(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that are functions of real-world\n    dates -- for example, contact matrices (which depend on the day of\n    the week and whether the current day is a holiday), historical\n    vaccination data, and seasonality.\n\n    Inherits attributes from StateVariable.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[Union[np.ndarray, float]] = None,\n                 timeseries_df: Optional[dict] = None):\n        \"\"\"\n        Args:\n            init_val (Optional[Union[np.ndarray, float]]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                has a \"date\" column with strings in format \"YYYY-MM-DD\"\n                of consecutive calendar days, and other columns\n                corresponding to values on those days\n        \"\"\"\n\n        super().__init__(init_val)\n        self.timeseries_df = timeseries_df\n\n    @abstractmethod\n    def update_current_val(self, current_date: datetime.date) -&gt; None:\n        \"\"\"\n        Subclasses must provide a concrete implementation of\n        updating self.current_val in-place.\n\n        Args:\n            current_date (date):\n                real-world date corresponding to\n                model's current simulation day.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Schedule.__init__","title":"<code>__init__(init_val=None, timeseries_df=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>init_val</code> <code>Optional[Union[ndarray, float]]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>has a \"date\" column with strings in format \"YYYY-MM-DD\" of consecutive calendar days, and other columns corresponding to values on those days</p> <code>None</code> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             init_val: Optional[Union[np.ndarray, float]] = None,\n             timeseries_df: Optional[dict] = None):\n    \"\"\"\n    Args:\n        init_val (Optional[Union[np.ndarray, float]]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            has a \"date\" column with strings in format \"YYYY-MM-DD\"\n            of consecutive calendar days, and other columns\n            corresponding to values on those days\n    \"\"\"\n\n    super().__init__(init_val)\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.Schedule.update_current_val","title":"<code>update_current_val(current_date)</code>","text":"<p>Subclasses must provide a concrete implementation of updating self.current_val in-place.</p> <p>Parameters:</p> Name Type Description Default <code>current_date</code> <code>date</code> <p>real-world date corresponding to model's current simulation day.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self, current_date: datetime.date) -&gt; None:\n    \"\"\"\n    Subclasses must provide a concrete implementation of\n    updating self.current_val in-place.\n\n    Args:\n        current_date (date):\n            real-world date corresponding to\n            model's current simulation day.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SimState","title":"<code>SimState</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Holds current values of simulation state.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@dataclass\nclass SimState(ABC):\n    \"\"\"\n    Holds current values of simulation state.\n    \"\"\"\n\n    compartments: Optional[sc.objdict] = None\n    epi_metrics: Optional[sc.objdict] = None\n    schedules: Optional[sc.objdict] = None\n    dynamic_vals: Optional[sc.objdict] = None\n\n    def update_values(self, lookup_dict):\n        for name, item in lookup_dict.items():\n            setattr(self, name, item.current_val)\n\n    def update_compartments(self):\n        self.update_values(self.compartments)\n\n    def update_epi_metrics(self):\n        self.update_values(self.epi_metrics)\n\n    def update_schedules(self):\n        self.update_values(self.schedules)\n\n    def update_dynamic_vals(self):\n        self.update_values(self.dynamic_vals)\n\n    def update_all(self) -&gt; None:\n        self.update_compartments()\n        self.update_epi_metrics()\n        self.update_schedules()\n        self.update_dynamic_vals()\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.StateVariable","title":"<code>StateVariable</code>","text":"<p>Parent class of Compartment, EpiMetric, DynamicVal, and Schedule classes. All subclasses have the common attributes \"init_val\" and \"current_val.\"</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class StateVariable:\n    \"\"\"\n    Parent class of Compartment, EpiMetric, DynamicVal, and Schedule\n    classes. All subclasses have the common attributes \"init_val\" and \"current_val.\"\n    \"\"\"\n\n    def __init__(self, init_val):\n        self.init_val = init_val\n        self.current_val = copy.deepcopy(init_val)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel","title":"<code>SubpopModel</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Contains and manages all necessary components for simulating a compartmental model, including compartments epi metrics, dynamic vals, a data container for the current simulation state, transition variables and transition variable groups, epidemiological parameters, simulation experiment configuration parameters, and a random number generator.</p> <p>All city-level models, regardless of disease type and compartment/transition structure, are instances of this class.</p> <p>When creating an instance, the order of elements does not matter within compartments, epi_metrics, dynamic_vals, transition_variables, and transition_variable_groups. The \"flow\" and \"physics\" information are stored on the objects.</p> <p>Attributes:</p> Name Type Description <code>compartments</code> <code>objdict</code> <p>objdict of all the model's Compartment instances.</p> <code>transition_variables</code> <code>objdict</code> <p>objdict of all the model's TransitionVariable instances.</p> <code>transition_variable_groups</code> <code>objdict</code> <p>objdict of all the model's TransitionVariableGroup instances.</p> <code>epi_metrics</code> <code>objdict</code> <p>objdict of all the model's EpiMetric instances.</p> <code>dynamic_vals</code> <code>objdict</code> <p>objdict of all the model's DynamicVal instances.</p> <code>schedules</code> <code>objdict</code> <p>objdict of all the model's Schedule instances.</p> <code>fixed_params</code> <code>FixedParams</code> <p>data container for the model's epidemiological parameters, such as the \"Greek letters\" characterizing sojourn times in compartments.</p> <code>config</code> <code>Config</code> <p>data container for the model's simulation configuration values.</p> <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> <code>current_simulation_day</code> <code>int</code> <p>tracks current simulation day -- incremented by +1 when config.timesteps_per_day discretized timesteps have completed.</p> <code>current_real_date</code> <code>date</code> <p>tracks real-world date -- advanced by +1 day when config.timesteps_per_day discretized timesteps have completed.</p> <code>lookup_by_name</code> <code>dict</code> <p>keys are names of StateVariable, TransitionVariable, and TransitionVariableGroup instances associated with the model -- values are the actual object.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class SubpopModel(ABC):\n    \"\"\"\n    Contains and manages all necessary components for\n    simulating a compartmental model, including compartments\n    epi metrics, dynamic vals, a data container for the current simulation\n    state, transition variables and transition variable groups,\n    epidemiological parameters, simulation experiment configuration\n    parameters, and a random number generator.\n\n    All city-level models, regardless of disease type and\n    compartment/transition structure, are instances of this class.\n\n    When creating an instance, the order of elements does not matter\n    within compartments, epi_metrics, dynamic_vals,\n    transition_variables, and transition_variable_groups.\n    The \"flow\" and \"physics\" information are stored on the objects.\n\n    Attributes:\n        compartments (sc.objdict):\n            objdict of all the model's Compartment instances.\n        transition_variables (sc.objdict):\n            objdict of all the model's TransitionVariable instances.\n        transition_variable_groups (sc.objdict):\n            objdict of all the model's TransitionVariableGroup instances.\n        epi_metrics (sc.objdict):\n            objdict of all the model's EpiMetric instances.\n        dynamic_vals (sc.objdict):\n            objdict of all the model's DynamicVal instances.\n        schedules (sc.objdict):\n            objdict of all the model's Schedule instances.\n        fixed_params (FixedParams):\n            data container for the model's epidemiological parameters,\n            such as the \"Greek letters\" characterizing sojourn times\n            in compartments.\n        config (Config):\n            data container for the model's simulation configuration values.\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        current_simulation_day (int):\n            tracks current simulation day -- incremented by +1\n            when config.timesteps_per_day discretized timesteps\n            have completed.\n        current_real_date (datetime.date):\n            tracks real-world date -- advanced by +1 day when\n            config.timesteps_per_day discretized timesteps\n            have completed.\n        lookup_by_name (dict):\n            keys are names of StateVariable, TransitionVariable,\n            and TransitionVariableGroup instances associated\n            with the model -- values are the actual object.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 sim_state: SimState,\n                 fixed_params: FixedParams,\n                 config: Config,\n                 RNG: np.random.Generator,\n                 name: str = \"\"):\n\n        self.sim_state = copy.deepcopy(sim_state)\n        self.fixed_params = copy.deepcopy(fixed_params)\n        self.config = copy.deepcopy(config)\n\n        self.RNG = RNG\n\n        self.name = name\n\n        self.current_simulation_day = 0\n        self.start_real_date = self.get_start_real_date()\n        self.current_real_date = self.start_real_date\n\n        self.compartments = self.create_compartments()\n        self.transition_variables = self.create_transition_variables()\n        self.transition_variable_groups = self.create_transition_variable_groups()\n\n        # Some epi metrics depend on transition variables, so\n        #   set up epi metrics after transition variables\n        self.epi_metrics = self.create_epi_metrics()\n        self.dynamic_vals = self.create_dynamic_vals()\n        self.schedules = self.create_schedules()\n\n        # The model's sim_state also has access to the model's\n        #   compartments, epi_metrics, dynamic_vals, and schedules --\n        #   so that sim_state can easily retrieve each object's\n        #   current_val and store it\n        self.sim_state.compartments = self.compartments\n        self.sim_state.epi_metrics = self.epi_metrics\n        self.sim_state.dynamic_vals = self.dynamic_vals\n        self.sim_state.schedules = self.schedules\n\n    def get_start_real_date(self):\n        \"\"\"\n        Fetches start_real_date from config -- converts to\n            proper datetime.date format if originally given as\n            string.\n\n        Returns:\n            start_real_date (datetime.date):\n                real-world date that corresponds to start of\n                simulation.\n        \"\"\"\n\n        start_real_date = self.config.start_real_date\n\n        if not isinstance(start_real_date, datetime.date):\n            try:\n                start_real_date = \\\n                    datetime.datetime.strptime(start_real_date, \"%Y-%m-%d\").date()\n            except ValueError:\n                print(\"Error: The date format should be YYYY-MM-DD.\")\n\n        return start_real_date\n\n    @abstractmethod\n    def create_compartments(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_transition_variables(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_transition_variable_groups(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_epi_metrics(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_dynamic_vals(self) -&gt; sc.objdict:\n        pass\n\n    @abstractmethod\n    def create_schedules(self) -&gt; sc.objdict:\n        pass\n\n    def modify_random_seed(self, new_seed_number) -&gt; None:\n        \"\"\"\n        Modifies model's RNG attribute in-place to new generator\n        seeded at new_seed_number.\n\n        Args:\n            new_seed_number (int):\n                used to re-seed model's random number generator.\n        \"\"\"\n\n        self._bit_generator = np.random.MT19937(seed=new_seed_number)\n        self.RNG = np.random.Generator(self._bit_generator)\n\n    def simulate_until_time_period(self, last_simulation_day) -&gt; None:\n        \"\"\"\n        Advance simulation model time until last_simulation_day.\n\n        Advance time by iterating through simulation days,\n        which are simulated by iterating through discretized\n        timesteps.\n\n        Save daily simulation data as history on each Compartment\n        instance.\n\n        Args:\n            last_simulation_day (positive int):\n                stop simulation at last_simulation_day (i.e. exclusive,\n                simulate up to but not including last_simulation_day).\n        \"\"\"\n\n        if self.current_simulation_day &gt; last_simulation_day:\n            raise SubpopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                   f\"exceeds last simulation day ({last_simulation_day}).\")\n\n        save_daily_history = self.config.save_daily_history\n        timesteps_per_day = self.config.timesteps_per_day\n\n        # last_simulation_day is exclusive endpoint\n        while self.current_simulation_day &lt; last_simulation_day:\n\n            # Get current values of Schedule and DynamicVal instances\n            self.prepare_daily_state()\n\n            self.simulate_timesteps(timesteps_per_day)\n\n            if save_daily_history:\n                self.save_daily_history()\n\n            self.increment_simulation_day()\n\n    def simulate_timesteps(self,\n                           num_timesteps: int) -&gt; None:\n        \"\"\"\n        Subroutine for simulate_until_time_period.\n\n        Iterates through discretized timesteps to simulate next\n        simulation day. Granularity of discretization is given by\n        attribute config.timesteps_per_day.\n\n        Properly scales transition variable realizations and changes\n        in dynamic vals by specified timesteps per day.\n\n        Parameters:\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n        \"\"\"\n\n        for timestep in range(num_timesteps):\n            self.update_transition_rates()\n\n            self.sample_transitions()\n\n            self.update_epi_metrics()\n\n            self.update_compartments()\n\n            self.sim_state.update_epi_metrics()\n            self.sim_state.update_compartments()\n\n    def prepare_daily_state(self) -&gt; None:\n        \"\"\"\n        At beginning of each day, update current value of\n        schedules and dynamic values -- note that schedules\n        and dynamic values are only updated once a day, not\n        for every discretized timestep.\n        \"\"\"\n\n        sim_state = self.sim_state\n        fixed_params = self.fixed_params\n        current_real_date = self.current_real_date\n\n        schedules = self.schedules\n        dynamic_vals = self.dynamic_vals\n\n        # Update schedules for current day\n        for schedule in schedules.values():\n            schedule.update_current_val(current_real_date)\n\n        # Update dynamic values for current day\n        for dval in dynamic_vals.values():\n            if dval.is_enabled:\n                dval.update_current_val(sim_state, fixed_params)\n\n        # Sync simulation state\n        self.sim_state.update_schedules()\n        self.sim_state.update_dynamic_vals()\n\n    def update_epi_metrics(self):\n\n        sim_state = self.sim_state\n        fixed_params = self.fixed_params\n        timesteps_per_day = self.config.timesteps_per_day\n\n        for metric in self.epi_metrics.values():\n            metric.change_in_current_val = \\\n                metric.get_change_in_current_val(sim_state,\n                                                 fixed_params,\n                                                 timesteps_per_day)\n            metric.update_current_val()\n\n    def update_transition_rates(self):\n\n        sim_state = self.sim_state\n        fixed_params = self.fixed_params\n\n        for tvar in self.transition_variables.values():\n            tvar.current_rate = tvar.get_current_rate(sim_state, fixed_params)\n\n    def sample_transitions(self):\n\n        RNG = self.RNG\n        timesteps_per_day = self.config.timesteps_per_day\n\n        # Obtain transition variable realizations for jointly distributed transition variables\n        #   (i.e. when there are multiple transition variable outflows from an epi compartment)\n        for tvargroup in self.transition_variable_groups.values():\n            tvargroup.current_vals_list = tvargroup.get_joint_realization(RNG,\n                                                                          timesteps_per_day)\n            tvargroup.update_transition_variable_realizations()\n\n        # Obtain transition variable realizations for marginally distributed transition variables\n        #   (i.e. when there is only one transition variable outflow from an epi compartment)\n        # If transition variable is jointly distributed, then its realization has already\n        #   been computed by its transition variable group container previously,\n        #   so skip the marginal computation\n        for tvar in self.transition_variables.values():\n            if not tvar.is_jointly_distributed:\n                tvar.current_val = tvar.get_realization(RNG, timesteps_per_day)\n\n    def update_compartments(self):\n\n        for tvar in self.transition_variables.values():\n            tvar.update_origin_outflow()\n            tvar.update_destination_inflow()\n\n        for compartment in self.compartments.values():\n            compartment.update_current_val()\n\n            compartment.reset_inflow()\n            compartment.reset_outflow()\n\n    def increment_simulation_day(self) -&gt; None:\n        \"\"\"\n        Move to next day in simulation\n        \"\"\"\n\n        self.current_simulation_day += 1\n        self.current_real_date += datetime.timedelta(days=1)\n\n    def save_daily_history(self) -&gt; None:\n        \"\"\"\n        Update history at end of each day, not at end of every\n           discretization timestep, to be efficient.\n        Update history of state variables other than Schedule\n           instances -- schedules do not have history\n           TransitionVariableGroup instances also do not\n           have history, so do not include.\n        \"\"\"\n        for svar in self.compartments.values() + \\\n                    self.epi_metrics.values() + \\\n                    self.dynamic_vals.values():\n            svar.save_history()\n\n    def reset_simulation(self) -&gt; None:\n        \"\"\"\n        Reset simulation in-place. Subsequent method calls of\n        simulate_until_time_period start from day 0, with original\n        day 0 state.\n\n        Returns current_simulation_day to 0.\n        Restores sim_state values to initial values.\n        Clears history on model's state variables.\n        Resets transition variables' current_val attribute to 0.\n\n        WARNING:\n            DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n            ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n            WHERE IT LEFT OFF.\n\n        Use method modify_random_seed to reset model's RNG to its\n        initial starting seed.\n        \"\"\"\n\n        self.current_simulation_day = 0\n        self.current_real_date = self.start_real_date\n\n        # AGAIN, MUST BE CAREFUL ABOUT MUTABLE NUMPY ARRAYS -- MUST USE DEEP COPY\n        for svar in self.compartments.values() + \\\n                    self.epi_metrics.values() + \\\n                    self.dynamic_vals.values() + \\\n                    self.schedules.values():\n            setattr(svar, \"current_val\", copy.deepcopy(svar.init_val))\n\n        self.sim_state.update_all()\n        self.clear_history()\n\n    def clear_history(self) -&gt; None:\n        \"\"\"\n        Resets history_vals_list attribute of each Compartment,\n            EpiMetric, and DynamicVal to an empty list.\n        \"\"\"\n\n        # Schedules do not have history since they are deterministic\n        for svar in self.compartments.values() + \\\n                    self.epi_metrics.values() + \\\n                    self.dynamic_vals.values():\n            svar.clear_history()\n\n        for tvar in self.transition_variables.values():\n            tvar.current_rate = None\n            tvar.current_val = 0.0\n\n        for tvargroup in self.transition_variable_groups.values():\n            tvargroup.current_vals_list = []\n\n    def find_name_by_compartment(self,\n                                 target_compartment: Compartment):\n        for name, compartment in self.compartments.items():\n            if compartment == target_compartment:\n                return name\n\n    def display(self) -&gt; None:\n        \"\"\"\n        Prints structure of model (compartments and linkages),\n            transition variables, epi metrics, schedules,\n            and dynamic values.\n        \"\"\"\n\n        # We build origin_dict so that we can print\n        #   compartment transitions in an easy-to-read way --\n        #   for connections between origin --&gt; destination,\n        #   we print all connections with the same origin\n        #   consecutively\n        origin_dict = defaultdict(list)\n\n        # Each key in origin_dict is a string corresponding to\n        #   an origin (Compartment) name\n        # Each val in origin_dict is a list of 3-tuples\n        # Each 3-tuple has the name of a destination (Compartment)\n        #   connected to the given origin, the name of the transition\n        #   variable connecting the origin and destination,\n        #   and Boolean indicating if the transition variable is jointly\n        #   distributed\n        for tvar_name, tvar in self.transition_variables.items():\n            origin_dict[self.find_name_by_compartment(tvar.origin)].append(\n                (self.find_name_by_compartment(tvar.destination),\n                 tvar_name, tvar.is_jointly_distributed))\n\n        print(f\"\\n&gt;&gt;&gt; Displaying SubpopModel {self.name}\")\n\n        print(\"\\nCompartments and transition variables\")\n        print(\"=====================================\")\n        for origin_name, origin in self.compartments.items():\n            for output in origin_dict[origin_name]:\n                if output[2]:\n                    print(f\"{origin_name} --&gt; {output[0]}, via {output[1]}: jointly distributed\")\n                else:\n                    print(f\"{origin_name} --&gt; {output[0]}, via {output[1]}\")\n\n        print(\"\\nEpi metrics\")\n        print(\"===========\")\n        for name in self.epi_metrics.keys():\n            print(f\"{name}\")\n\n        print(\"\\nSchedules\")\n        print(\"=========\")\n        for name in self.schedules.keys():\n            print(f\"{name}\")\n\n        print(\"\\nDynamic values\")\n        print(\"==============\")\n        for name, dynamic_val in self.dynamic_vals.items():\n            if dynamic_val.is_enabled:\n                print(f\"{name}: enabled\")\n            else:\n                print(f\"{name}: disabled\")\n        print(\"\\n\")\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.clear_history","title":"<code>clear_history()</code>","text":"<p>Resets history_vals_list attribute of each Compartment,     EpiMetric, and DynamicVal to an empty list.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def clear_history(self) -&gt; None:\n    \"\"\"\n    Resets history_vals_list attribute of each Compartment,\n        EpiMetric, and DynamicVal to an empty list.\n    \"\"\"\n\n    # Schedules do not have history since they are deterministic\n    for svar in self.compartments.values() + \\\n                self.epi_metrics.values() + \\\n                self.dynamic_vals.values():\n        svar.clear_history()\n\n    for tvar in self.transition_variables.values():\n        tvar.current_rate = None\n        tvar.current_val = 0.0\n\n    for tvargroup in self.transition_variable_groups.values():\n        tvargroup.current_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.display","title":"<code>display()</code>","text":"<p>Prints structure of model (compartments and linkages),     transition variables, epi metrics, schedules,     and dynamic values.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def display(self) -&gt; None:\n    \"\"\"\n    Prints structure of model (compartments and linkages),\n        transition variables, epi metrics, schedules,\n        and dynamic values.\n    \"\"\"\n\n    # We build origin_dict so that we can print\n    #   compartment transitions in an easy-to-read way --\n    #   for connections between origin --&gt; destination,\n    #   we print all connections with the same origin\n    #   consecutively\n    origin_dict = defaultdict(list)\n\n    # Each key in origin_dict is a string corresponding to\n    #   an origin (Compartment) name\n    # Each val in origin_dict is a list of 3-tuples\n    # Each 3-tuple has the name of a destination (Compartment)\n    #   connected to the given origin, the name of the transition\n    #   variable connecting the origin and destination,\n    #   and Boolean indicating if the transition variable is jointly\n    #   distributed\n    for tvar_name, tvar in self.transition_variables.items():\n        origin_dict[self.find_name_by_compartment(tvar.origin)].append(\n            (self.find_name_by_compartment(tvar.destination),\n             tvar_name, tvar.is_jointly_distributed))\n\n    print(f\"\\n&gt;&gt;&gt; Displaying SubpopModel {self.name}\")\n\n    print(\"\\nCompartments and transition variables\")\n    print(\"=====================================\")\n    for origin_name, origin in self.compartments.items():\n        for output in origin_dict[origin_name]:\n            if output[2]:\n                print(f\"{origin_name} --&gt; {output[0]}, via {output[1]}: jointly distributed\")\n            else:\n                print(f\"{origin_name} --&gt; {output[0]}, via {output[1]}\")\n\n    print(\"\\nEpi metrics\")\n    print(\"===========\")\n    for name in self.epi_metrics.keys():\n        print(f\"{name}\")\n\n    print(\"\\nSchedules\")\n    print(\"=========\")\n    for name in self.schedules.keys():\n        print(f\"{name}\")\n\n    print(\"\\nDynamic values\")\n    print(\"==============\")\n    for name, dynamic_val in self.dynamic_vals.items():\n        if dynamic_val.is_enabled:\n            print(f\"{name}: enabled\")\n        else:\n            print(f\"{name}: disabled\")\n    print(\"\\n\")\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.get_start_real_date","title":"<code>get_start_real_date()</code>","text":"<p>Fetches start_real_date from config -- converts to     proper datetime.date format if originally given as     string.</p> <p>Returns:</p> Name Type Description <code>start_real_date</code> <code>date</code> <p>real-world date that corresponds to start of simulation.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_start_real_date(self):\n    \"\"\"\n    Fetches start_real_date from config -- converts to\n        proper datetime.date format if originally given as\n        string.\n\n    Returns:\n        start_real_date (datetime.date):\n            real-world date that corresponds to start of\n            simulation.\n    \"\"\"\n\n    start_real_date = self.config.start_real_date\n\n    if not isinstance(start_real_date, datetime.date):\n        try:\n            start_real_date = \\\n                datetime.datetime.strptime(start_real_date, \"%Y-%m-%d\").date()\n        except ValueError:\n            print(\"Error: The date format should be YYYY-MM-DD.\")\n\n    return start_real_date\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.increment_simulation_day","title":"<code>increment_simulation_day()</code>","text":"<p>Move to next day in simulation</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def increment_simulation_day(self) -&gt; None:\n    \"\"\"\n    Move to next day in simulation\n    \"\"\"\n\n    self.current_simulation_day += 1\n    self.current_real_date += datetime.timedelta(days=1)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.modify_random_seed","title":"<code>modify_random_seed(new_seed_number)</code>","text":"<p>Modifies model's RNG attribute in-place to new generator seeded at new_seed_number.</p> <p>Parameters:</p> Name Type Description Default <code>new_seed_number</code> <code>int</code> <p>used to re-seed model's random number generator.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def modify_random_seed(self, new_seed_number) -&gt; None:\n    \"\"\"\n    Modifies model's RNG attribute in-place to new generator\n    seeded at new_seed_number.\n\n    Args:\n        new_seed_number (int):\n            used to re-seed model's random number generator.\n    \"\"\"\n\n    self._bit_generator = np.random.MT19937(seed=new_seed_number)\n    self.RNG = np.random.Generator(self._bit_generator)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.prepare_daily_state","title":"<code>prepare_daily_state()</code>","text":"<p>At beginning of each day, update current value of schedules and dynamic values -- note that schedules and dynamic values are only updated once a day, not for every discretized timestep.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def prepare_daily_state(self) -&gt; None:\n    \"\"\"\n    At beginning of each day, update current value of\n    schedules and dynamic values -- note that schedules\n    and dynamic values are only updated once a day, not\n    for every discretized timestep.\n    \"\"\"\n\n    sim_state = self.sim_state\n    fixed_params = self.fixed_params\n    current_real_date = self.current_real_date\n\n    schedules = self.schedules\n    dynamic_vals = self.dynamic_vals\n\n    # Update schedules for current day\n    for schedule in schedules.values():\n        schedule.update_current_val(current_real_date)\n\n    # Update dynamic values for current day\n    for dval in dynamic_vals.values():\n        if dval.is_enabled:\n            dval.update_current_val(sim_state, fixed_params)\n\n    # Sync simulation state\n    self.sim_state.update_schedules()\n    self.sim_state.update_dynamic_vals()\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.reset_simulation","title":"<code>reset_simulation()</code>","text":"<p>Reset simulation in-place. Subsequent method calls of simulate_until_time_period start from day 0, with original day 0 state.</p> <p>Returns current_simulation_day to 0. Restores sim_state values to initial values. Clears history on model's state variables. Resets transition variables' current_val attribute to 0.</p> WARNING <p>DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE WHERE IT LEFT OFF.</p> <p>Use method modify_random_seed to reset model's RNG to its initial starting seed.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def reset_simulation(self) -&gt; None:\n    \"\"\"\n    Reset simulation in-place. Subsequent method calls of\n    simulate_until_time_period start from day 0, with original\n    day 0 state.\n\n    Returns current_simulation_day to 0.\n    Restores sim_state values to initial values.\n    Clears history on model's state variables.\n    Resets transition variables' current_val attribute to 0.\n\n    WARNING:\n        DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n        ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n        WHERE IT LEFT OFF.\n\n    Use method modify_random_seed to reset model's RNG to its\n    initial starting seed.\n    \"\"\"\n\n    self.current_simulation_day = 0\n    self.current_real_date = self.start_real_date\n\n    # AGAIN, MUST BE CAREFUL ABOUT MUTABLE NUMPY ARRAYS -- MUST USE DEEP COPY\n    for svar in self.compartments.values() + \\\n                self.epi_metrics.values() + \\\n                self.dynamic_vals.values() + \\\n                self.schedules.values():\n        setattr(svar, \"current_val\", copy.deepcopy(svar.init_val))\n\n    self.sim_state.update_all()\n    self.clear_history()\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.save_daily_history","title":"<code>save_daily_history()</code>","text":"<p>Update history at end of each day, not at end of every    discretization timestep, to be efficient. Update history of state variables other than Schedule    instances -- schedules do not have history    TransitionVariableGroup instances also do not    have history, so do not include.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def save_daily_history(self) -&gt; None:\n    \"\"\"\n    Update history at end of each day, not at end of every\n       discretization timestep, to be efficient.\n    Update history of state variables other than Schedule\n       instances -- schedules do not have history\n       TransitionVariableGroup instances also do not\n       have history, so do not include.\n    \"\"\"\n    for svar in self.compartments.values() + \\\n                self.epi_metrics.values() + \\\n                self.dynamic_vals.values():\n        svar.save_history()\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.simulate_timesteps","title":"<code>simulate_timesteps(num_timesteps)</code>","text":"<p>Subroutine for simulate_until_time_period.</p> <p>Iterates through discretized timesteps to simulate next simulation day. Granularity of discretization is given by attribute config.timesteps_per_day.</p> <p>Properly scales transition variable realizations and changes in dynamic vals by specified timesteps per day.</p> <p>Parameters:</p> Name Type Description Default <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def simulate_timesteps(self,\n                       num_timesteps: int) -&gt; None:\n    \"\"\"\n    Subroutine for simulate_until_time_period.\n\n    Iterates through discretized timesteps to simulate next\n    simulation day. Granularity of discretization is given by\n    attribute config.timesteps_per_day.\n\n    Properly scales transition variable realizations and changes\n    in dynamic vals by specified timesteps per day.\n\n    Parameters:\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n    \"\"\"\n\n    for timestep in range(num_timesteps):\n        self.update_transition_rates()\n\n        self.sample_transitions()\n\n        self.update_epi_metrics()\n\n        self.update_compartments()\n\n        self.sim_state.update_epi_metrics()\n        self.sim_state.update_compartments()\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModel.simulate_until_time_period","title":"<code>simulate_until_time_period(last_simulation_day)</code>","text":"<p>Advance simulation model time until last_simulation_day.</p> <p>Advance time by iterating through simulation days, which are simulated by iterating through discretized timesteps.</p> <p>Save daily simulation data as history on each Compartment instance.</p> <p>Parameters:</p> Name Type Description Default <code>last_simulation_day</code> <code>positive int</code> <p>stop simulation at last_simulation_day (i.e. exclusive, simulate up to but not including last_simulation_day).</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def simulate_until_time_period(self, last_simulation_day) -&gt; None:\n    \"\"\"\n    Advance simulation model time until last_simulation_day.\n\n    Advance time by iterating through simulation days,\n    which are simulated by iterating through discretized\n    timesteps.\n\n    Save daily simulation data as history on each Compartment\n    instance.\n\n    Args:\n        last_simulation_day (positive int):\n            stop simulation at last_simulation_day (i.e. exclusive,\n            simulate up to but not including last_simulation_day).\n    \"\"\"\n\n    if self.current_simulation_day &gt; last_simulation_day:\n        raise SubpopModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                               f\"exceeds last simulation day ({last_simulation_day}).\")\n\n    save_daily_history = self.config.save_daily_history\n    timesteps_per_day = self.config.timesteps_per_day\n\n    # last_simulation_day is exclusive endpoint\n    while self.current_simulation_day &lt; last_simulation_day:\n\n        # Get current values of Schedule and DynamicVal instances\n        self.prepare_daily_state()\n\n        self.simulate_timesteps(timesteps_per_day)\n\n        if save_daily_history:\n            self.save_daily_history()\n\n        self.increment_simulation_day()\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.SubpopModelError","title":"<code>SubpopModelError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for simulation model errors.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class SubpopModelError(Exception):\n    \"\"\"Custom exceptions for simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionTypes","title":"<code>TransitionTypes</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class TransitionTypes(str, Enum):\n    BINOMIAL = \"binomial\"\n    BINOMIAL_DETERMINISTIC = \"binomial_deterministic\"\n    BINOMIAL_TAYLOR_APPROX = \"binomial_taylor_approx\"\n    BINOMIAL_TAYLOR_APPROX_DETERMINISTIC = \"binomial_taylor_approx_deterministic\"\n    POISSON = \"poisson\"\n    POISSON_DETERMINISTIC = \"poisson_deterministic\"\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable","title":"<code>TransitionVariable</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for transition variables in epidemiological model.</p> <p>For example, in an S-I-R model, the new number infected every iteration (the number going from S to I) in an iteration is modeled as a TransitionVariable subclass, with a concrete implementation of the abstract method get_current_rate.</p> <p>When an instance is initialized, its get_realization attribute is dynamically assigned, just like in the case of TransitionVariableGroup instantiation.</p> <p>Attributes:</p> Name Type Description <code>_transition_type</code> <code>str</code> <p>only values defined in TransitionTypes Enum are valid, specifying probability distribution of transitions between compartments.</p> <code>get_current_rate</code> <code>function</code> <p>provides specific implementation for computing current rate as a function of current simulation state and epidemiological parameters.</p> <code>current_rate</code> <code>ndarray</code> <p>holds output from get_current_rate method -- used to generate random variable realizations for transitions between compartments.</p> <code>current_val</code> <code>ndarray</code> <p>holds realization of random variable parameterized by current_rate.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of current_val, holds history of transition variable realizations for age-risk groups -- element t corresponds to previous current_val value at end of simulation day t.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class TransitionVariable(ABC):\n    \"\"\"\n    Abstract base class for transition variables in\n    epidemiological model.\n\n    For example, in an S-I-R model, the new number infected\n    every iteration (the number going from S to I) in an iteration\n    is modeled as a TransitionVariable subclass, with a concrete\n    implementation of the abstract method get_current_rate.\n\n    When an instance is initialized, its get_realization attribute\n    is dynamically assigned, just like in the case of\n    TransitionVariableGroup instantiation.\n\n    Attributes:\n        _transition_type (str):\n            only values defined in TransitionTypes Enum are valid, specifying\n            probability distribution of transitions between compartments.\n        get_current_rate (function):\n            provides specific implementation for computing current rate\n            as a function of current simulation state and epidemiological parameters.\n        current_rate (np.ndarray):\n            holds output from get_current_rate method -- used to generate\n            random variable realizations for transitions between compartments.\n        current_val (np.ndarray):\n            holds realization of random variable parameterized by current_rate.\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of current_val, holds\n            history of transition variable realizations for age-risk\n            groups -- element t corresponds to previous current_val value\n            at end of simulation day t.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin,\n                 destination,\n                 transition_type,\n                 is_jointly_distributed=False):\n        \"\"\"\n        Parameters:\n            origin (Compartment):\n                the compartment from which Transition Variable exits.\n            destination (Compartment):\n                compartment that the TransitionVariable enters.\n            transition_type (str):\n                only values defined in TransitionTypes Enum are valid, specifying\n                probability distribution of transitions between compartments.\n            is_jointly_distributed (bool):\n                indicates if transition quantity must be jointly computed\n                (i.e. if there are multiple outflows from the origin compartment).\n        \"\"\"\n\n        self.origin = origin\n        self.destination = destination\n\n        # Also see __init__ method in TransitionVariableGroup class.\n        #   The structure is similar.\n        self._transition_type = transition_type\n        self._is_jointly_distributed = is_jointly_distributed\n\n        if is_jointly_distributed:\n            self.get_realization = None\n        else:\n            self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_rate = None\n        self.current_val = 0\n\n        self.history_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; TransitionTypes:\n        return self._transition_type\n\n    @property\n    def is_jointly_distributed(self) -&gt; bool:\n        return self._is_jointly_distributed\n\n    @abstractmethod\n    def get_current_rate(self,\n                         sim_state: SimState,\n                         fixed_params: FixedParams) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns current rate of transition variable,\n        based on current state of the simulation and epidemiological parameters.\n        Output should be a numpy array of size A x L, where A is\n        number of age groups and L is number of risk groups.\n\n        Args:\n            sim_state (SimState):\n                holds simulation state (current values of StateVariable instances).\n            fixed_params (FixedParams):\n                holds values of epidemiological parameters.\n\n        Returns:\n            np.ndarray:\n                holds age-risk transition rate,\n                must be same shape as origin.init_val,\n                i.e. be size A x L, where A is number of age groups\n                and L is number of risk groups.\n        \"\"\"\n        pass\n\n    def update_origin_outflow(self) -&gt; None:\n        \"\"\"\n        Adds current realization of TransitionVariable to\n            its origin Compartment's current_outflow.\n            Used to compute total number leaving that\n            origin Compartment.\n        \"\"\"\n\n        self.origin.current_outflow += self.current_val\n\n    def update_destination_inflow(self) -&gt; None:\n        \"\"\"\n        Adds current realization of TransitionVariable to\n            its destination Compartment's current_inflow.\n            Used to compute total number leaving that\n            destination Compartment.\n        \"\"\"\n\n        self.destination.current_inflow += self.current_val\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending current_val attribute\n            to history_vals_list in place\n\n        Deep copying is CRUCIAL because current_val is a mutable\n            np.ndarray -- without deep copying, history_vals_list would\n            have the same value for all elements\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def clear_history(self) -&gt; None:\n        \"\"\"\n        Resets history_vals_list attribute to empty list.\n        \"\"\"\n\n        self.history_vals_list = []\n\n    def get_realization(self,\n                        RNG: np.random.Generator,\n                        num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        This method gets assigned to one of the following methods\n            based on the TransitionVariable transition type:\n            get_binomial_realization, get_binomial_taylor_approx_realization,\n            get_poisson_realization, get_binomial_deterministic_realization,\n            get_binomial_taylor_approx_deterministic_realization,\n            get_poisson_deterministic_realization. This is done so that\n            the same method get_realization can be called regardless of\n            transition type.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                used to generate random variables and control reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n        \"\"\"\n\n        pass\n\n    def get_binomial_realization(self,\n                                 RNG: np.random.Generator,\n                                 num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses RNG to generate binomial random variable with\n            number of trials equal to population count in the\n            origin Compartment and probability computed from\n            a function of the TransitionVariable's current rate\n            -- see the approx_binomial_probability_from_rate\n            function for details\n\n        Parameters:\n            RNG (np.random.Generator object):\n                used to generate random variables and control reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size A x L, where A is number of age groups and\n                L is number of risk groups.\n        \"\"\"\n\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=approx_binomial_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n\n    def get_binomial_taylor_approx_realization(self,\n                                               RNG: np.random.Generator,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses RNG to generate binomial random variable with\n            number of trials equal to population count in the\n            origin Compartment and probability equal to\n            the TransitionVariable's current_rate / num_timesteps\n\n        Parameters:\n            RNG (np.random.Generator object):\n                used to generate random variables and control reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size A x L, where A is number of age groups and L\n                is number of risk groups.\n        \"\"\"\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=self.current_rate * (1.0 / num_timesteps))\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Uses RNG to generate Poisson random variable with\n            rate equal to (population count in the\n            origin Compartment x the TransitionVariable's\n            current_rate / num_timesteps)\n\n        Parameters:\n            RNG (np.random.Generator object):\n                used to generate random variables and control reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size A x L, where A is number of age groups and\n                L is number of risk groups.\n        \"\"\"\n        return RNG.poisson(self.base_count * self.current_rate / float(num_timesteps))\n\n    def get_binomial_deterministic_realization(self,\n                                               RNG: np.random.Generator,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of binomial distribution\n            (number of trials x probability), where number of trials\n            equals population count in the origin Compartment and\n            probability is computed from a function of the TransitionVariable's\n            current rate -- see the approx_binomial_probability_from_rate\n            function for details\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size A x L, where A is number of age groups and\n                L is number of risk groups.\n        \"\"\"\n\n        return np.asarray(self.base_count *\n                          approx_binomial_probability_from_rate(self.current_rate, 1.0 / num_timesteps),\n                          dtype=int)\n\n    def get_binomial_taylor_approx_deterministic_realization(self,\n                                                             RNG: np.random.Generator,\n                                                             num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of binomial distribution\n            (number of trials x probability), where number of trials\n            equals population count in the origin Compartment and\n            probability equals the TransitionVariable's current rate /\n            num_timesteps\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size A x L, where A is number of age groups and\n                L is number of risk groups.\n        \"\"\"\n\n        return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n\n    def get_poisson_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministically returns mean of Poisson distribution,\n            givey by (population count in the origin Compartment x\n            TransitionVariable's current rate / num_timesteps)\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size A x L, where A is number of age groups and\n                L is number of risk groups.\n        \"\"\"\n\n        return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n\n    @property\n    def base_count(self) -&gt; np.ndarray:\n        return self.origin.current_val\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.__init__","title":"<code>__init__(origin, destination, transition_type, is_jointly_distributed=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>origin</code> <code>Compartment</code> <p>the compartment from which Transition Variable exits.</p> required <code>destination</code> <code>Compartment</code> <p>compartment that the TransitionVariable enters.</p> required <code>transition_type</code> <code>str</code> <p>only values defined in TransitionTypes Enum are valid, specifying probability distribution of transitions between compartments.</p> required <code>is_jointly_distributed</code> <code>bool</code> <p>indicates if transition quantity must be jointly computed (i.e. if there are multiple outflows from the origin compartment).</p> <code>False</code> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             origin,\n             destination,\n             transition_type,\n             is_jointly_distributed=False):\n    \"\"\"\n    Parameters:\n        origin (Compartment):\n            the compartment from which Transition Variable exits.\n        destination (Compartment):\n            compartment that the TransitionVariable enters.\n        transition_type (str):\n            only values defined in TransitionTypes Enum are valid, specifying\n            probability distribution of transitions between compartments.\n        is_jointly_distributed (bool):\n            indicates if transition quantity must be jointly computed\n            (i.e. if there are multiple outflows from the origin compartment).\n    \"\"\"\n\n    self.origin = origin\n    self.destination = destination\n\n    # Also see __init__ method in TransitionVariableGroup class.\n    #   The structure is similar.\n    self._transition_type = transition_type\n    self._is_jointly_distributed = is_jointly_distributed\n\n    if is_jointly_distributed:\n        self.get_realization = None\n    else:\n        self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_rate = None\n    self.current_val = 0\n\n    self.history_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.clear_history","title":"<code>clear_history()</code>","text":"<p>Resets history_vals_list attribute to empty list.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def clear_history(self) -&gt; None:\n    \"\"\"\n    Resets history_vals_list attribute to empty list.\n    \"\"\"\n\n    self.history_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_binomial_deterministic_realization","title":"<code>get_binomial_deterministic_realization(RNG, num_timesteps)</code>","text":"<p>Deterministically returns mean of binomial distribution     (number of trials x probability), where number of trials     equals population count in the origin Compartment and     probability is computed from a function of the TransitionVariable's     current rate -- see the approx_binomial_probability_from_rate     function for details</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size A x L, where A is number of age groups and L is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_binomial_deterministic_realization(self,\n                                           RNG: np.random.Generator,\n                                           num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of binomial distribution\n        (number of trials x probability), where number of trials\n        equals population count in the origin Compartment and\n        probability is computed from a function of the TransitionVariable's\n        current rate -- see the approx_binomial_probability_from_rate\n        function for details\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size A x L, where A is number of age groups and\n            L is number of risk groups.\n    \"\"\"\n\n    return np.asarray(self.base_count *\n                      approx_binomial_probability_from_rate(self.current_rate, 1.0 / num_timesteps),\n                      dtype=int)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_binomial_realization","title":"<code>get_binomial_realization(RNG, num_timesteps)</code>","text":"<p>Uses RNG to generate binomial random variable with     number of trials equal to population count in the     origin Compartment and probability computed from     a function of the TransitionVariable's current rate     -- see the approx_binomial_probability_from_rate     function for details</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size A x L, where A is number of age groups and L is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_binomial_realization(self,\n                             RNG: np.random.Generator,\n                             num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses RNG to generate binomial random variable with\n        number of trials equal to population count in the\n        origin Compartment and probability computed from\n        a function of the TransitionVariable's current rate\n        -- see the approx_binomial_probability_from_rate\n        function for details\n\n    Parameters:\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size A x L, where A is number of age groups and\n            L is number of risk groups.\n    \"\"\"\n\n    return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                        p=approx_binomial_probability_from_rate(self.current_rate, 1.0 / num_timesteps))\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_binomial_taylor_approx_deterministic_realization","title":"<code>get_binomial_taylor_approx_deterministic_realization(RNG, num_timesteps)</code>","text":"<p>Deterministically returns mean of binomial distribution     (number of trials x probability), where number of trials     equals population count in the origin Compartment and     probability equals the TransitionVariable's current rate /     num_timesteps</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size A x L, where A is number of age groups and L is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_binomial_taylor_approx_deterministic_realization(self,\n                                                         RNG: np.random.Generator,\n                                                         num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of binomial distribution\n        (number of trials x probability), where number of trials\n        equals population count in the origin Compartment and\n        probability equals the TransitionVariable's current rate /\n        num_timesteps\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size A x L, where A is number of age groups and\n            L is number of risk groups.\n    \"\"\"\n\n    return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_binomial_taylor_approx_realization","title":"<code>get_binomial_taylor_approx_realization(RNG, num_timesteps)</code>","text":"<p>Uses RNG to generate binomial random variable with     number of trials equal to population count in the     origin Compartment and probability equal to     the TransitionVariable's current_rate / num_timesteps</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size A x L, where A is number of age groups and L is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_binomial_taylor_approx_realization(self,\n                                           RNG: np.random.Generator,\n                                           num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses RNG to generate binomial random variable with\n        number of trials equal to population count in the\n        origin Compartment and probability equal to\n        the TransitionVariable's current_rate / num_timesteps\n\n    Parameters:\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size A x L, where A is number of age groups and L\n            is number of risk groups.\n    \"\"\"\n    return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                        p=self.current_rate * (1.0 / num_timesteps))\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_current_rate","title":"<code>get_current_rate(sim_state, fixed_params)</code>","text":"<p>Computes and returns current rate of transition variable, based on current state of the simulation and epidemiological parameters. Output should be a numpy array of size A x L, where A is number of age groups and L is number of risk groups.</p> <p>Parameters:</p> Name Type Description Default <code>sim_state</code> <code>SimState</code> <p>holds simulation state (current values of StateVariable instances).</p> required <code>fixed_params</code> <code>FixedParams</code> <p>holds values of epidemiological parameters.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: holds age-risk transition rate, must be same shape as origin.init_val, i.e. be size A x L, where A is number of age groups and L is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>@abstractmethod\ndef get_current_rate(self,\n                     sim_state: SimState,\n                     fixed_params: FixedParams) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns current rate of transition variable,\n    based on current state of the simulation and epidemiological parameters.\n    Output should be a numpy array of size A x L, where A is\n    number of age groups and L is number of risk groups.\n\n    Args:\n        sim_state (SimState):\n            holds simulation state (current values of StateVariable instances).\n        fixed_params (FixedParams):\n            holds values of epidemiological parameters.\n\n    Returns:\n        np.ndarray:\n            holds age-risk transition rate,\n            must be same shape as origin.init_val,\n            i.e. be size A x L, where A is number of age groups\n            and L is number of risk groups.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_poisson_deterministic_realization","title":"<code>get_poisson_deterministic_realization(RNG, num_timesteps)</code>","text":"<p>Deterministically returns mean of Poisson distribution,     givey by (population count in the origin Compartment x     TransitionVariable's current rate / num_timesteps)</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size A x L, where A is number of age groups and L is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_poisson_deterministic_realization(self,\n                                          RNG: np.random.Generator,\n                                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministically returns mean of Poisson distribution,\n        givey by (population count in the origin Compartment x\n        TransitionVariable's current rate / num_timesteps)\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size A x L, where A is number of age groups and\n            L is number of risk groups.\n    \"\"\"\n\n    return np.asarray(self.base_count * self.current_rate / num_timesteps, dtype=int)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_poisson_realization","title":"<code>get_poisson_realization(RNG, num_timesteps)</code>","text":"<p>Uses RNG to generate Poisson random variable with     rate equal to (population count in the     origin Compartment x the TransitionVariable's     current_rate / num_timesteps)</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size A x L, where A is number of age groups and L is number of risk groups.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_poisson_realization(self,\n                            RNG: np.random.Generator,\n                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Uses RNG to generate Poisson random variable with\n        rate equal to (population count in the\n        origin Compartment x the TransitionVariable's\n        current_rate / num_timesteps)\n\n    Parameters:\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size A x L, where A is number of age groups and\n            L is number of risk groups.\n    \"\"\"\n    return RNG.poisson(self.base_count * self.current_rate / float(num_timesteps))\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.get_realization","title":"<code>get_realization(RNG, num_timesteps)</code>","text":"<p>This method gets assigned to one of the following methods     based on the TransitionVariable transition type:     get_binomial_realization, get_binomial_taylor_approx_realization,     get_poisson_realization, get_binomial_deterministic_realization,     get_binomial_taylor_approx_deterministic_realization,     get_poisson_deterministic_realization. This is done so that     the same method get_realization can be called regardless of     transition type.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_realization(self,\n                    RNG: np.random.Generator,\n                    num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    This method gets assigned to one of the following methods\n        based on the TransitionVariable transition type:\n        get_binomial_realization, get_binomial_taylor_approx_realization,\n        get_poisson_realization, get_binomial_deterministic_realization,\n        get_binomial_taylor_approx_deterministic_realization,\n        get_poisson_deterministic_realization. This is done so that\n        the same method get_realization can be called regardless of\n        transition type.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.save_history","title":"<code>save_history()</code>","text":"<p>Saves current value to history by appending current_val attribute     to history_vals_list in place</p> <p>Deep copying is CRUCIAL because current_val is a mutable     np.ndarray -- without deep copying, history_vals_list would     have the same value for all elements</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending current_val attribute\n        to history_vals_list in place\n\n    Deep copying is CRUCIAL because current_val is a mutable\n        np.ndarray -- without deep copying, history_vals_list would\n        have the same value for all elements\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.update_destination_inflow","title":"<code>update_destination_inflow()</code>","text":"<p>Adds current realization of TransitionVariable to     its destination Compartment's current_inflow.     Used to compute total number leaving that     destination Compartment.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_destination_inflow(self) -&gt; None:\n    \"\"\"\n    Adds current realization of TransitionVariable to\n        its destination Compartment's current_inflow.\n        Used to compute total number leaving that\n        destination Compartment.\n    \"\"\"\n\n    self.destination.current_inflow += self.current_val\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariable.update_origin_outflow","title":"<code>update_origin_outflow()</code>","text":"<p>Adds current realization of TransitionVariable to     its origin Compartment's current_outflow.     Used to compute total number leaving that     origin Compartment.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_origin_outflow(self) -&gt; None:\n    \"\"\"\n    Adds current realization of TransitionVariable to\n        its origin Compartment's current_outflow.\n        Used to compute total number leaving that\n        origin Compartment.\n    \"\"\"\n\n    self.origin.current_outflow += self.current_val\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup","title":"<code>TransitionVariableGroup</code>","text":"<p>Container for TransitionVariable objects to handle joint sampling, when there are multiple outflows from a single compartment.</p> <p>For example, if all outflows of compartment H are: R and D, i.e. from the Hosp compartment, people either go to Recovered or Dead, a TransitionVariableGroup that holds both R and D handles the correct correlation structure between R and D.</p> <p>When an instance is initialized, its get_joint_realization attribute is dynamically assigned to a method according to its transition_type attribute. This enables all instances to use the same method during simulation.</p> <p>Attributes:</p> Name Type Description <code>origin</code> <code>Compartment</code> <p>specifies origin of TransitionVariableGroup -- corresponding populations leave this compartment.</p> <code>_transition_type</code> <code>str</code> <p>only values defined in JointTransitionTypes Enum are valid, specifies joint probability distribution of all outflows from origin.</p> <code>transition_variables</code> <code>list[TransitionVariable]</code> <p>specifying TransitionVariable instances that outflow from origin -- order does not matter.</p> <code>get_joint_realization</code> <code>function</code> <p>assigned at initialization, generates realizations according to probability distribution given by _transition_type attribute, returns either (M x A x L) or ((M+1) x A x L) np.ndarray, where M is the length of transition_variables (i.e., number of outflows from origin), A is number of age groups, L is number of risk groups.</p> <code>current_vals_list</code> <code>list</code> <p>used to store results from get_joint_realization -- has either M or M+1 arrays of size A x L.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>class TransitionVariableGroup:\n    \"\"\"\n    Container for TransitionVariable objects to handle joint sampling,\n    when there are multiple outflows from a single compartment.\n\n    For example, if all outflows of compartment H are: R and D,\n    i.e. from the Hosp compartment, people either go to Recovered\n    or Dead, a TransitionVariableGroup that holds both R and D handles\n    the correct correlation structure between R and D.\n\n    When an instance is initialized, its get_joint_realization attribute\n    is dynamically assigned to a method according to its transition_type\n    attribute. This enables all instances to use the same method during\n    simulation.\n\n    Attributes:\n        origin (Compartment):\n            specifies origin of TransitionVariableGroup --\n            corresponding populations leave this compartment.\n        _transition_type (str):\n            only values defined in JointTransitionTypes Enum are valid,\n            specifies joint probability distribution of all outflows\n            from origin.\n        transition_variables (list[TransitionVariable]):\n            specifying TransitionVariable instances that outflow from origin --\n            order does not matter.\n        get_joint_realization (function):\n            assigned at initialization, generates realizations according\n            to probability distribution given by _transition_type attribute,\n            returns either (M x A x L) or ((M+1) x A x L) np.ndarray,\n            where M is the length of transition_variables (i.e., number of\n            outflows from origin), A is number of age groups, L is number of\n            risk groups.\n        current_vals_list (list):\n            used to store results from get_joint_realization --\n            has either M or M+1 arrays of size A x L.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 origin,\n                 transition_type,\n                 transition_variables):\n        \"\"\"\n        Args:\n            transition_type (str):\n                only values defined in TransitionTypes Enum are valid, specifying\n                probability distribution of transitions between compartments.\n\n        See class docstring for other parameters.\n        \"\"\"\n\n        self.origin = origin\n        self.transition_variables = transition_variables\n\n        # If marginal transition type is any kind of binomial transition,\n        #   then its joint transition type is a multinomial counterpart\n        # For example, if the marginal transition type is TransitionTypes.BINOMIAL_DETERMINISTIC,\n        #   then the joint transition type is JointTransitionTypes.MULTINOMIAL_DETERMINISTIC\n        transition_type = transition_type.replace(\"binomial\", \"multinomial\")\n        self._transition_type = transition_type\n\n        # Dynamically assign a method to get_joint_realization attribute\n        #   based on the value of transition_type\n        # getattr fetches a method by name\n        self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; JointTransitionTypes:\n        return self._transition_type\n\n    def get_total_rate(self) -&gt; np.ndarray:\n        \"\"\"\n        Return the age-risk-specific total transition rate,\n        which is the sum of the current rate of each transition variable\n        in this transition variable group.\n\n        Used to properly scale multinomial probabilities vector so\n        that elements sum to 1.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, has size equal to number\n                of age groups x number of risk groups,\n                sum of current rates of transition variables in\n                transition variable group.\n        \"\"\"\n\n        # axis 0: corresponds to outgoing transition variable\n        # axis 1: corresponds to age groups\n        # axis 2: corresponds to risk groups\n        # --&gt; summing over axis 0 gives the total rate for each age-risk group\n        return np.sum(self.get_current_rates_array(), axis=0)\n\n    def get_probabilities_array(self,\n                                num_timesteps: int) -&gt; list:\n        \"\"\"\n        Returns an array of probabilities used for joint binomial\n        (multinomial) transitions (get_multinomial_realization method).\n\n        Returns:\n            np.ndarray:\n                contains positive floats &lt;= 1, size equal to\n                ((length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        total_rate = self.get_total_rate()\n\n        total_outgoing_probability = approx_binomial_probability_from_rate(total_rate,\n                                                                           1 / num_timesteps)\n\n        # Create probabilities_list, where element i corresponds to the\n        #   transition variable i's current rate divided by the total rate,\n        #   multiplized by the total outgoing probability\n        # This generates the probabilities array that parameterizes the\n        #   multinomial distribution\n        probabilities_list = []\n\n        for transition_variable in self.transition_variables:\n            probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                      total_outgoing_probability)\n\n        # Append the probability that a person stays in the compartment\n        probabilities_list.append(1 - total_outgoing_probability)\n\n        return np.asarray(probabilities_list)\n\n    def get_current_rates_array(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of current rates of transition variables in\n        self.transition_variables -- ith element in array\n        corresponds to current rate of ith transition variable.\n\n        Returns:\n            np.ndarray:\n                array of positive floats, size equal to (length of outgoing\n                transition variables list x number of age groups x number of risk groups).\n        \"\"\"\n\n        current_rates_list = []\n        for tvar in self.transition_variables:\n            current_rates_list.append(tvar.current_rate)\n\n        return np.asarray(current_rates_list)\n\n    def get_joint_realization(self,\n                              RNG: np.random.Generator,\n                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        This function is dynamically assigned based on the Transition\n        Variable Group's transition type -- this function is set to\n        one of the following methods: get_multinomial_realization,\n        get_multinomial_taylor_approx_realization, get_poisson_realization,\n        get_multinomial_deterministic_realization,\n        get_multinomial_taylor_approx_deterministic_realization,\n        get_poisson_deterministic_realization.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                used to generate random variables and control reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n        \"\"\"\n\n        pass\n\n    def get_multinomial_realization(self,\n                                    RNG: np.random.Generator,\n                                    num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                used to generate random variables and control reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                ((length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    probabilities_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_multinomial_taylor_approx_realization(self,\n                                                  RNG: np.random.Generator,\n                                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution\n        using Taylor Series approximation for probability parameter.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                used to generate random variables and control reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size equal to (length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        current_rates_array = self.get_current_rates_array()\n\n        total_rate = self.get_total_rate()\n\n        # Multiply current rates array by length of time interval (1 / num_timesteps)\n        # Also append additional value corresponding to probability of\n        #   remaining in current epi compartment (not transitioning at all)\n        # Note: \"vstack\" function here works better than append function because append\n        #   automatically flattens the resulting array, resulting in dimension issues\n        current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                                np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    current_scaled_rates_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from Poisson distribution.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                used to generate random variables and control reproducibility.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to length of\n                (outgoing transition variables list x\n                number of age groups x number of risk groups).\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n        transition_variables = self.transition_variables\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                for outflow_ix in range(num_outflows):\n                    realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                        self.origin.current_val[age_group, risk_group] *\n                        transition_variables[outflow_ix].current_rate[\n                            age_group, risk_group] / num_timesteps)\n\n        return realizations_array\n\n    def get_multinomial_deterministic_realization(self,\n                                                  RNG: np.random.Generator,\n                                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to get_multinomial_realization --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                (length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n        return np.asarray(self.origin.current_val * probabilities_array, dtype=int)\n\n    def get_multinomial_taylor_approx_deterministic_realization(self,\n                                                                RNG: np.random.Generator,\n                                                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to get_multinomial_taylor_approx_realization --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                (length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        current_rates_array = self.get_current_rates_array()\n        return np.asarray(self.origin.current_val * current_rates_array / num_timesteps, dtype=int)\n\n    def get_poisson_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to get_poisson_realization --\n        uses mean (rate array) as realization rather than randomly sampling.\n\n        Parameters:\n            RNG (np.random.Generator object):\n                NOT USED -- only included so that get_realization has\n                the same function arguments regardless of transition type.\n            num_timesteps (int):\n                number of timesteps per day -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                (length of outgoing transition variables list\n                x number of age groups x number of risk groups).\n        \"\"\"\n\n        return np.asarray(self.origin.current_val * self.get_current_rates_array() / num_timesteps, dtype=int)\n\n    def reset(self) -&gt; None:\n        self.current_vals_list = []\n\n    def update_transition_variable_realizations(self) -&gt; None:\n        \"\"\"\n        Updates current_val attribute on all\n        TransitionVariable instances contained in this\n        transition variable group.\n        \"\"\"\n\n        # Since the ith element in probabilities_array corresponds to the ith transition variable\n        #   in transition_variables, the ith element in multinomial_realizations_list\n        #   also corresponds to the ith transition variable in transition_variables\n        # Update the current realization of the transition variables contained in this group\n        for ix in range(len(self.transition_variables)):\n            self.transition_variables[ix].current_val = \\\n                self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.__init__","title":"<code>__init__(origin, transition_type, transition_variables)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>transition_type</code> <code>str</code> <p>only values defined in TransitionTypes Enum are valid, specifying probability distribution of transitions between compartments.</p> required <p>See class docstring for other parameters.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def __init__(self,\n             origin,\n             transition_type,\n             transition_variables):\n    \"\"\"\n    Args:\n        transition_type (str):\n            only values defined in TransitionTypes Enum are valid, specifying\n            probability distribution of transitions between compartments.\n\n    See class docstring for other parameters.\n    \"\"\"\n\n    self.origin = origin\n    self.transition_variables = transition_variables\n\n    # If marginal transition type is any kind of binomial transition,\n    #   then its joint transition type is a multinomial counterpart\n    # For example, if the marginal transition type is TransitionTypes.BINOMIAL_DETERMINISTIC,\n    #   then the joint transition type is JointTransitionTypes.MULTINOMIAL_DETERMINISTIC\n    transition_type = transition_type.replace(\"binomial\", \"multinomial\")\n    self._transition_type = transition_type\n\n    # Dynamically assign a method to get_joint_realization attribute\n    #   based on the value of transition_type\n    # getattr fetches a method by name\n    self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_vals_list = []\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_current_rates_array","title":"<code>get_current_rates_array()</code>","text":"<p>Returns an array of current rates of transition variables in self.transition_variables -- ith element in array corresponds to current rate of ith transition variable.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: array of positive floats, size equal to (length of outgoing transition variables list x number of age groups x number of risk groups).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_current_rates_array(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of current rates of transition variables in\n    self.transition_variables -- ith element in array\n    corresponds to current rate of ith transition variable.\n\n    Returns:\n        np.ndarray:\n            array of positive floats, size equal to (length of outgoing\n            transition variables list x number of age groups x number of risk groups).\n    \"\"\"\n\n    current_rates_list = []\n    for tvar in self.transition_variables:\n        current_rates_list.append(tvar.current_rate)\n\n    return np.asarray(current_rates_list)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_joint_realization","title":"<code>get_joint_realization(RNG, num_timesteps)</code>","text":"<p>This function is dynamically assigned based on the Transition Variable Group's transition type -- this function is set to one of the following methods: get_multinomial_realization, get_multinomial_taylor_approx_realization, get_poisson_realization, get_multinomial_deterministic_realization, get_multinomial_taylor_approx_deterministic_realization, get_poisson_deterministic_realization.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_joint_realization(self,\n                          RNG: np.random.Generator,\n                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    This function is dynamically assigned based on the Transition\n    Variable Group's transition type -- this function is set to\n    one of the following methods: get_multinomial_realization,\n    get_multinomial_taylor_approx_realization, get_poisson_realization,\n    get_multinomial_deterministic_realization,\n    get_multinomial_taylor_approx_deterministic_realization,\n    get_poisson_deterministic_realization.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_multinomial_deterministic_realization","title":"<code>get_multinomial_deterministic_realization(RNG, num_timesteps)</code>","text":"<p>Deterministic counterpart to get_multinomial_realization -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to (length of outgoing transition variables list + 1) x number of age groups x number of risk groups -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_multinomial_deterministic_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to get_multinomial_realization --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            (length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n    return np.asarray(self.origin.current_val * probabilities_array, dtype=int)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_multinomial_realization","title":"<code>get_multinomial_realization(RNG, num_timesteps)</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to ((length of outgoing transition variables list + 1) x number of age groups x number of risk groups) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_multinomial_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            ((length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                probabilities_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_multinomial_taylor_approx_deterministic_realization","title":"<code>get_multinomial_taylor_approx_deterministic_realization(RNG, num_timesteps)</code>","text":"<p>Deterministic counterpart to get_multinomial_taylor_approx_realization -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to (length of outgoing transition variables list + 1) x number of age groups x number of risk groups -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_multinomial_taylor_approx_deterministic_realization(self,\n                                                            RNG: np.random.Generator,\n                                                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to get_multinomial_taylor_approx_realization --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            (length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    current_rates_array = self.get_current_rates_array()\n    return np.asarray(self.origin.current_val * current_rates_array / num_timesteps, dtype=int)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_multinomial_taylor_approx_realization","title":"<code>get_multinomial_taylor_approx_realization(RNG, num_timesteps)</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution using Taylor Series approximation for probability parameter.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size equal to (length of outgoing transition variables list + 1) x number of age groups x number of risk groups -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_multinomial_taylor_approx_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution\n    using Taylor Series approximation for probability parameter.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size equal to (length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    current_rates_array = self.get_current_rates_array()\n\n    total_rate = self.get_total_rate()\n\n    # Multiply current rates array by length of time interval (1 / num_timesteps)\n    # Also append additional value corresponding to probability of\n    #   remaining in current epi compartment (not transitioning at all)\n    # Note: \"vstack\" function here works better than append function because append\n    #   automatically flattens the resulting array, resulting in dimension issues\n    current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                            np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                current_scaled_rates_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_poisson_deterministic_realization","title":"<code>get_poisson_deterministic_realization(RNG, num_timesteps)</code>","text":"<p>Deterministic counterpart to get_poisson_realization -- uses mean (rate array) as realization rather than randomly sampling.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>NOT USED -- only included so that get_realization has the same function arguments regardless of transition type.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to (length of outgoing transition variables list x number of age groups x number of risk groups).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_poisson_deterministic_realization(self,\n                                          RNG: np.random.Generator,\n                                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to get_poisson_realization --\n    uses mean (rate array) as realization rather than randomly sampling.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            NOT USED -- only included so that get_realization has\n            the same function arguments regardless of transition type.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            (length of outgoing transition variables list\n            x number of age groups x number of risk groups).\n    \"\"\"\n\n    return np.asarray(self.origin.current_val * self.get_current_rates_array() / num_timesteps, dtype=int)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_poisson_realization","title":"<code>get_poisson_realization(RNG, num_timesteps)</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from Poisson distribution.</p> <p>Parameters:</p> Name Type Description Default <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps per day -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to length of (outgoing transition variables list x number of age groups x number of risk groups).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_poisson_realization(self,\n                            RNG: np.random.Generator,\n                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from Poisson distribution.\n\n    Parameters:\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        num_timesteps (int):\n            number of timesteps per day -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to length of\n            (outgoing transition variables list x\n            number of age groups x number of risk groups).\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n    transition_variables = self.transition_variables\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            for outflow_ix in range(num_outflows):\n                realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                    self.origin.current_val[age_group, risk_group] *\n                    transition_variables[outflow_ix].current_rate[\n                        age_group, risk_group] / num_timesteps)\n\n    return realizations_array\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_probabilities_array","title":"<code>get_probabilities_array(num_timesteps)</code>","text":"<p>Returns an array of probabilities used for joint binomial (multinomial) transitions (get_multinomial_realization method).</p> <p>Returns:</p> Type Description <code>list</code> <p>np.ndarray: contains positive floats &lt;= 1, size equal to ((length of outgoing transition variables list + 1) x number of age groups x number of risk groups) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_probabilities_array(self,\n                            num_timesteps: int) -&gt; list:\n    \"\"\"\n    Returns an array of probabilities used for joint binomial\n    (multinomial) transitions (get_multinomial_realization method).\n\n    Returns:\n        np.ndarray:\n            contains positive floats &lt;= 1, size equal to\n            ((length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    total_rate = self.get_total_rate()\n\n    total_outgoing_probability = approx_binomial_probability_from_rate(total_rate,\n                                                                       1 / num_timesteps)\n\n    # Create probabilities_list, where element i corresponds to the\n    #   transition variable i's current rate divided by the total rate,\n    #   multiplized by the total outgoing probability\n    # This generates the probabilities array that parameterizes the\n    #   multinomial distribution\n    probabilities_list = []\n\n    for transition_variable in self.transition_variables:\n        probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                  total_outgoing_probability)\n\n    # Append the probability that a person stays in the compartment\n    probabilities_list.append(1 - total_outgoing_probability)\n\n    return np.asarray(probabilities_list)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.get_total_rate","title":"<code>get_total_rate()</code>","text":"<p>Return the age-risk-specific total transition rate, which is the sum of the current rate of each transition variable in this transition variable group.</p> <p>Used to properly scale multinomial probabilities vector so that elements sum to 1.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, has size equal to number of age groups x number of risk groups, sum of current rates of transition variables in transition variable group.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def get_total_rate(self) -&gt; np.ndarray:\n    \"\"\"\n    Return the age-risk-specific total transition rate,\n    which is the sum of the current rate of each transition variable\n    in this transition variable group.\n\n    Used to properly scale multinomial probabilities vector so\n    that elements sum to 1.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, has size equal to number\n            of age groups x number of risk groups,\n            sum of current rates of transition variables in\n            transition variable group.\n    \"\"\"\n\n    # axis 0: corresponds to outgoing transition variable\n    # axis 1: corresponds to age groups\n    # axis 2: corresponds to risk groups\n    # --&gt; summing over axis 0 gives the total rate for each age-risk group\n    return np.sum(self.get_current_rates_array(), axis=0)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.TransitionVariableGroup.update_transition_variable_realizations","title":"<code>update_transition_variable_realizations()</code>","text":"<p>Updates current_val attribute on all TransitionVariable instances contained in this transition variable group.</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def update_transition_variable_realizations(self) -&gt; None:\n    \"\"\"\n    Updates current_val attribute on all\n    TransitionVariable instances contained in this\n    transition variable group.\n    \"\"\"\n\n    # Since the ith element in probabilities_array corresponds to the ith transition variable\n    #   in transition_variables, the ith element in multinomial_realizations_list\n    #   also corresponds to the ith transition variable in transition_variables\n    # Update the current realization of the transition variables contained in this group\n    for ix in range(len(self.transition_variables)):\n        self.transition_variables[ix].current_val = \\\n            self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.approx_binomial_probability_from_rate","title":"<code>approx_binomial_probability_from_rate(rate, interval_length)</code>","text":"<p>Converts a rate (events per time) to the probability of any event occurring in the next time interval of length interval_length, assuming the number of events occurring in time interval follows a Poisson distribution with given rate parameter.</p> <p>The probability of 0 events in time_interval_length is e^(-rate * time_interval_length), so the probability of any event in time_interval_length is 1 - e^(-rate * time_interval_length).</p> <p>Rate must be A x L np.ndarray, where A is the number of age groups and L is the number of risk groups. Rate is transformed to A x L np.ndarray corresponding to probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>ndarray</code> <p>dimension A x L (number of age groups x number of risk groups), rate parameters in a Poisson distribution.</p> required <code>interval_length</code> <code>positive int</code> <p>length of time interval in simulation days.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: array of positive scalars, dimension A x L</p> Source code in <code>CLT_BaseModel/clt_base/base_components.py</code> <pre><code>def approx_binomial_probability_from_rate(rate: np.ndarray,\n                                          interval_length: int) -&gt; np.ndarray:\n    \"\"\"\n    Converts a rate (events per time) to the probability of any event\n    occurring in the next time interval of length interval_length,\n    assuming the number of events occurring in time interval\n    follows a Poisson distribution with given rate parameter.\n\n    The probability of 0 events in time_interval_length is\n    e^(-rate * time_interval_length), so the probability of any event\n    in time_interval_length is 1 - e^(-rate * time_interval_length).\n\n    Rate must be A x L np.ndarray, where A is the number of age groups\n    and L is the number of risk groups. Rate is transformed to\n    A x L np.ndarray corresponding to probabilities.\n\n    Parameters:\n        rate (np.ndarray):\n            dimension A x L (number of age groups x number of risk groups),\n            rate parameters in a Poisson distribution.\n        interval_length (positive int):\n            length of time interval in simulation days.\n\n    Returns:\n        np.ndarray: array of positive scalars, dimension A x L\n    \"\"\"\n\n    return 1 - np.exp(-rate * interval_length)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.convert_dict_vals_lists_to_arrays","title":"<code>convert_dict_vals_lists_to_arrays(d)</code>","text":"Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>def convert_dict_vals_lists_to_arrays(d: dict) -&gt; dict:\n\n    # convert lists to numpy arrays to support numpy operations\n    for key, val in d.items():\n        if type(val) is list:\n            d[key] = np.asarray(val)\n\n    return d\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.create_basic_compartment_history_plot","title":"<code>create_basic_compartment_history_plot(sim_model, savefig_filename=None)</code>","text":"Source code in <code>CLT_BaseModel/clt_base/plotting.py</code> <pre><code>def create_basic_compartment_history_plot(sim_model,\n                                          savefig_filename=None):\n    plt.clf()\n    plt.figure(1)\n    for name, compartment in sim_model.compartments.items():\n        history_vals_list = [np.sum(age_risk_group_entry) for age_risk_group_entry in compartment.history_vals_list]\n        plt.plot(history_vals_list, label=name, alpha=0.6)\n    plt.legend()\n    plt.xlabel(\"Days\")\n    plt.ylabel(\"Number of individuals\")\n\n    if savefig_filename:\n        plt.savefig(savefig_filename, dpi=1200)\n\n    plt.show()\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.load_json","title":"<code>load_json(json_filepath)</code>","text":"Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>def load_json(json_filepath: str) -&gt; dict:\n\n    # Note: the \"with open\" is important for file handling\n    #   and avoiding resource leaks -- otherwise,\n    #   we have to manually close the file, which is a bit\n    #   more cumbersome\n    with open(json_filepath, 'r') as file:\n        data = json.load(file)\n\n    # json does not support numpy, so we must convert\n    #   lists to numpy arrays\n    return convert_dict_vals_lists_to_arrays(data)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.make_dataclass_from_dict","title":"<code>make_dataclass_from_dict(dataclass_ref, d)</code>","text":"<p>Create instance of class dataclass_ref, based on information in dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>dataclass_ref</code> <code>Type[DataClassProtocol]</code> <p>(class, not instance) from which to create instance -- must have dataclass decorator.</p> required <code>d</code> <code>dict</code> <p>all keys and values respectively must match name and datatype of dataclass_ref instance attributes.</p> required <p>Returns:</p> Name Type Description <code>DataClassProtocol</code> <code>DataClassProtocol</code> <p>instance of dataclass_ref with attributes dynamically assigned by json_filepath file contents.</p> Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>def make_dataclass_from_dict(dataclass_ref: Type[DataClassProtocol],\n                             d: dict) -&gt; DataClassProtocol:\n    \"\"\"\n    Create instance of class dataclass_ref,\n    based on information in dictionary.\n\n    Args:\n        dataclass_ref (Type[DataClassProtocol]):\n            (class, not instance) from which to create instance --\n            must have dataclass decorator.\n        d (dict):\n            all keys and values respectively must match name and datatype\n            of dataclass_ref instance attributes.\n\n    Returns:\n        DataClassProtocol:\n            instance of dataclass_ref with attributes dynamically\n            assigned by json_filepath file contents.\n    \"\"\"\n\n    d = convert_dict_vals_lists_to_arrays(d)\n\n    return dataclass_ref(**d)\n</code></pre>"},{"location":"base_components_reference/#CLT_BaseModel.clt_base.make_dataclass_from_json","title":"<code>make_dataclass_from_json(dataclass_ref, json_filepath)</code>","text":"<p>Create instance of class dataclass_ref, based on information in json_filepath.</p> <p>Parameters:</p> Name Type Description Default <code>dataclass_ref</code> <code>Type[DataClassProtocol]</code> <p>(class, not instance) from which to create instance -- must have dataclass decorator.</p> required <code>json_filepath</code> <code>str</code> <p>path to json file (path includes actual filename with suffix \".json\") -- all json fields must match name and datatype of dataclass_ref instance attributes.</p> required <p>Returns:</p> Name Type Description <code>DataClassProtocol</code> <code>DataClassProtocol</code> <p>instance of dataclass_ref with attributes dynamically assigned by json_filepath file contents.</p> Source code in <code>CLT_BaseModel/clt_base/input_parsers.py</code> <pre><code>def make_dataclass_from_json(dataclass_ref: Type[DataClassProtocol],\n                             json_filepath: str) -&gt; DataClassProtocol:\n    \"\"\"\n    Create instance of class dataclass_ref,\n    based on information in json_filepath.\n\n    Args:\n        dataclass_ref (Type[DataClassProtocol]):\n            (class, not instance) from which to create instance --\n            must have dataclass decorator.\n        json_filepath (str):\n            path to json file (path includes actual filename\n            with suffix \".json\") -- all json fields must\n            match name and datatype of dataclass_ref instance\n            attributes.\n\n    Returns:\n        DataClassProtocol:\n            instance of dataclass_ref with attributes dynamically\n            assigned by json_filepath file contents.\n    \"\"\"\n\n    d = load_json(json_filepath)\n\n    return make_dataclass_from_dict(dataclass_ref, d)\n</code></pre>"},{"location":"flu_code_quickstart/","title":"Flu Code Quickstart","text":"<p>This page is getting updated, please check back soon! </p>"},{"location":"flu_components_reference/","title":"Flu Components Code API Reference","text":"<p>Docstrings and references for <code>flu_components.py</code>.</p>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.base_path","title":"<code>base_path = Path(__file__).parent.parent / 'flu_demo_input_files'</code>  <code>module-attribute</code>","text":""},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.AbsoluteHumidity","title":"<code>AbsoluteHumidity</code>","text":"<p>               Bases: <code>Schedule</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class AbsoluteHumidity(clt.Schedule):\n    def update_current_val(self, current_date: datetime.date) -&gt; None:\n        self.current_val = absolute_humidity_func(current_date)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.AsympToRecovered","title":"<code>AsympToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class AsympToRecovered(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        return np.full((fixed_params.num_age_groups, fixed_params.num_risk_groups),\n                       fixed_params.IA_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.BetaReduct","title":"<code>BetaReduct</code>","text":"<p>               Bases: <code>DynamicVal</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class BetaReduct(clt.DynamicVal):\n\n    def __init__(self, init_val, is_enabled):\n        super().__init__(init_val, is_enabled)\n        self.permanent_lockdown = False\n\n    def update_current_val(self, sim_state, fixed_params):\n        if np.sum(sim_state.I) / np.sum(fixed_params.total_pop_age_risk) &gt; 0.05:\n            self.current_val = .5\n            self.permanent_lockdown = True\n        else:\n            if not self.permanent_lockdown:\n                self.current_val = 0.0\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.ExposedToAsymp","title":"<code>ExposedToAsymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class ExposedToAsymp(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        return np.full((fixed_params.num_age_groups, fixed_params.num_risk_groups),\n                       fixed_params.E_to_I_rate * fixed_params.E_to_IA_prop)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.ExposedToPresymp","title":"<code>ExposedToPresymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class ExposedToPresymp(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        return np.full((fixed_params.num_age_groups, fixed_params.num_risk_groups),\n                       fixed_params.E_to_I_rate * (1 - fixed_params.E_to_IA_prop))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluContactMatrix","title":"<code>FluContactMatrix</code>","text":"<p>               Bases: <code>Schedule</code></p> <p>Attributes:</p> Name Type Description <code>timeseries_df</code> <code>DataFrame</code> <p>has a \"date\" column with strings in format \"YYYY-MM-DD\" of consecutive calendar days, and other columns named \"is_school_day\" (bool) and \"is_work_day\" (bool) corresponding to type of day.</p> <code>total_contact_matrix</code> <code>ndarray</code> <p>(A x L) x (A x L) np.ndarray, where A is the number of age groups and L is the number of risk groups.</p> <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class FluContactMatrix(clt.Schedule):\n    \"\"\"\n    Attributes:\n        timeseries_df (pd.DataFrame):\n            has a \"date\" column with strings in format \"YYYY-MM-DD\"\n            of consecutive calendar days, and other columns\n            named \"is_school_day\" (bool) and \"is_work_day\" (bool)\n            corresponding to type of day.\n        total_contact_matrix (np.ndarray):\n            (A x L) x (A x L) np.ndarray, where A is the number\n            of age groups and L is the number of risk groups.\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 init_val: Optional[Union[np.ndarray, float]] = None):\n        super().__init__(init_val)\n\n        df = pd.read_csv(base_path / \"school_work_calendar.csv\", index_col=0)\n        df[\"date\"] = pd.to_datetime(df[\"date\"]).dt.date\n\n        self.time_series_df = df\n\n        self.total_contact_matrix = np.array([[2.5, 0.5], [2, 1.5]]).reshape((2, 1, 2, 1))\n        self.school_contact_matrix = np.array([[0.5, 0], [0.05, 0.1]]).reshape((2, 1, 2, 1))\n        self.work_contact_matrix = np.array([[0, 0], [0, 0.0]]).reshape((2, 1, 2, 1))\n\n    def update_current_val(self, current_date: datetime.date) -&gt; None:\n        \"\"\"\n        Subclasses must provide a concrete implementation of\n        updating self.current_val in-place\n\n        Args:\n            current_date (datetime.date):\n                real-world date corresponding to\n                model's current simulation day\n        \"\"\"\n\n        df = self.time_series_df\n\n        try:\n            current_row = df[df[\"date\"] == current_date].iloc[0]\n        except IndexError:\n            print(f\"Error: {current_date} is not in the Calendar's time_series_df.\")\n\n        self.current_val = self.total_contact_matrix - \\\n                           (1 - current_row[\"is_school_day\"]) * self.school_contact_matrix - \\\n                           (1 - current_row[\"is_work_day\"]) * self.work_contact_matrix\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluContactMatrix.update_current_val","title":"<code>update_current_val(current_date)</code>","text":"<p>Subclasses must provide a concrete implementation of updating self.current_val in-place</p> <p>Parameters:</p> Name Type Description Default <code>current_date</code> <code>date</code> <p>real-world date corresponding to model's current simulation day</p> required Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def update_current_val(self, current_date: datetime.date) -&gt; None:\n    \"\"\"\n    Subclasses must provide a concrete implementation of\n    updating self.current_val in-place\n\n    Args:\n        current_date (datetime.date):\n            real-world date corresponding to\n            model's current simulation day\n    \"\"\"\n\n    df = self.time_series_df\n\n    try:\n        current_row = df[df[\"date\"] == current_date].iloc[0]\n    except IndexError:\n        print(f\"Error: {current_date} is not in the Calendar's time_series_df.\")\n\n    self.current_val = self.total_contact_matrix - \\\n                       (1 - current_row[\"is_school_day\"]) * self.school_contact_matrix - \\\n                       (1 - current_row[\"is_work_day\"]) * self.work_contact_matrix\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluFixedParams","title":"<code>FluFixedParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FixedParams</code></p> <p>Data container for pre-specified and fixed epidemiological parameters in FluModel flu model. Along with FluSimState, is passed to get_current_rate and get_change_in_current_val.</p> <p>Assume that FluFixedParams fields are constant or piecewise constant throughout the simulation. For variables that are more complicated and time-dependent, use a EpiMetric instead.</p> <p>Each field of datatype np.ndarray must be A x L, where A is the number of age groups and L is the number of risk groups. Note: this means all arrays should be 2D. See FluSimState docstring for important formatting note on 2D arrays.</p> TODO <p>when adding multiple strains, need to add subscripts to math of attributes and add strain-specific description</p> <p>Attributes:</p> Name Type Description <code>num_age_groups</code> <code>positive int</code> <p>number of age groups.</p> <code>num_risk_groups</code> <code>positive int</code> <p>number of risk groups.</p> <code>beta_baseline</code> <code>positive float</code> <p>transmission rate.</p> <code>total_pop_age_risk</code> <code>np.ndarray of positive ints</code> <p>total number in population, summed across all age-risk groups.</p> <code>humidity_impact</code> <code>positive float</code> <p>coefficient that determines how much absolute humidity affects beta_baseline.</p> <code>immunity_hosp_increase_factor</code> <code>positive float</code> <p>factor by which population-level immunity against hospitalization grows after each case that recovers.</p> <code>immunity_inf_increase_factor</code> <code>positive float</code> <p>factor by which population-level immunity against infection grows after each case     that recovers.</p> <code>immunity_saturation</code> <code>np.ndarray of positive floats</code> <p>constant(s) modeling saturation of antibody production of individuals.</p> <code>waning_factor_hosp</code> <code>positive float</code> <p>rate at which infection-induced immunity against hospitalization wanes.</p> <code>waning_factor_inf</code> <code>positive float</code> <p>rate at which infection-induced immunity against infection wanes.</p> <code>hosp_risk_reduction</code> <code>positive float in [0,1]</code> <p>reduction in hospitalization risk from infection-induced immunity.</p> <code>inf_risk_reduction</code> <code>positive float in [0,1]</code> <p>reduction in infection risk from infection-induced immunity.</p> <code>death_risk_reduction</code> <code>positive float in [0,1]</code> <p>reduction in death risk from infection-induced immunity.</p> <code>R_to_S_rate</code> <code>positive float</code> <p>rate at which people in R move to S.</p> <code>E_to_I_rate</code> <code>positive float</code> <p>rate at which people in E move to I (both IP and IA, infected pre-symptomatic and infected asymptomatic)</p> <code>IP_to_IS_rate</code> <code>positive float</code> <p>rate a which people in IP (infected pre-symptomatic) move to IS (infected symptomatic)</p> <code>IS_to_R_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to R.</p> <code>IA_to_R_rate</code> <code>positive float</code> <p>rate at which people in IA (infected asymptomatic) move to R</p> <code>IS_to_H_rate</code> <code>positive float</code> <p>rate at which people in IS (infected symptomatic) move to H.</p> <code>H_to_R_rate</code> <code>positive float</code> <p>rate at which people in H move to R.</p> <code>H_to_D_rate</code> <code>positive float</code> <p>rate at which people in H move to D.</p> <code>E_to_IA_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>proportion exposed who are asymptomatic based on age-risk groups.</p> <code>IS_to_H_adjusted_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion infected who are hospitalized based on age-risk groups.</p> <code>H_to_D_adjusted_prop</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion hospitalized who die based on age-risk groups.</p> <code>IP_relative_inf</code> <code>positive float</code> <p>relative infectiousness of pre-symptomatic to symptomatic people (IP to IS compartment).</p> <code>IA_relative_inf</code> <code>positive float</code> <p>relative infectiousness of asymptomatic to symptomatic people (IA to IS compartment).</p> <code>viral_shedding_peak</code> <code>positive float</code> <p>the peak time of an individual's viral shedding.</p> <code>viral_shedding_magnitude</code> <code>positive float</code> <p>magnitude of the viral shedding.</p> <code>viral_shedding_duration</code> <code>positive float</code> <p>duration of the viral shedding, must be larger than viral_shedding_peak</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>@dataclass\nclass FluFixedParams(clt.FixedParams):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in FluModel flu model. Along with FluSimState,\n    is passed to get_current_rate and get_change_in_current_val.\n\n    Assume that FluFixedParams fields are constant or piecewise\n    constant throughout the simulation. For variables that\n    are more complicated and time-dependent, use a EpiMetric\n    instead.\n\n    Each field of datatype np.ndarray must be A x L,\n    where A is the number of age groups and L is the number of\n    risk groups. Note: this means all arrays should be 2D.\n    See FluSimState docstring for important formatting note\n    on 2D arrays.\n\n    TODO:\n        when adding multiple strains, need to add subscripts\n        to math of attributes and add strain-specific description\n\n    Attributes:\n        num_age_groups (positive int):\n            number of age groups.\n        num_risk_groups (positive int):\n            number of risk groups.\n        beta_baseline (positive float): transmission rate.\n        total_pop_age_risk (np.ndarray of positive ints):\n            total number in population, summed across all\n            age-risk groups.\n        humidity_impact (positive float):\n            coefficient that determines how much absolute\n            humidity affects beta_baseline.\n        immunity_hosp_increase_factor (positive float):\n            factor by which population-level immunity\n            against hospitalization grows after each\n            case that recovers.\n        immunity_inf_increase_factor (positive float):\n            factor by which population-level immunity\n            against infection grows after each case\n                that recovers.\n        immunity_saturation (np.ndarray of positive floats):\n            constant(s) modeling saturation of antibody\n            production of individuals.\n        waning_factor_hosp (positive float):\n            rate at which infection-induced immunity\n            against hospitalization wanes.\n        waning_factor_inf (positive float):\n            rate at which infection-induced immunity\n            against infection wanes.\n        hosp_risk_reduction (positive float in [0,1]):\n            reduction in hospitalization risk from\n            infection-induced immunity.\n        inf_risk_reduction (positive float in [0,1]):\n            reduction in infection risk\n            from infection-induced immunity.\n        death_risk_reduction (positive float in [0,1]):\n            reduction in death risk from infection-induced immunity.\n        R_to_S_rate (positive float):\n            rate at which people in R move to S.\n        E_to_I_rate (positive float):\n            rate at which people in E move to I (both\n            IP and IA, infected pre-symptomatic and infected\n            asymptomatic)\n        IP_to_IS_rate (positive float):\n            rate a which people in IP (infected pre-symptomatic)\n            move to IS (infected symptomatic)\n        IS_to_R_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to R.\n        IA_to_R_rate (positive float):\n            rate at which people in IA (infected asymptomatic)\n            move to R\n        IS_to_H_rate (positive float):\n            rate at which people in IS (infected symptomatic)\n            move to H.\n        H_to_R_rate (positive float):\n            rate at which people in H move to R.\n        H_to_D_rate (positive float):\n            rate at which people in H move to D.\n        E_to_IA_prop (np.ndarray of positive floats in [0,1]):\n            proportion exposed who are asymptomatic based on\n            age-risk groups.\n        IS_to_H_adjusted_prop (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion infected who are hospitalized\n            based on age-risk groups.\n        H_to_D_adjusted_prop (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion hospitalized who die based on\n            age-risk groups.\n        IP_relative_inf (positive float):\n            relative infectiousness of pre-symptomatic to symptomatic\n            people (IP to IS compartment).\n        IA_relative_inf (positive float):\n            relative infectiousness of asymptomatic to symptomatic\n            people (IA to IS compartment).\n        viral_shedding_peak (positive float):\n            the peak time of an individual's viral shedding.\n        viral_shedding_magnitude (positive float):\n            magnitude of the viral shedding.\n        viral_shedding_duration (positive float):\n            duration of the viral shedding,\n            must be larger than viral_shedding_peak\n        viral_shedding_feces_mass (positive float)\n            average mass of feces (gram)\n    \"\"\"\n\n    num_age_groups: Optional[int] = None\n    num_risk_groups: Optional[int] = None\n    beta_baseline: Optional[float] = None\n    total_pop_age_risk: Optional[np.ndarray] = None\n    humidity_impact: Optional[float] = None\n    immunity_hosp_increase_factor: Optional[float] = None\n    immunity_inf_increase_factor: Optional[float] = None\n    immunity_saturation: Optional[np.ndarray] = None\n    waning_factor_hosp: Optional[float] = None\n    waning_factor_inf: Optional[float] = None\n    hosp_risk_reduction: Optional[float] = None\n    inf_risk_reduction: Optional[float] = None\n    death_risk_reduction: Optional[float] = None\n    R_to_S_rate: Optional[float] = None\n    E_to_I_rate: Optional[float] = None\n    IP_to_IS_rate: Optional[float] = None\n    IS_to_R_rate: Optional[float] = None\n    IA_to_R_rate: Optional[float] = None\n    IS_to_H_rate: Optional[float] = None\n    H_to_R_rate: Optional[float] = None\n    H_to_D_rate: Optional[float] = None\n    E_to_IA_prop: Optional[np.ndarray] = None\n    IS_to_H_adjusted_prop: Optional[np.ndarray] = None\n    H_to_D_adjusted_prop: Optional[np.ndarray] = None\n    IP_relative_inf: Optional[float] = None\n    IA_relative_inf: Optional[float] = None\n    viral_shedding_peak: Optional[float] = None  # viral shedding parameters\n    viral_shedding_magnitude: Optional[float] = None  # viral shedding parameters\n    viral_shedding_duration: Optional[float] = None  # viral shedding parameters\n    viral_shedding_feces_mass: Optional[float] = None  # viral shedding parameters\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSimState","title":"<code>FluSimState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SimState</code></p> <p>Data container for pre-specified and fixed set of Compartment initial values and EpiMetric initial values in FluModel flu model.</p> <p>Each field below should be A x L np.ndarray, where A is the number of age groups and L is the number of risk groups. Note: this means all arrays should be 2D. Even if there is 1 age group and 1 risk group (no group stratification), each array should be 1x1, which is two-dimensional. For example, np.array([[100]]) is correct -- np.array([100]) is wrong.</p> <p>Attributes:</p> Name Type Description <code>S</code> <code>np.ndarray of positive floats</code> <p>susceptible compartment for age-risk groups -- (holds current_val of Compartment \"S\").</p> <code>E</code> <code>np.ndarray of positive floats</code> <p>exposed compartment for age-risk groups -- (holds current_val of Compartment \"E\").</p> <code>IP</code> <code>np.ndarray of positive floats</code> <p>infected pre-symptomatic compartment for age-risk groups (holds current_val of Compartment \"IP\").</p> <code>IS</code> <code>np.ndarray of positive floats</code> <p>infected symptomatic compartment for age-risk groups (holds current_val of Compartment \"IS\").</p> <code>IA</code> <code>np.ndarray of positive floats</code> <p>infected asymptomatic compartment for age-risk groups (holds current_val of Compartment \"IA\").</p> <code>H</code> <code>np.ndarray of positive floats</code> <p>hospital compartment for age-risk groups (holds current_val of Compartment \"H\").</p> <code>R</code> <code>np.ndarray of positive floats</code> <p>recovered compartment for age-risk groups (holds current_val of Compartment \"R\").</p> <code>D</code> <code>np.ndarray of positive floats</code> <p>dead compartment for age-risk groups (holds current_val of Compartment \"D\").</p> <code>pop_immunity_hosp</code> <code>np.ndarray of positive floats</code> <p>infection-induced population-level immunity against hospitalization, for age-risk groups (holds current_val of EpiMetric \"pop_immunity_hosp\").</p> <code>pop_immunity_inf</code> <code>np.ndarray of positive floats</code> <p>infection-induced population-level immunity against infection, for age-risk groups (holds current_val of EpiMetric \"pop_immunity_inf\").</p> <code>absolute_humidity</code> <code>positive float</code> <p>grams of water vapor per cubic meter g/m^3, used as seasonality parameter that influences transmission rate beta_baseline.</p> <code>flu_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x L x A x L array, where A is the number of age groups and L is the number of risk groups -- element (a, l, a', l') corresponds to the number of contacts that a person in age-risk group a,l has with people in age-risk group a', l'.</p> <code>beta_reduct</code> <code>float in [0, 1]</code> <p>starting value of DynamicVal \"beta_reduct\" on starting day of simulation -- this DynamicVal emulates a simple staged-alert policy</p> <code>wastewater</code> <code>np.ndarray of positive floats</code> <p>wastewater viral load</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>@dataclass\nclass FluSimState(clt.SimState):\n    \"\"\"\n    Data container for pre-specified and fixed set of\n    Compartment initial values and EpiMetric initial values\n    in FluModel flu model.\n\n    Each field below should be A x L np.ndarray, where\n    A is the number of age groups and L is the number of risk groups.\n    Note: this means all arrays should be 2D. Even if there is\n    1 age group and 1 risk group (no group stratification),\n    each array should be 1x1, which is two-dimensional.\n    For example, np.array([[100]]) is correct --\n    np.array([100]) is wrong.\n\n    Attributes:\n        S (np.ndarray of positive floats):\n            susceptible compartment for age-risk groups --\n            (holds current_val of Compartment \"S\").\n        E (np.ndarray of positive floats):\n            exposed compartment for age-risk groups --\n            (holds current_val of Compartment \"E\").\n        IP (np.ndarray of positive floats):\n            infected pre-symptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IP\").\n        IS (np.ndarray of positive floats):\n            infected symptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IS\").\n        IA (np.ndarray of positive floats):\n            infected asymptomatic compartment for age-risk groups\n            (holds current_val of Compartment \"IA\").\n        H (np.ndarray of positive floats):\n            hospital compartment for age-risk groups\n            (holds current_val of Compartment \"H\").\n        R (np.ndarray of positive floats):\n            recovered compartment for age-risk groups\n            (holds current_val of Compartment \"R\").\n        D (np.ndarray of positive floats):\n            dead compartment for age-risk groups\n            (holds current_val of Compartment \"D\").\n        pop_immunity_hosp (np.ndarray of positive floats):\n            infection-induced population-level immunity against\n            hospitalization, for age-risk groups (holds current_val\n            of EpiMetric \"pop_immunity_hosp\").\n        pop_immunity_inf (np.ndarray of positive floats):\n            infection-induced population-level immunity against\n            infection, for age-risk groups (holds current_val\n            of EpiMetric \"pop_immunity_inf\").\n        absolute_humidity (positive float):\n            grams of water vapor per cubic meter g/m^3,\n            used as seasonality parameter that influences\n            transmission rate beta_baseline.\n        flu_contact_matrix (np.ndarray of positive floats):\n            A x L x A x L array, where A is the number of age\n            groups and L is the number of risk groups --\n            element (a, l, a', l') corresponds to the number of\n            contacts that a person in age-risk group a,l\n            has with people in age-risk group a', l'.\n        beta_reduct (float in [0,1]):\n            starting value of DynamicVal \"beta_reduct\" on\n            starting day of simulation -- this DynamicVal\n            emulates a simple staged-alert policy\n        wastewater (np.ndarray of positive floats):\n            wastewater viral load\n    \"\"\"\n\n    S: Optional[np.ndarray] = None\n    E: Optional[np.ndarray] = None\n    IP: Optional[np.ndarray] = None\n    IS: Optional[np.ndarray] = None\n    IA: Optional[np.ndarray] = None\n    H: Optional[np.ndarray] = None\n    R: Optional[np.ndarray] = None\n    D: Optional[np.ndarray] = None\n    pop_immunity_hosp: Optional[np.ndarray] = None\n    pop_immunity_inf: Optional[np.ndarray] = None\n    absolute_humidity: Optional[float] = None\n    flu_contact_matrix: Optional[np.ndarray] = None\n    beta_reduct: Optional[float] = 0.0\n    wastewater: Optional[np.ndarray] = None  # wastewater viral load\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel","title":"<code>FluSubpopModel</code>","text":"<p>               Bases: <code>SubpopModel</code></p> <p>Class for creating ImmunoSEIRS flu model with predetermined fixed structure -- initial values and epidemiological structure are populated by user-specified JSON files.</p> <p>Key method create_transmission_model returns a SubpopModel instance with S-E-I-H-R-D compartments and pop_immunity_inf and pop_immunity_hosp epi metrics. </p> The structure is as follows <ul> <li>S = R_to_S - S_to_E</li> <li>E = S_to_E - E_to_IP - E_to_IA</li> <li>I = new_infected - IS_to_R - IS_to_H</li> <li>H = IS_to_H - H_to_R - H_to_D</li> <li>R = IS_to_R + H_to_R - R_to_S</li> <li>D = H_to_D</li> </ul> The following are TransitionVariable instances <ul> <li>R_to_S is a RecoveredToSusceptible instance</li> <li>S_to_E is a SusceptibleToExposed instance</li> <li>IP_to_IS is a PresympToSymp instance</li> <li>IS_to_H is a SympToHosp instance</li> <li>IS_to_R is a SympToRecovered instance</li> <li>H_to_R is a HospToRecovered instance</li> <li>H_to_D is a HospToDead instance</li> </ul> There are three TransitionVariableGroups <ul> <li>E_out (handles E_to_IP and E_to_IA)</li> <li>IS_out (handles IS_to_H and IS_to_R)</li> <li>H_out (handles H_to_R and H_to_D)</li> </ul> The following are EpiMetric instances <ul> <li>pop_immunity_inf is a PopulationImmunityInf instance</li> <li>pop_immunity_hosp is a PopulationImmunityHosp instance</li> </ul> <p>Transition rates and update formulas are specified in     corresponding classes.</p> <p>See parent class SubpopModel's docstring for additional attributes.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class FluSubpopModel(clt.SubpopModel):\n    \"\"\"\n    Class for creating ImmunoSEIRS flu model with predetermined fixed\n    structure -- initial values and epidemiological structure are\n    populated by user-specified JSON files.\n\n    Key method create_transmission_model returns a SubpopModel\n    instance with S-E-I-H-R-D compartments and pop_immunity_inf\n    and pop_immunity_hosp epi metrics. \n\n    The structure is as follows:\n        - S = R_to_S - S_to_E\n        - E = S_to_E - E_to_IP - E_to_IA\n        - I = new_infected - IS_to_R - IS_to_H\n        - H = IS_to_H - H_to_R - H_to_D\n        - R = IS_to_R + H_to_R - R_to_S\n        - D = H_to_D\n\n    The following are TransitionVariable instances:\n        - R_to_S is a RecoveredToSusceptible instance\n        - S_to_E is a SusceptibleToExposed instance\n        - IP_to_IS is a PresympToSymp instance\n        - IS_to_H is a SympToHosp instance\n        - IS_to_R is a SympToRecovered instance\n        - H_to_R is a HospToRecovered instance\n        - H_to_D is a HospToDead instance\n\n    There are three TransitionVariableGroups:\n        - E_out (handles E_to_IP and E_to_IA)\n        - IS_out (handles IS_to_H and IS_to_R)\n        - H_out (handles H_to_R and H_to_D)\n\n    The following are EpiMetric instances:\n        - pop_immunity_inf is a PopulationImmunityInf instance\n        - pop_immunity_hosp is a PopulationImmunityHosp instance\n\n    Transition rates and update formulas are specified in\n        corresponding classes.\n\n    See parent class SubpopModel's docstring for additional attributes.\n    \"\"\"\n\n    def __init__(self,\n                 sim_state_dict: dict,\n                 fixed_params_dict: dict,\n                 config_dict: dict,\n                 RNG: np.random.Generator,\n                 wastewater_enabled: bool=False):\n        \"\"\"\n        Args:\n            sim_state_dict (dict):\n                holds current simulation state information,\n                such as current values of epidemiological compartments\n                and epi metrics -- keys and values respectively\n                must match field names and format of FluSimState.\n            fixed_params_dict (dict):\n                holds epidemiological parameter values -- keys and\n                values respectively must match field names and\n                format of FluFixedParams.\n            config_dict (dict):\n                holds configuration values -- keys and values\n                respectively must match field names and format of\n                Config.\n            RNG (np.random.Generator):\n                numpy random generator object used to obtain\n                random numbers.\n            wastewater_enabled (bool):\n                if True, includes \"wastewater\" EpiMetric. Otherwise,\n                excludes it.\n        \"\"\"\n\n        # Assign config, fixed_params, and sim_state to model-specific\n        # types of dataclasses that have epidemiological parameter information\n        # and sim state information\n\n        self.wastewater_enabled = wastewater_enabled\n\n        sim_state = clt.make_dataclass_from_dict(FluSimState, sim_state_dict)\n        fixed_params = clt.make_dataclass_from_dict(FluFixedParams, fixed_params_dict)\n        config = clt.make_dataclass_from_dict(clt.Config, config_dict)\n\n        # IMPORTANT NOTE: as always, we must be careful with mutable objects\n        #   and generally use deep copies to avoid modification of the same\n        #   object. But in this function call, using deep copies is unnecessary\n        #   (redundant) because the parent class SubpopModel's __init__()\n        #   creates deep copies.\n        super().__init__(sim_state, fixed_params, config, RNG)\n\n    def create_compartments(self) -&gt; sc.objdict:\n        \"\"\"\n        Create Compartment instances S-E-I-H-R-D (6 compartments total),\n            save in sc.objdict, and return objdict\n        \"\"\"\n\n        compartments = sc.objdict()\n\n        for name in (\"S\", \"E\", \"IP\", \"IS\", \"IA\", \"H\", \"R\", \"D\"):\n            compartments[name] = clt.Compartment(getattr(self.sim_state, name))\n\n        return compartments\n\n    def create_dynamic_vals(self) -&gt; sc.objdict:\n        \"\"\"\n        Create all DynamicVal instances, save in sc.objdict, and return objdict\n        \"\"\"\n\n        dynamic_vals = sc.objdict()\n\n        dynamic_vals[\"beta_reduct\"] = BetaReduct(init_val=0.0,\n                                                 is_enabled=False)\n\n        return dynamic_vals\n\n    def create_schedules(self) -&gt; sc.objdict():\n        \"\"\"\n        Create all Schedule instances, save in sc.objdict, and return objdict\n        \"\"\"\n\n        schedules = sc.objdict()\n\n        schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n        schedules[\"flu_contact_matrix\"] = FluContactMatrix()\n\n        return schedules\n\n    def create_transition_variables(self) -&gt; sc.objdict:\n        \"\"\"\n        Create all TransitionVariable instances (7 transition variables total),\n            save in sc.objdict, and return objdict\n        \"\"\"\n\n        # NOTE: see the parent class SubpopModel's __init__() --\n        #   create_transition_variables is called after\n        #   self.config is assigned and after self.compartments\n        #   has been created -- so these variables do exist\n        # TODO: there is potentially a better way to design this\n        #   (in SubpopModel) to be more EXPLICIT -- think about this...\n        transition_type = self.config.transition_type\n        compartments = self.compartments\n\n        transition_variables = sc.objdict()\n\n        S = compartments.S\n        E = compartments.E\n        IP = compartments.IP\n        IS = compartments.IS\n        IA = compartments.IA\n        H = compartments.H\n        R = compartments.R\n        D = compartments.D\n\n        transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n        transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n        transition_variables.IP_to_IS = PresympToSymp(IP, IS, transition_type)\n        transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n        transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n        transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n        transition_variables.IS_to_R = SympToRecovered(IS, R, transition_type, True)\n        transition_variables.IS_to_H = SympToHosp(IS, H, transition_type, True)\n        transition_variables.H_to_R = HospToRecovered(H, R, transition_type, True)\n        transition_variables.H_to_D = HospToDead(H, D, transition_type, True)\n\n        return transition_variables\n\n    def create_transition_variable_groups(self) -&gt; sc.objdict:\n        \"\"\"\n        Create all transition variable groups described in docstring (2 transition\n        variable groups total), save in sc.objdict, return\n        \"\"\"\n\n        # Shortcuts for attribute access\n        # NOTE: see the parent class SubpopModel's __init__() --\n        #   create_transition_variable_groups is called after\n        #   self.config is assigned and after\n        #   self.compartments and self.transition_variables are created\n        #   -- so these variables do exist\n        # See similar NOTE in create_transition_variables function\n        transition_type = self.config.transition_type\n        compartments = self.compartments\n        transition_variables = self.transition_variables\n\n        transition_variable_groups = sc.objdict()\n\n        transition_variable_groups.E_out = clt.TransitionVariableGroup(compartments.E,\n                                                                       transition_type,\n                                                                       (transition_variables.E_to_IP,\n                                                                        transition_variables.E_to_IA))\n\n        transition_variable_groups.IS_out = clt.TransitionVariableGroup(compartments.IS,\n                                                                        transition_type,\n                                                                        (transition_variables.IS_to_R,\n                                                                         transition_variables.IS_to_H))\n\n        transition_variable_groups.H_out = clt.TransitionVariableGroup(compartments.H,\n                                                                       transition_type,\n                                                                       (transition_variables.H_to_R,\n                                                                        transition_variables.H_to_D))\n\n        return transition_variable_groups\n\n    def create_epi_metrics(self) -&gt; sc.objdict:\n        \"\"\"\n        Create all epi metric described in docstring (2 state\n        variables total), save in sc.objdict, and return objdict\n        \"\"\"\n\n        epi_metrics = sc.objdict()\n\n        # Shortcuts for attribute access\n        # NOTE: see the parent class SubpopModel's __init__() --\n        #   create_epi_metrics is called after self.transition_variables\n        #   are created -- so this variable exists\n        # See similar NOTE in create_transition_variables\n        #   and create_transition_variable_groups function\n        transition_variables = self.transition_variables\n\n        epi_metrics.pop_immunity_inf = \\\n            PopulationImmunityInf(getattr(self.sim_state, \"pop_immunity_inf\"),\n                                  transition_variables.R_to_S)\n\n        if self.wastewater_enabled:\n            epi_metrics.wastewater = \\\n                Wastewater(getattr(self.sim_state, \"wastewater\"),  # initial value is set to null for now\n                           transition_variables.S_to_E)\n\n        epi_metrics.pop_immunity_hosp = \\\n            PopulationImmunityHosp(getattr(self.sim_state, \"pop_immunity_hosp\"),\n                                   transition_variables.R_to_S)\n\n        return epi_metrics\n\n    def run_model_checks(self):\n\n        print(\"&gt;&gt;&gt; Running flu model checks... \\n\")\n        print(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\")\n\n        error_counter = 0\n\n        sim_state = self.sim_state\n\n        for name, val in vars(sim_state).items():\n            if isinstance(val, np.ndarray):\n                flattened_array = val.flatten()\n                for val in flattened_array:\n                    if val &lt; 0:\n                        print(f\"STOP! INPUT ERROR: {name} should not have negative values.\")\n                        error_counter += 1\n            elif isinstance(val, float):\n                if val &lt; 0:\n                    print(f\"STOP! INPUT ERROR: {name} should not be negative.\")\n                    error_counter += 1\n\n        compartment_population_sum = np.zeros((self.fixed_params.num_age_groups,\n                                               self.fixed_params.num_risk_groups))\n\n        for name, compartment in self.compartments.items():\n            compartment_population_sum += compartment.current_val\n            flattened_current_val = compartment.current_val.flatten()\n            for val in flattened_current_val:\n                if val != int(val):\n                    print(f\"STOP! INPUT ERROR: {name} should not have non-negative values.\")\n                    error_counter += 1\n\n        if (compartment_population_sum != self.fixed_params.total_pop_age_risk).any():\n            print(f\"STOP! INPUT ERROR: sum of population in compartments must \\n\"\n                  f\"match specified total population value. Check \\n\"\n                  f\"\\\"total_pop_age_risk\\\" in fixed params JSON and \\n\"\n                  f\"check compartments in state variables' init vals JSON.\")\n            error_counter += 1\n\n        fixed_params = self.fixed_params\n\n        # TODO: this has identical logic as the loop over sim_state -- pull out as\n        #   separate function\n        for name, val in vars(fixed_params).items():\n            if isinstance(val, np.ndarray):\n                flattened_array = val.flatten()\n                for val in flattened_array:\n                    if val &lt; 0:\n                        print(f\"STOP! INPUT ERROR: {name} should not have negative values.\")\n                        error_counter += 1\n            elif isinstance(val, float):\n                if val &lt; 0:\n                    print(f\"STOP! INPUT ERROR: {name} should not be negative.\")\n                    error_counter += 1\n\n        if error_counter == 0:\n\n\n            print(\"OKAY! Flu model has passed input checks: \\n\"\n                  \"Compartment populations are nonnegative whole numbers \\n\"\n                  \"and match the specified \\\"total_pop_age_risk\\\" values. \\n\"\n                  \"Fixed parameters are nonnegative.\")\n\n        print(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\")\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.__init__","title":"<code>__init__(sim_state_dict, fixed_params_dict, config_dict, RNG, wastewater_enabled=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>sim_state_dict</code> <code>dict</code> <p>holds current simulation state information, such as current values of epidemiological compartments and epi metrics -- keys and values respectively must match field names and format of FluSimState.</p> required <code>fixed_params_dict</code> <code>dict</code> <p>holds epidemiological parameter values -- keys and values respectively must match field names and format of FluFixedParams.</p> required <code>config_dict</code> <code>dict</code> <p>holds configuration values -- keys and values respectively must match field names and format of Config.</p> required <code>RNG</code> <code>Generator</code> <p>numpy random generator object used to obtain random numbers.</p> required <code>wastewater_enabled</code> <code>bool</code> <p>if True, includes \"wastewater\" EpiMetric. Otherwise, excludes it.</p> <code>False</code> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def __init__(self,\n             sim_state_dict: dict,\n             fixed_params_dict: dict,\n             config_dict: dict,\n             RNG: np.random.Generator,\n             wastewater_enabled: bool=False):\n    \"\"\"\n    Args:\n        sim_state_dict (dict):\n            holds current simulation state information,\n            such as current values of epidemiological compartments\n            and epi metrics -- keys and values respectively\n            must match field names and format of FluSimState.\n        fixed_params_dict (dict):\n            holds epidemiological parameter values -- keys and\n            values respectively must match field names and\n            format of FluFixedParams.\n        config_dict (dict):\n            holds configuration values -- keys and values\n            respectively must match field names and format of\n            Config.\n        RNG (np.random.Generator):\n            numpy random generator object used to obtain\n            random numbers.\n        wastewater_enabled (bool):\n            if True, includes \"wastewater\" EpiMetric. Otherwise,\n            excludes it.\n    \"\"\"\n\n    # Assign config, fixed_params, and sim_state to model-specific\n    # types of dataclasses that have epidemiological parameter information\n    # and sim state information\n\n    self.wastewater_enabled = wastewater_enabled\n\n    sim_state = clt.make_dataclass_from_dict(FluSimState, sim_state_dict)\n    fixed_params = clt.make_dataclass_from_dict(FluFixedParams, fixed_params_dict)\n    config = clt.make_dataclass_from_dict(clt.Config, config_dict)\n\n    # IMPORTANT NOTE: as always, we must be careful with mutable objects\n    #   and generally use deep copies to avoid modification of the same\n    #   object. But in this function call, using deep copies is unnecessary\n    #   (redundant) because the parent class SubpopModel's __init__()\n    #   creates deep copies.\n    super().__init__(sim_state, fixed_params, config, RNG)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_compartments","title":"<code>create_compartments()</code>","text":"<p>Create Compartment instances S-E-I-H-R-D (6 compartments total),     save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_compartments(self) -&gt; sc.objdict:\n    \"\"\"\n    Create Compartment instances S-E-I-H-R-D (6 compartments total),\n        save in sc.objdict, and return objdict\n    \"\"\"\n\n    compartments = sc.objdict()\n\n    for name in (\"S\", \"E\", \"IP\", \"IS\", \"IA\", \"H\", \"R\", \"D\"):\n        compartments[name] = clt.Compartment(getattr(self.sim_state, name))\n\n    return compartments\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_dynamic_vals","title":"<code>create_dynamic_vals()</code>","text":"<p>Create all DynamicVal instances, save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_dynamic_vals(self) -&gt; sc.objdict:\n    \"\"\"\n    Create all DynamicVal instances, save in sc.objdict, and return objdict\n    \"\"\"\n\n    dynamic_vals = sc.objdict()\n\n    dynamic_vals[\"beta_reduct\"] = BetaReduct(init_val=0.0,\n                                             is_enabled=False)\n\n    return dynamic_vals\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_epi_metrics","title":"<code>create_epi_metrics()</code>","text":"<p>Create all epi metric described in docstring (2 state variables total), save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_epi_metrics(self) -&gt; sc.objdict:\n    \"\"\"\n    Create all epi metric described in docstring (2 state\n    variables total), save in sc.objdict, and return objdict\n    \"\"\"\n\n    epi_metrics = sc.objdict()\n\n    # Shortcuts for attribute access\n    # NOTE: see the parent class SubpopModel's __init__() --\n    #   create_epi_metrics is called after self.transition_variables\n    #   are created -- so this variable exists\n    # See similar NOTE in create_transition_variables\n    #   and create_transition_variable_groups function\n    transition_variables = self.transition_variables\n\n    epi_metrics.pop_immunity_inf = \\\n        PopulationImmunityInf(getattr(self.sim_state, \"pop_immunity_inf\"),\n                              transition_variables.R_to_S)\n\n    if self.wastewater_enabled:\n        epi_metrics.wastewater = \\\n            Wastewater(getattr(self.sim_state, \"wastewater\"),  # initial value is set to null for now\n                       transition_variables.S_to_E)\n\n    epi_metrics.pop_immunity_hosp = \\\n        PopulationImmunityHosp(getattr(self.sim_state, \"pop_immunity_hosp\"),\n                               transition_variables.R_to_S)\n\n    return epi_metrics\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_schedules","title":"<code>create_schedules()</code>","text":"<p>Create all Schedule instances, save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_schedules(self) -&gt; sc.objdict():\n    \"\"\"\n    Create all Schedule instances, save in sc.objdict, and return objdict\n    \"\"\"\n\n    schedules = sc.objdict()\n\n    schedules[\"absolute_humidity\"] = AbsoluteHumidity()\n    schedules[\"flu_contact_matrix\"] = FluContactMatrix()\n\n    return schedules\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_transition_variable_groups","title":"<code>create_transition_variable_groups()</code>","text":"<p>Create all transition variable groups described in docstring (2 transition variable groups total), save in sc.objdict, return</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_transition_variable_groups(self) -&gt; sc.objdict:\n    \"\"\"\n    Create all transition variable groups described in docstring (2 transition\n    variable groups total), save in sc.objdict, return\n    \"\"\"\n\n    # Shortcuts for attribute access\n    # NOTE: see the parent class SubpopModel's __init__() --\n    #   create_transition_variable_groups is called after\n    #   self.config is assigned and after\n    #   self.compartments and self.transition_variables are created\n    #   -- so these variables do exist\n    # See similar NOTE in create_transition_variables function\n    transition_type = self.config.transition_type\n    compartments = self.compartments\n    transition_variables = self.transition_variables\n\n    transition_variable_groups = sc.objdict()\n\n    transition_variable_groups.E_out = clt.TransitionVariableGroup(compartments.E,\n                                                                   transition_type,\n                                                                   (transition_variables.E_to_IP,\n                                                                    transition_variables.E_to_IA))\n\n    transition_variable_groups.IS_out = clt.TransitionVariableGroup(compartments.IS,\n                                                                    transition_type,\n                                                                    (transition_variables.IS_to_R,\n                                                                     transition_variables.IS_to_H))\n\n    transition_variable_groups.H_out = clt.TransitionVariableGroup(compartments.H,\n                                                                   transition_type,\n                                                                   (transition_variables.H_to_R,\n                                                                    transition_variables.H_to_D))\n\n    return transition_variable_groups\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.FluSubpopModel.create_transition_variables","title":"<code>create_transition_variables()</code>","text":"<p>Create all TransitionVariable instances (7 transition variables total),     save in sc.objdict, and return objdict</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def create_transition_variables(self) -&gt; sc.objdict:\n    \"\"\"\n    Create all TransitionVariable instances (7 transition variables total),\n        save in sc.objdict, and return objdict\n    \"\"\"\n\n    # NOTE: see the parent class SubpopModel's __init__() --\n    #   create_transition_variables is called after\n    #   self.config is assigned and after self.compartments\n    #   has been created -- so these variables do exist\n    # TODO: there is potentially a better way to design this\n    #   (in SubpopModel) to be more EXPLICIT -- think about this...\n    transition_type = self.config.transition_type\n    compartments = self.compartments\n\n    transition_variables = sc.objdict()\n\n    S = compartments.S\n    E = compartments.E\n    IP = compartments.IP\n    IS = compartments.IS\n    IA = compartments.IA\n    H = compartments.H\n    R = compartments.R\n    D = compartments.D\n\n    transition_variables.R_to_S = RecoveredToSusceptible(R, S, transition_type)\n    transition_variables.S_to_E = SusceptibleToExposed(S, E, transition_type)\n    transition_variables.IP_to_IS = PresympToSymp(IP, IS, transition_type)\n    transition_variables.IA_to_R = AsympToRecovered(IA, R, transition_type)\n    transition_variables.E_to_IP = ExposedToPresymp(E, IP, transition_type, True)\n    transition_variables.E_to_IA = ExposedToAsymp(E, IA, transition_type, True)\n    transition_variables.IS_to_R = SympToRecovered(IS, R, transition_type, True)\n    transition_variables.IS_to_H = SympToHosp(IS, H, transition_type, True)\n    transition_variables.H_to_R = HospToRecovered(H, R, transition_type, True)\n    transition_variables.H_to_D = HospToDead(H, D, transition_type, True)\n\n    return transition_variables\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.HospToDead","title":"<code>HospToDead</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class HospToDead(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        return np.asarray(fixed_params.H_to_D_adjusted_prop * fixed_params.H_to_D_rate /\n                          (1 + fixed_params.death_risk_reduction * sim_state.pop_immunity_hosp))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.HospToRecovered","title":"<code>HospToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class HospToRecovered(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        return np.full((fixed_params.num_age_groups, fixed_params.num_risk_groups),\n                       (1 - fixed_params.H_to_D_adjusted_prop) * fixed_params.H_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.PopulationImmunityHosp","title":"<code>PopulationImmunityHosp</code>","text":"<p>               Bases: <code>EpiMetric</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class PopulationImmunityHosp(clt.EpiMetric):\n\n    def __init__(self, init_val, R_to_S):\n        super().__init__(init_val)\n        self.R_to_S = R_to_S\n\n    def get_change_in_current_val(self,\n                                  sim_state: FluSimState,\n                                  fixed_params: FluFixedParams,\n                                  num_timesteps: int):\n        pop_immunity_hosp = sim_state.pop_immunity_hosp\n\n        immunity_gain_numerator = fixed_params.immunity_hosp_increase_factor * self.R_to_S.current_val\n        immunity_gain_denominator = fixed_params.total_pop_age_risk * \\\n                                    (1 + fixed_params.immunity_saturation * pop_immunity_hosp)\n\n        immunity_gain = immunity_gain_numerator / immunity_gain_denominator\n        immunity_loss = fixed_params.waning_factor_hosp * sim_state.pop_immunity_hosp\n\n        final_change = (immunity_gain - immunity_loss) / num_timesteps\n\n        return np.asarray(final_change, dtype=np.float64)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.PopulationImmunityInf","title":"<code>PopulationImmunityInf</code>","text":"<p>               Bases: <code>EpiMetric</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class PopulationImmunityInf(clt.EpiMetric):\n    def __init__(self, init_val, R_to_S):\n        super().__init__(init_val)\n        self.R_to_S = R_to_S\n\n    def get_change_in_current_val(self,\n                                  sim_state: FluSimState,\n                                  fixed_params: FluFixedParams,\n                                  num_timesteps: int):\n        pop_immunity_inf = np.float64(sim_state.pop_immunity_inf)\n\n        immunity_gain_numerator = fixed_params.immunity_inf_increase_factor * self.R_to_S.current_val\n        immunity_gain_denominator = fixed_params.total_pop_age_risk * \\\n                                    (1 + fixed_params.immunity_saturation * pop_immunity_inf)\n\n        immunity_gain = immunity_gain_numerator / immunity_gain_denominator\n        immunity_loss = fixed_params.waning_factor_inf * sim_state.pop_immunity_inf\n\n        final_change = (immunity_gain - immunity_loss) / num_timesteps\n\n        return np.asarray(final_change, dtype=np.float64)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.PresympToSymp","title":"<code>PresympToSymp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class PresympToSymp(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        return np.full((fixed_params.num_age_groups, fixed_params.num_risk_groups),\n                       fixed_params.IP_to_IS_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.RecoveredToSusceptible","title":"<code>RecoveredToSusceptible</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class RecoveredToSusceptible(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        return np.full((fixed_params.num_age_groups, fixed_params.num_risk_groups), fixed_params.R_to_S_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.SusceptibleToExposed","title":"<code>SusceptibleToExposed</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class SusceptibleToExposed(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        force_of_immunity = (1 + fixed_params.inf_risk_reduction * sim_state.pop_immunity_inf)\n\n        # We subtract absolute_humidity because higher humidity means less transmission\n        beta_humidity_adjusted = (1 - sim_state.absolute_humidity * fixed_params.humidity_impact) * \\\n                                 fixed_params.beta_baseline\n\n        # Compute I / N -&gt; original shape is (A, L)\n        # Expand ratio for broadcasting -&gt; new shape is (1, 1, A, L)\n        I_N_ratio_expanded = ((\n                                      sim_state.IS + sim_state.IP * fixed_params.IP_relative_inf + sim_state.IA * fixed_params.IA_relative_inf)\n                              / fixed_params.total_pop_age_risk)[None, None, :, :]\n\n        # Expand force_of_immunity for broadcasting -&gt; new shape is (A, L, 1, 1)\n        force_of_immunity_expanded = force_of_immunity[:, :, None, None]\n\n        # Element-wise multiplication and division by M_expanded\n        # Sum over a' and l' (last two dimensions) -&gt; result has shape (A, L)\n        summand = np.sum(sim_state.flu_contact_matrix * I_N_ratio_expanded / force_of_immunity_expanded, axis=(2, 3))\n\n        return (1 - sim_state.beta_reduct) * beta_humidity_adjusted * summand\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.SympToHosp","title":"<code>SympToHosp</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class SympToHosp(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        return np.asarray(fixed_params.IS_to_H_rate * fixed_params.IS_to_H_adjusted_prop /\n                          (1 + fixed_params.hosp_risk_reduction * sim_state.pop_immunity_hosp))\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.SympToRecovered","title":"<code>SympToRecovered</code>","text":"<p>               Bases: <code>TransitionVariable</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class SympToRecovered(clt.TransitionVariable):\n    def get_current_rate(self,\n                         sim_state: FluSimState,\n                         fixed_params: FluFixedParams):\n        return np.full((fixed_params.num_age_groups, fixed_params.num_risk_groups),\n                       (1 - fixed_params.IS_to_H_adjusted_prop) * fixed_params.IS_to_R_rate)\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.Wastewater","title":"<code>Wastewater</code>","text":"<p>               Bases: <code>EpiMetric</code></p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>class Wastewater(clt.EpiMetric):\n\n    def __init__(self, init_val, S_to_E):\n        super().__init__(init_val)\n        self.S_to_E = S_to_E\n        # preprocess\n        self.flag_preprocessed = False\n        self.viral_shedding = []\n        self.viral_shedding_duration = None\n        self.viral_shedding_magnitude = None\n        self.viral_shedding_peak = None\n        self.viral_shedding_feces_mass = None\n        self.S_to_E_len = 5000  # preset to match the simulation time horizon\n        self.S_to_E_history = np.zeros(self.S_to_E_len)\n        self.cur_time_stamp = -1\n        self.num_timesteps = None\n        self.val_list_len = None\n        self.current_val_list = None\n        self.cur_idx_timestep = -1\n\n    def get_change_in_current_val(self,\n                                  sim_state: FluSimState,\n                                  fixed_params: FluFixedParams,\n                                  num_timesteps: int):\n        if not self.flag_preprocessed:  # preprocess the viral shedding function if not done yet\n            self.val_list_len = num_timesteps\n            self.current_val_list = np.zeros(self.val_list_len)\n            self.preprocess(fixed_params, num_timesteps)\n        return 0\n\n    def update_current_val(self) -&gt; None:\n        \"\"\"\n        Adds change_in_current_val attribute to current_val attribute\n            in-place.\n        \"\"\"\n        # record number of exposed people per day\n        self.cur_time_stamp += 1\n        self.S_to_E_history[self.cur_time_stamp] = np.sum(self.S_to_E.current_val)\n        current_val = 0\n\n        # attribute access shortcut\n        cur_time_stamp = self.cur_time_stamp\n\n        # discrete convolution\n        len_duration = self.viral_shedding_duration * self.num_timesteps\n\n        if self.cur_time_stamp &gt;= len_duration - 1:\n            current_val = self.S_to_E_history[\n                          (cur_time_stamp - len_duration + 1):(cur_time_stamp + 1)] @ self.viral_shedding\n        else:\n            current_val = self.S_to_E_history[\n                          :(cur_time_stamp + 1)] @ self.viral_shedding[-(cur_time_stamp + 1):]\n\n        self.current_val = current_val\n        self.cur_idx_timestep += 1\n        self.current_val_list[self.cur_idx_timestep] = current_val\n\n    def preprocess(self,\n                   fixed_params: FluFixedParams,\n                   num_timesteps: int):\n        # store the parameters locally\n        self.viral_shedding_duration = copy.deepcopy(fixed_params.viral_shedding_duration)\n        self.viral_shedding_magnitude = copy.deepcopy(fixed_params.viral_shedding_magnitude)\n        self.viral_shedding_peak = copy.deepcopy(fixed_params.viral_shedding_peak)\n        self.viral_shedding_feces_mass = copy.deepcopy(fixed_params.viral_shedding_feces_mass)\n        self.num_timesteps = copy.deepcopy(num_timesteps)\n        num_timesteps = np.float64(num_timesteps)\n        self.viral_shedding = []\n        # trapezoidal integral\n        for time_idx in range(int(fixed_params.viral_shedding_duration * self.num_timesteps)):\n            cur_time_point = time_idx / num_timesteps\n            next_time_point = (time_idx + 1) / num_timesteps\n            next_time_log_viral_shedding = fixed_params.viral_shedding_magnitude * next_time_point / \\\n                                           (fixed_params.viral_shedding_peak ** 2 + next_time_point ** 2)\n            if time_idx == 0:\n                interval_viral_shedding = fixed_params.viral_shedding_feces_mass * 0.5 * (\n                        10 ** next_time_log_viral_shedding) / num_timesteps\n            else:\n                cur_time_log_viral_shedding = fixed_params.viral_shedding_magnitude * cur_time_point / \\\n                                              (fixed_params.viral_shedding_peak ** 2 + cur_time_point ** 2)\n                interval_viral_shedding = fixed_params.viral_shedding_feces_mass * 0.5 \\\n                                          * (\n                                                  10 ** cur_time_log_viral_shedding + 10 ** next_time_log_viral_shedding) / num_timesteps\n            self.viral_shedding.append(interval_viral_shedding)\n        self.viral_shedding.reverse()\n        self.viral_shedding = np.array(self.viral_shedding)\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves daily viral load (accumulated during one day) to history by appending current_val attribute\n            to history_vals_list in place\n\n        \"\"\"\n        daily_viral_load = np.sum(self.current_val_list)\n        self.history_vals_list.append(daily_viral_load)\n        # reset the index of current_val_list\n        self.cur_idx_timestep = -1\n\n    def clear_history(self) -&gt; None:\n        \"\"\"\n        Resets history_vals_list attribute to empty list.\n        \"\"\"\n        self.flag_preprocessed = False\n        self.viral_shedding = []\n        self.viral_shedding_duration = None\n        self.viral_shedding_magnitude = None\n        self.viral_shedding_peak = None\n        self.viral_shedding_feces_mass = None\n        self.S_to_E_len = 5000  # preset to match the simulation time horizon\n        self.S_to_E_history = np.zeros(self.S_to_E_len)\n        self.cur_time_stamp = -1\n        self.num_timesteps = None\n        self.val_list_len = None\n        self.current_val_list = None\n        self.cur_idx_timestep = -1\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.Wastewater.clear_history","title":"<code>clear_history()</code>","text":"<p>Resets history_vals_list attribute to empty list.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def clear_history(self) -&gt; None:\n    \"\"\"\n    Resets history_vals_list attribute to empty list.\n    \"\"\"\n    self.flag_preprocessed = False\n    self.viral_shedding = []\n    self.viral_shedding_duration = None\n    self.viral_shedding_magnitude = None\n    self.viral_shedding_peak = None\n    self.viral_shedding_feces_mass = None\n    self.S_to_E_len = 5000  # preset to match the simulation time horizon\n    self.S_to_E_history = np.zeros(self.S_to_E_len)\n    self.cur_time_stamp = -1\n    self.num_timesteps = None\n    self.val_list_len = None\n    self.current_val_list = None\n    self.cur_idx_timestep = -1\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.Wastewater.save_history","title":"<code>save_history()</code>","text":"<p>Saves daily viral load (accumulated during one day) to history by appending current_val attribute     to history_vals_list in place</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves daily viral load (accumulated during one day) to history by appending current_val attribute\n        to history_vals_list in place\n\n    \"\"\"\n    daily_viral_load = np.sum(self.current_val_list)\n    self.history_vals_list.append(daily_viral_load)\n    # reset the index of current_val_list\n    self.cur_idx_timestep = -1\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.Wastewater.update_current_val","title":"<code>update_current_val()</code>","text":"<p>Adds change_in_current_val attribute to current_val attribute     in-place.</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def update_current_val(self) -&gt; None:\n    \"\"\"\n    Adds change_in_current_val attribute to current_val attribute\n        in-place.\n    \"\"\"\n    # record number of exposed people per day\n    self.cur_time_stamp += 1\n    self.S_to_E_history[self.cur_time_stamp] = np.sum(self.S_to_E.current_val)\n    current_val = 0\n\n    # attribute access shortcut\n    cur_time_stamp = self.cur_time_stamp\n\n    # discrete convolution\n    len_duration = self.viral_shedding_duration * self.num_timesteps\n\n    if self.cur_time_stamp &gt;= len_duration - 1:\n        current_val = self.S_to_E_history[\n                      (cur_time_stamp - len_duration + 1):(cur_time_stamp + 1)] @ self.viral_shedding\n    else:\n        current_val = self.S_to_E_history[\n                      :(cur_time_stamp + 1)] @ self.viral_shedding[-(cur_time_stamp + 1):]\n\n    self.current_val = current_val\n    self.cur_idx_timestep += 1\n    self.current_val_list[self.cur_idx_timestep] = current_val\n</code></pre>"},{"location":"flu_components_reference/#CLT_BaseModel.flu_model.flu_components.absolute_humidity_func","title":"<code>absolute_humidity_func(current_date)</code>","text":"<p>Note: this is a dummy function loosely based off of the absolute humidity data from Kaiming and Shraddha's new burden averted draft.</p> <p>TODO: replace this function with real humidity function</p> <p>The following calculation is used to achieve the correct     upside-down parabola with the right min and max     values and location     max_value = 12.5     0.00027 = (max_value - k) / ((0 - h) ** 2)</p> <p>Parameters:</p> Name Type Description Default <code>current_date</code> <code>date</code> <p>datetime.date object corresponding to real-world date</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>nonnegative float between 3.4 and 12.5 corresponding to absolute humidity that day of the year</p> Source code in <code>CLT_BaseModel/flu_model/flu_components.py</code> <pre><code>def absolute_humidity_func(current_date: datetime.date) -&gt; float:\n    \"\"\"\n    Note: this is a dummy function loosely based off of\n    the absolute humidity data from Kaiming and Shraddha's\n    new burden averted draft.\n\n    TODO: replace this function with real humidity function\n\n    The following calculation is used to achieve the correct\n        upside-down parabola with the right min and max\n        values and location\n        max_value = 12.5\n        0.00027 = (max_value - k) / ((0 - h) ** 2)\n\n    Args:\n        current_date (datetime.date):\n            datetime.date object corresponding to\n            real-world date\n\n    Returns:\n        float:\n            nonnegative float between 3.4 and 12.5\n            corresponding to absolute humidity\n            that day of the year\n    \"\"\"\n\n    # Convert datetime.date to integer between 1 and 365\n    #   corresponding to day of the year\n    day_of_year = current_date.timetuple().tm_yday\n\n    # Minimum humidity occurs in January and December\n    # Maximum humidity occurs in July\n    return 12.5 - 0.00027 * (day_of_year % 365 - 180) ** 2\n</code></pre>"},{"location":"flu_components_walkthrough/","title":"Flu Model Creation Walkthrough","text":"<p>This page is getting updated, please check back soon! </p>"},{"location":"flu_input_files/","title":"Flu Model Input Files Overview","text":"<p>Written by LP, updated 01/07/2025 (work in progress) </p> <p>Important note: we are updating this page with wastewater inputs -- check back soon.</p> <p>Here we provide a mapping between the input variable names in the flu model's <code>JSON</code> files (and corresponding <code>dataclasses</code>), which become object attribute names in the model) and the mathematical variable. </p> <p>The folder <code>flu_demo_input_files</code> contains 3 <code>JSON</code> input files used to run <code>flu_demo.py</code>: <code>config.json</code>, <code>fixed_params.json</code>, and <code>state_variables_init_vals.json</code>. These input files respectively initialize <code>Config</code> instances, <code>FluFixedParams</code> instances, and <code>FluSimState</code> instances.</p> <p>In general, for users to customize the values (not the structure) of the flu model given in <code>flu_components.py</code>, they must provide analogous 3 <code>JSON</code> input files with the following formats.</p>"},{"location":"flu_input_files/#simulation-configuration","title":"Simulation configuration","text":"<p>The table below describes the <code>JSON</code> file used to initialize <code>Config</code> instances. These values specify the simulation experiment configuration. </p> Name Explanation Format <code>timesteps_per_day</code> number of discretized timesteps per day -- larger values may increase accuracy of approximation to continuous time but slow down simulation positive <code>int</code> <code>transition_type</code> specifies distribution of stochastic or deterministic population transitions between compartments -- see mathematical definition of transition types for specific formulas <code>str</code>, must have value in <code>base_components.TransitionTypes</code> to be valid <code>start_real_date</code> real-world date corresponding to start of simulation <code>str</code>, must have format <code>\"YYYY-MM-DD\"</code> <code>save_daily_history</code> indicates if daily history is saved on <code>EpiCompartment</code> instances -- may want to strategically turn off to save time during performance runs <code>bool</code>"},{"location":"flu_input_files/#fixed-parameters","title":"Fixed parameters","text":"<p>The table below has a variable name to math variable mapping for the <code>JSON</code> file used to initialize <code>FluFixedParams</code> instances. We can think of this file as the \"Greek letter file\" -- it specifies values such as transition rates as well as number of age groups and risk groups. We assume that these values do not change throughout the course of the simulation.  </p> Name Math Variable Dimension <code>num_age_groups</code> \\(\\lvert A \\rvert\\) positive <code>int</code> <code>num_risk_groups</code> \\(\\lvert L \\rvert\\) positive <code>int</code> <code>beta_baseline</code> \\(\\beta_0\\) positive scalar <code>total_pop_age_risk</code> \\(\\boldsymbol{N}\\) \\(\\boldsymbol{\\tilde{\\nu}}\\) <code>humidity_impact</code> \\(\\xi\\) scalar <code>immunity_hosp_increase_factor</code> \\(g^H\\) scalar <code>immunity_inf_increase_factor</code> \\(g^I\\) scalar <code>immunity_saturation_constant</code> \\(\\boldsymbol{O}\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>waning_factor_hosp</code> \\(w^H\\) positive scalar <code>waning_factor_inf</code> \\(w^I\\) positive scalar <code>hosp_risk_reduction</code> \\(\\boldsymbol{K}^H\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>inf_risk_reduction</code> \\(\\boldsymbol{K}^I\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>death_risk_reduction</code> \\(\\boldsymbol{K}^D\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>R_to_S_rate</code> \\(\\eta\\) positive scalar <code>E_to_I_rate</code> \\(\\sigma\\) positive scalar <code>IP_to_IS_rate</code> \\(\\rho\\) positive scalar <code>IS_to_R_rate</code> \\(\\gamma\\) positive scalar <code>IA_to_R_rate</code> \\(\\gamma_{IA}\\) positive scalar <code>IS_to_H_rate</code> \\(\\zeta\\) positive scalar <code>H_to_R_rate</code> \\(\\gamma_H\\) positive scalar <code>H_to_D_rate</code> \\(\\pi\\) positive scalar <code>E_to_IA_prop</code> \\(\\tau\\) scalar in \\([0,1]\\) <code>H_to_D_adjusted_prop</code> \\(\\boldsymbol{\\tilde{\\nu}}\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>IS_to_H_adjusted_prop</code> \\(\\boldsymbol{\\tilde{\\mu}}\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>IP_relative_inf</code> \\(r_{IP}\\) positive scalar <code>IA_relative_inf</code> \\(r_{IA}\\) positive scalar"},{"location":"flu_input_files/#initial-values-of-state-variables","title":"Initial values of state variables","text":"<p>The table below has a variable name to math variable mapping for the <code>JSON</code> file used to initialize <code>FluSimState</code> instances. This file specifies initial conditions for <code>StateVariable</code> objects (which includes <code>EpiCompartment</code>, <code>EpiMetric</code>, <code>Schedule</code>, and <code>DynamicVal</code> objects). </p> <p>Important notes:</p> <ul> <li> <p>In <code>state_variables_init_vals.json</code> in <code>flu_demo_input_files</code>, <code>absolute_humidity</code> and <code>flu_contact_matrix</code> have initial values of <code>null</code> (which gets translated to <code>None</code> in <code>Python</code>). This is because absolute humidity and the flu contact matrix are <code>Schedule</code> instances, and get their values deterministically updated according to a schedule. At every simulation day <code>t</code>, their values are well-defined (taken from a schedule calendar), regardless of the initial value. Therefore, the initial value does not matter and we initialize these objects with a current value of <code>None</code>. However, these objects are indeed updated and used in the simulation.</p> </li> <li> <p>Currently, <code>beta_reduct</code> is not a part of the mathematical formulation. In the code, <code>beta_reduct</code> is a <code>DynamicVal</code> that decreases <code>beta_baseline</code> when a certain simulation state is triggered. This emulates a very simple staged-alert policy. In <code>flu_components.py</code>, <code>beta_reduct</code> is automatically disabled, so that the simple staged-alert policy is not in effect during default flu model runs. When enabled, <code>beta_reduct</code> has a value of <code>0.5</code> (corresponding to a \\(50\\%\\) decrease in transmission rates) when more than \\(5\\%\\) of the population is infected, and it has a value of <code>0.0</code> otherwise. </p> </li> </ul> Name Math Variable Dimension <code>S</code> \\(\\boldsymbol{S}(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>E</code> \\(\\boldsymbol{E}(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>IP</code> \\(\\boldsymbol{I^P}(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>IS</code> \\(\\boldsymbol{I^S}(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>IA</code> \\(\\boldsymbol{I^A}(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>H</code> \\(\\boldsymbol{H}(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>R</code> \\(\\boldsymbol{R}(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>D</code> \\(\\boldsymbol{D}(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>population_immunity_inf</code> \\(\\boldsymbol{M}^I(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>population_immunity_hosp</code> \\(\\boldsymbol{M}^H(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>absolute_humidity</code> <code>absolute_humidity</code> \\(= \\xi / q(0)\\) scalar <code>flu_contact_matrix</code> \\(\\boldsymbol{\\phi}(0)\\) \\(\\lvert A \\rvert \\times \\lvert L \\rvert \\times \\lvert A \\rvert \\times \\lvert L \\rvert\\) <code>beta_reduct</code> N/A scalar in \\([0,1]\\)"},{"location":"flu_model_code_overview/","title":"Flu Model Code Overview","text":"<p>Written by LP, updated 11/21/2024 (work in progress)</p>"},{"location":"flu_model_code_overview/#overview-assumptions","title":"Overview &amp; Assumptions","text":"<p>The module <code>flu_components.py</code> extends the base classes of <code>base_components.py</code> to implement a compartmental model with a specific structure. This model is given by the mathematical formulation of the flu model with a few simplifying assumptions. The script <code>flu_demo.py</code> runs the flu model with input data given in <code>flu_demo_input_files</code>. Note that this input data gives \"toy\" values. For a realistic model, we would estimate or calibrate these values using real-world historical data. </p> <p>The simplifying assumptions of <code>flu_components.py</code> include:</p> <ul> <li>We model only one immunity inducing event (say, H1N1).<ul> <li>We model only one strain (and thus disregard prevalence).</li> <li>We do not model vaccination.</li> </ul> </li> <li>Matrices that would otherwise have \\(3\\) indices (e.g. \\(\\boldsymbol{M}_{a, \\ell, H1}^H(t)\\) because they are \\(\\lvert A \\rvert \\times \\lvert L \\rvert \\times \\lvert \\mathcal I \\rvert\\)) only have \\(2\\) indices in the code (for age-risk group). In other words, these matrices are now only \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) and we drop the immunity-inducing event dimension entirely.</li> </ul> <p>A more comprehensive model relaxing these simplifying assumptions is coming soon!</p>"},{"location":"flu_model_code_overview/#documentation","title":"Documentation","text":"<p>Follow the links below for code readme's, tutorials, and other resources.</p> Name Explanation Flu Code Quickstart Must-read. Explanation of <code>flu_demo.py</code> and basic simulation functionality. Helps user get started with a concrete simulation right away. Flu Input Files Overview Must-read. Explanation of <code>flu_demo_input_files</code> and the required <code>JSON</code> specifications and formats for customizing flu model values. Flu Components Walkthrough Advanced. Must-read for users who want to create a custom model structure. Explains <code>flu_components.py</code> subclasses to demonstrate how to create custom subclasses for a customized flu model or another model."},{"location":"math_flu_components/","title":"Flu Model Mathematical Formulation","text":"<p>Written by LP, updated 01/07/2025 (work in progress) </p> <p>Important note: we are updating this page to include wastewater viral load and a metapopulation travel model -- check back soon.</p>"},{"location":"math_flu_components/#flu-model-diagram","title":"Flu model: diagram","text":""},{"location":"math_flu_components/#flu-model-deterministic-differential-equations","title":"Flu model: deterministic differential equations","text":"<ul> <li>\\(t \\in \\mathbb N\\): current simulation day</li> <li>\\(a\\): age group, \\(A\\): set of all age groups</li> <li>\\(\\ell\\): risk group, \\(L\\): set of all risk groups</li> <li>\\(i\\): type of immunity-inducing event, \\(\\mathcal{I} := \\left\\{\\text{H1}, \\text{H3}, \\text{V}\\right\\}\\): the set of all types of immunity-inducing events: infection by H1N1, infection by H3N2, and vaccination, respectively.</li> <li>\\(\\boldsymbol{O}\\): \\(\\lvert A \\rvert \\times \\lvert L \\rvert \\times \\lvert \\mathcal{I} \\rvert\\) matrix, where the \\((a, \\ell, i)\\)th element is the positive constant modeling the saturation of antibody production in individuals in age group \\(a\\) and risk group \\(\\ell\\) who had immunity-inducing event \\(i\\).</li> </ul> <p>Population-level immunity against infection (derived from H1N1 infections, H3N2 infections, and vaccinations respectively)</p> \\[\\begin{align} \\frac{dM^I_{a,\\ell,H1}(t)}{dt} &amp;= \\frac{g^I_{H1} p_{H1}(t) \\eta(t) R_{a,\\ell}(t)}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal I} O_{a,\\ell, i} M^I_{a,\\ell, i}(t)\\right)} - w^I_{H1} M^I_{a,\\ell,H1}(t) \\\\ \\frac{dM^I_{a,\\ell,H3}(t)}{dt} &amp;= \\frac{g^I_{H3} p_{H3}(t) \\eta(t) R_{a,\\ell}(t)}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal I} O_{a,\\ell, i} M^I_{a,\\ell, i}(t)\\right)} - w^I_{H3} M^I_{a,\\ell,H3}(t) \\\\ \\frac{dM^I_{a,\\ell,V}(t)}{dt} &amp;= g^I_V V(t - \\delta) - w^I_V M^I_{a,\\ell,V}(t) \\end{align}\\] <p>where</p> <ul> <li>\\(\\eta\\): rate at which recovered individuals become susceptible, so that \\(1/\\eta\\) is the average number of days a person is totally immune from reinfection until being susceptible again.</li> <li>\\(g^I_{H1}\\): factor by which population-level immunity against infection grows after each H1N1 case that recovers.</li> <li>\\(g^I_{H3}\\): factor by which population-level immunity against infection grows after each H3N2 case that recovers.</li> <li>\\(g^I_V\\): factor by which population-level immunity against infection grows after each vaccination.</li> <li>\\(\\boldsymbol{N}\\): \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) matrix corresponding to total population, where element \\(N_{a, \\ell}\\) is the total population of age group \\(a\\) and risk group \\(\\ell\\).</li> <li>\\(\\boldsymbol{p} = \\boldsymbol{p}(t) = [p_{H1}(t)\\), \\(p_{H3}(t)]\\): where elements correspond to prevalence of H1N1, H3N2 respectively.</li> <li>\\(w^I_{H1}\\): rate at which H1N1 infection-induced immunity against infection wanes.</li> <li>\\(w^I_{H3}\\): rate at which H3N2 infection-induced immunity against infection wanes.</li> <li>\\(w^I_V\\): rate at which vaccine-induced immunity against infection wanes.</li> <li>\\(V(t)\\): number of vaccine doses administered at time \\(t\\).</li> <li>\\(\\delta\\): number of days after dose for vaccine to become effective.</li> </ul> <p>Population-level immunity against hospitalization (derived from H1N1 infections, H3N2 infections, and vaccinations respectively)</p> \\[\\begin{align} \\frac{dM^H_{a,\\ell,H1}(t)}{dt} &amp;= \\frac{g^H_{H1} p_{H1}(t) \\eta(t) R_{a,\\ell}(t)}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal{I}} O_{a,\\ell, i} M^H_{a,\\ell, i}(t)\\right)} - w^H_{H1} M^H_{a,\\ell,H1}(t) \\\\ \\frac{dM^H_{a,\\ell,H3}(t)}{dt} &amp;= \\frac{g^H_{H3} p_{H3}(t) \\eta(t) R_{a,\\ell}(t)}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal{I}} O_{a,\\ell, i} M^H_{a,\\ell, i}(t)\\right)} - w^H_{H3} M^H_{a,\\ell,H3}(t) \\\\ \\frac{dM^H_{a,\\ell,V}(t)}{dt} &amp;= g^H_V V(t) - w^H_V M^H_{a,\\ell,V}(t) \\end{align}\\] <p>where</p> <ul> <li>\\(p_{H1}(t)\\), \\(p_{H3}(t)\\), \\(V(t)\\), \\(\\delta\\): see above.</li> <li>\\(g^H_{H1}\\): factor by which population-level immunity against hospitalization grows after each H1N1 case that recovers.</li> <li>\\(g^H_{H3}\\): factor by which population-level immunity against hospitalization grows after each H3N2 case that recovers.</li> <li>\\(g^H_V\\): factor by which population-level immunity against hospitalization grows after each vaccination.</li> <li>\\(w^H_{H1}\\): rate at which H1N1 infection-induced immunity against hospitalization wanes.</li> <li>\\(w^H_{H3}\\): rate at which H3N2 infection-induced immunity against hospitalization wanes.</li> <li>\\(w^H_V\\): rate at which vaccine-induced immunity against hospitalization wanes.</li> </ul> <p>Compartment equations</p> \\[\\begin{align} \\frac{dS_{a,\\ell}(t)}{dt} &amp;= \\underbrace{\\eta R_{a,\\ell}(t)}_{\\text{$R$ to $S$}} -\\underbrace{S_{a,\\ell}(t) \\sum_{a^\\prime \\in A, \\ell^\\prime \\in L} \\frac{\\beta(t) \\phi_{a, \\ell, a^\\prime, \\ell^\\prime}(t) I^{\\text{weighted}}_{a^\\prime, \\ell^\\prime}(t)}{N_{a^\\prime, \\ell^\\prime} (1 + \\boldsymbol{\\Lambda^{I, I}_{a,\\ell}(t)})}}_{\\text{$S$ to $E$}} \\\\[1em] \\frac{dE_{a,\\ell}(t)}{dt} &amp;= \\underbrace{S_{a,\\ell}(t) \\sum_{a^\\prime \\in A, \\ell^\\prime \\in L} \\frac{\\beta(t) \\phi_{a, \\ell, a^\\prime, \\ell^\\prime}(t) I^{\\text{weighted}}_{a^\\prime, \\ell^\\prime}(t)}{N_{a^\\prime, \\ell^\\prime} (1 + \\boldsymbol{\\Lambda^{I, I}_{a,\\ell}(t)})}}_{\\text{$S$ to $E$}} - \\underbrace{\\sigma (1-\\tau) E_{a,\\ell}(t)}_{\\text{$E$ to $I^P$}} - \\underbrace{\\sigma \\tau E_{a,\\ell}(t)}_{\\text{$E$ to $I^A$}} \\\\[1em] \\frac{dI^P_{a,\\ell}(t)}{dt} &amp;= \\underbrace{\\sigma (1-\\tau) E_{a,\\ell}(t)}_{\\text{$E$ to $I^P$}} - \\underbrace{\\rho I^P_{a,\\ell}(t)}_{\\text{$I^P$ to $I^S$}} \\\\[1em] \\frac{dI^S_{a,\\ell}(t)}{dt} &amp;= \\underbrace{\\rho I^P_{a,\\ell}(t)}_{\\text{$I^P$ to $I^S$}} - \\underbrace{(1-\\tilde{\\mu}_{a,\\ell})\\gamma I^S_{a,\\ell}(t)}_{\\text{$I^S$ to $R$}} - \\underbrace{\\frac{\\zeta \\tilde{\\mu}_{a,\\ell} I^S_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}_{a,\\ell}(t)}}}_{\\text{$I^S$ to $H$}} \\\\[1em] \\frac{dI^A_{a,\\ell}(t)}{dt} &amp;= \\underbrace{\\sigma \\tau E_{a,\\ell}(t)}_{\\text{$E$ to $I^A$}} - \\underbrace{\\gamma_{IA} I^A_{a,\\ell}(t)}_{\\text{$I^A$ to $R$}} \\\\[1em] \\frac{dH_{a,\\ell}(t)}{dt} &amp;= \\underbrace{\\frac{\\zeta \\tilde{\\mu}_{a,\\ell} I^S_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}_{a,\\ell}(t)}}}_{\\text{$I^S$ to $H$}} - \\underbrace{(1-\\tilde{\\nu}_{a,\\ell})\\gamma_H H_{a,\\ell}(t)}_{\\text{$H$ to $R$}} - \\underbrace{\\frac{\\pi \\tilde{\\nu}_{a,\\ell} H_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}_{a,\\ell}(t)}}}_{\\text{$H$ to $D$}} \\\\[1em] \\frac{dR_{a,\\ell}(t)}{dt} &amp;= \\underbrace{(1-\\tilde{\\mu}_{a,\\ell}) \\gamma I^S_{a,\\ell}(t)}_{\\text{$I^S$ to $R$}} + \\underbrace{\\gamma_{IA} I^A_{a,\\ell}(t)}_{\\text{$I^A$ to $R$}} + \\underbrace{(1-\\tilde{\\nu}_{a,\\ell})\\gamma_H H_{a,\\ell}(t)}_{\\text{$H$ to $R$}} - \\underbrace{\\eta R_{a,\\ell}(t)}_{\\text{$R$ to $S$}} \\\\[1em] \\frac{dD_{a,\\ell}(t)}{dt} &amp;= \\underbrace{\\frac{\\pi \\tilde{\\nu}_{a,\\ell} H_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{D, H}}_{a,\\ell}(t)}}_{\\text{$H$ to $D$}}  \\end{align}\\] <p>where </p> \\[ I^{\\text{weighted}}_{a^\\prime, \\ell^\\prime}(t) := \\left[I^S_{a^\\prime, \\ell^\\prime}(t) + r_{IP} I^P_{a^\\prime, \\ell^\\prime}(t) + r_{IA} I^A_{a^\\prime, \\ell^\\prime}(t)\\right] \\] <p>and where we have the following terms that characterize the effect of population-level immunities:</p> \\[\\begin{align} \\boldsymbol{\\Lambda^{I, I}_{a,\\ell}(t)} &amp;= \\left[\\boldsymbol{K_{a,\\ell}^I}(p(t))\\right]^T \\boldsymbol{M_{a,\\ell}^I}(t) \\\\ \\boldsymbol{\\Lambda^{H, H}_{a,\\ell}(t)} &amp;= \\left[\\boldsymbol{K_{a,\\ell}^H}(p(t))\\right]^T \\boldsymbol{M_{a,\\ell}^H}(t) \\\\ \\boldsymbol{\\Lambda^{D, H}}_{a,\\ell}(t) &amp;= \\left[\\boldsymbol{K_{a,\\ell}^D}(p(t))\\right]^T\\boldsymbol{M_{a,\\ell}^H}(t) \\end{align}\\] <p>and where</p> <ul> <li>\\(\\beta(t) = \\beta_0 (1 + q(t))\\): time-dependent transmission rate per day.</li> <li>\\(q(t)\\): seasonality parameter based on absolute humidity, where \\(q(t)\\) is a function of historical absolute humidity data times \\(\\xi\\), a humidity impact factor</li> <li>\\(\\phi_{a, \\ell, a^\\prime, \\ell^\\prime}(t)\\): mixing rates between age-risk group \\(a, \\ell\\) and \\(a^\\prime, \\ell^\\prime\\). Specifically, the interpretation is: for an individual in age-risk group \\(a, \\ell\\), the number of contacts they have in age-risk group \\(a^\\prime, \\ell^\\prime\\) per day.</li> <li>\\(\\tau\\): proportion exposed who are completely asymptomatic when infectious.</li> <li>\\(r_{IP}\\), \\(r_{IA}\\): relative infectiousness (compared to infected symptomatic people) of infected presymptomatic and infected asymptomatic people respectively. </li> <li>\\(\\gamma, \\gamma_H, \\gamma_{IA}\\): recovery rates for infected symptomatic (\\(I^S\\)),  hospital (\\(H\\)), and infected asymptomatic (\\(I^A\\)) compartments respectively, so that \\(1/\\gamma\\) is the average number of days it takes for an infected person not in the hospital to recover, and \\(1/\\gamma_H\\) is analogous, but for an infected person in the hospital. </li> <li>\\(\\sigma\\): infection rate (both exposed to infected presymptomatic transition rate and exposed to infected asymptomatic transition rate), so that \\(1/\\sigma\\) is the average number of days after exposure before a person becomes infectious.</li> <li>\\(\\rho\\): infected presymptomatic to infected symptomatic transition rate, so that \\(1/rho\\) is the average number of days that an infected person is presymptomatic before becoming symptomatic. </li> <li>\\(\\boldsymbol{\\tilde{\\mu}}\\), where \\(\\tilde{\\mu}_{a, \\ell} = \\frac{\\mu_{a, \\ell}\\gamma}{\\zeta - \\mu_{a, \\ell}(\\zeta-\\gamma)}\\): adjusted hospitalization rate (as in, proportion hospitalized based on age-risk group \\(a, \\ell\\) group) actually used in model -- this adjustment is necessary to ensure actual proportion hospitalized recapitulates \\([\\mu_{a, \\ell}]\\).</li> <li>\\(\\boldsymbol{\\mu}\\): \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) hospitalization rate (proportion hospitalized based on age-risk group \\(a, \\ell\\)).</li> <li>\\(\\zeta\\): hospitalization rate (infected to hospital transition rate), so that \\(1/\\zeta\\) is the average number of days a person is infected before going to the hospital.</li> <li>\\(\\boldsymbol{\\tilde{\\nu}}\\), where \\(\\tilde{\\nu}_{a, \\ell} = \\frac{\\nu_{a, \\ell}\\gamma_H}{\\pi - \\nu_{a, \\ell}(\\zeta-\\gamma_H)}\\): adjusted in-hospital mortality rate (as in, proportion who die in the hospital based on age group) actually used in model -- this adjustment is necessary to ensure actual proportion who die in the hospital recapitulates \\([\\nu_{a, \\ell}]\\).</li> <li>\\(\\boldsymbol{\\nu}\\): \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) in-hospital mortality rate (proportion who die based on age-risk group \\(a, \\ell\\)).</li> <li>\\(\\pi\\): death rate from hospital, so that \\(1/\\pi\\) is the average number of days a person spends in the hospital before dying.</li> </ul> <p>The following are all \\(\\lvert A \\rvert \\times \\lvert L \\rvert \\times \\lvert \\mathcal I \\rvert\\) matrices:</p> <ul> <li>\\(\\boldsymbol{K}^I(\\boldsymbol{p}) = [\\boldsymbol{K}^I_{H1}(p_{H1}), \\boldsymbol{K}^I_{H3}(p_{H3}), \\boldsymbol{K}^I_{V}]\\): reduction in infection risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^{H}(\\boldsymbol{p}) = [\\boldsymbol{K}^H_{H1}(p_{H1}), \\boldsymbol{K}^H_{H3}(p_{H3}), \\boldsymbol{K}^H_{V}]\\): reduction in hospitalization risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^D(\\boldsymbol{p}) = [\\boldsymbol{K}^D_{H1}(p_{H1}), \\boldsymbol{K^D}_{H3}(p_{H3}), \\boldsymbol{K}^D_{V}]\\): reduction in death risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{M}^I = \\boldsymbol{M}^I(t) = [\\boldsymbol{M}^I_{H1}(t), \\boldsymbol{M}^I_{H3}(t), \\boldsymbol{M}^I_{V}(t)]\\): population-level immunity from infection (induced by H1 infection, H3 infection, vaccination respectively).  </li> <li>\\(\\boldsymbol{M}^H = \\boldsymbol{M}^H(t) = [\\boldsymbol{M}^H_{H1}(t), \\boldsymbol{M}^H_{H3}(t), \\boldsymbol{M}^H_{V}(t)]\\): population-level immunity from hospitalization (induced by H1 infection, H3 infection, vaccination respectively).</li> </ul> <p>Note that prevalence is time-dependent, but we use \\(\\boldsymbol{p} = \\boldsymbol{p}(t)\\) for notation simplicity. </p>"},{"location":"math_flu_components/#flu-model-discretized-stochastic-implementation","title":"Flu model: discretized stochastic implementation","text":"<p>To actually implement/simulate this compartmental model, we discretize the deterministic differential equations and treat transitions between compartments as stochastic to model uncertainty. We extend the notation from the deterministic differential equations to capture the stochastic elements.</p> <p>Let \\(\\boldsymbol{\\mathcal X}(t) = \\left\\{\\boldsymbol{S}(t), \\boldsymbol{E}(t), \\boldsymbol{I}(t), \\boldsymbol{H}(t), \\boldsymbol{R}(t), \\boldsymbol{D}(t), \\boldsymbol{M}^I(t), \\boldsymbol{M}^H(t), q(t), \\boldsymbol{\\phi}(t), \\boldsymbol{p}(t), V(t)\\right\\}\\) be the \"simulate state\" at time \\(t\\). \\(\\boldsymbol{\\mathcal X}(t)\\) is a set of matrices. </p> <p>Let \\(\\boldsymbol{\\Theta} = \\left\\{\\boldsymbol{O}, \\boldsymbol{N}, \\boldsymbol{g}^I, \\boldsymbol{w}^I, \\boldsymbol{g}^H, \\boldsymbol{w^H}, \\beta_0, \\gamma, \\gamma_H, \\sigma, \\boldsymbol{\\mu}, \\zeta, \\boldsymbol{\\nu}, \\pi, \\eta \\right\\}\\) be the set of fixed parameters. We define notation \\(\\boldsymbol{g}^I = [g^I_{H1}, g^I_{H3}, g^I_V]\\),  \\(\\boldsymbol{w}^I = [w^I_{H1}, w^I_{H3}, w^I_V]\\), \\(\\boldsymbol{g}^H = [g^H_{H1}, g^H_{H3}, g^H_V]\\), and \\(\\boldsymbol{w}^H = [w^H_{H1}, w^H_{H3}, w^H_V]\\). </p> <p>Then given initial state \\(\\boldsymbol{\\mathcal X}_0 = \\boldsymbol{\\mathcal X}(0)\\), we can formulate our discretized stochastic implementation as</p> \\[ \\boldsymbol{\\mathcal X}(t + \\Delta t) = \\boldsymbol{\\mathcal X}(t) + f\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega; \\boldsymbol{\\Theta}\\right) \\quad \\text{for} \\quad t \\ge 0, \\] <p>where \\(f\\) is parametrized by \\(\\boldsymbol{\\Theta}\\), and depends on the step size of discretization \\(\\Delta t\\) and a sample path \\(\\omega\\). We assume that each sample path \\(\\omega\\) is realized from a random process that does not depend on \\(\\boldsymbol{\\mathcal X}(t)\\) or \\(\\Delta t\\) for each \\(t\\). When we are discussing a single model with a fixed set of parameters \\(\\boldsymbol{\\Theta}\\), we drop the \\(\\boldsymbol{\\Theta}\\) notation for simplicity.  </p> <p>Now we formulate how we implement discretized stochastic transitions. We assume that \\(q(t)\\), \\(\\boldsymbol{\\phi}(t)\\), \\(\\boldsymbol{p}(t)\\), and \\(V(t)\\)  are updated deterministically according to some \"schedule.\"  </p> <p>We model stochastic transitions between compartments using \"transition variables.\" Transition variables correspond to incoming and outgoing flows of epidemiological compartments (see the compartment equations above). </p> <p>Below we formulate the discretized stochastic transitions. For brevity, we omit the update formulas for \\(\\boldsymbol{M}^H(t)\\) since it is analogous to the discretized update for \\(\\boldsymbol{M}^I(t)\\). Note that the population-level immunity variables behave as aggregate epidemiological metrics. They are deterministic functions of the simulation state and transitions between compartments.</p> <p>Note: all \\(y\\) and \\(y^*\\)-variables depend on \\(\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). For notation simplicity, we define \\(\\boldsymbol{\\Xi}_t := \\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and write \\(y\\) and \\(y^*\\)-variables as functions of \\(\\boldsymbol{\\Xi}_t\\).</p> \\[\\begin{align} M_{a, \\ell, H1}^I(t + \\Delta t) &amp;= M_{a, \\ell, H1}^I(t) + \\left[\\frac{g^I_{H1} p_{H1}(t) \\cdot \\overbrace{y_{R\\rightarrow S,  a, \\ell}(\\boldsymbol{\\Xi}_t)}^{\\text{$R$ to $S$}}}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal I} O_{a,\\ell, i} M^I_{a,\\ell, i}(t)\\right)} - w^I_{H1} M^I_{a,\\ell,H1}(t)\\right] \\Delta t \\\\ M_{a, \\ell, H3}^I(t + \\Delta t) &amp;= M_{a, \\ell, H3}^I(t) + \\left[\\frac{g^I_{H3} p_{H3}(t) \\cdot \\overbrace{y_{R\\rightarrow S,  a, \\ell}(\\boldsymbol{\\Xi}_t)}^{\\text{$R$ to $S$}}}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal I} O_{a,\\ell, i} M^I_{a,\\ell, i}(t)\\right)} - w^I_{H3} M^I_{a,\\ell,H3}(t)\\right] \\Delta t \\\\ dM^I_{a,\\ell,V}(t + \\Delta t) &amp;= dM^I_{a,\\ell,V}(t) + \\left[g^I_V V(t - \\delta) - w^I_V M^I_{a,\\ell,V}(t)\\right] \\Delta t \\end{align}\\] \\[ \\vdots \\] \\[\\begin{align} S_{a,\\ell}(t + \\Delta t) &amp;= S_{a, \\ell}(t) + \\underbrace{y_{R\\rightarrow S, a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$R$ to $S$}} - \\underbrace{y_{S\\rightarrow E,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$S$ to $E$}} \\\\ E_{a,\\ell}(t + \\Delta t) &amp;= E_{a, \\ell}(t) + \\underbrace{y_{S\\rightarrow E,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$S$ to $E$}} - \\underbrace{y^*_{E\\rightarrow I^P,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$E$ to $I^P$}} - \\underbrace{y^*_{E\\rightarrow I^A,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$E$ to $I^A$}} \\\\ I^P_{a,\\ell}(t + \\Delta t) &amp;= I^P_{a,\\ell}(t) + \\underbrace{y^*_{E\\rightarrow I^P,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$E$ to $I^P$}} - \\underbrace{y_{I^P \\rightarrow I^S,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$I^P$ to $I^S$}} \\\\ I^A_{a, \\ell}(t + \\Delta t) &amp;= I^A_{a, \\ell}(t) + \\underbrace{y^*_{E\\rightarrow I^A,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$E$ to $I^A$}} - \\underbrace{y_{I^A \\rightarrow R,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$I^A$ to $R$}} \\\\ I^S_{a,\\ell}(t + \\Delta t) &amp;= I^S_{a, \\ell}(t) + \\underbrace{y_{E \\rightarrow I^S,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$E$ to $I^P$}} - \\underbrace{y^*_{I^S \\rightarrow R,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$I^S$ to $R$}} - \\underbrace{y^*_{I^S \\rightarrow H,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$I^S$ to $H$}} \\\\ H_{a,\\ell}(t + \\Delta t) &amp;= H_{a, \\ell}(t) + \\underbrace{y^*_{I^S \\rightarrow H,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$I^S$ to $H$}} - \\underbrace{y^*_{H\\rightarrow R,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$H$ to $R$}} - \\underbrace{y^*_{H\\rightarrow D,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$H$ to $D$}} \\\\ R_{a,\\ell}(t + \\Delta t) &amp;= R_{a, \\ell}(t) + \\underbrace{y^*_{I^S \\rightarrow R,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$I^S$ to $R$}} + \\underbrace{y^*_{H\\rightarrow R,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$H$ to $R$}} - \\underbrace{y_{R\\rightarrow S,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$R$ to $S$}} \\\\ D_{a,\\ell}(t + \\Delta t) &amp;= D_{a, \\ell}(t) + \\underbrace{y_{H\\rightarrow D,  a, \\ell}(\\boldsymbol{\\Xi}_t)}_{\\text{$H$ to $D$}}  \\end{align}\\] <p>IMPORTANT: the \"\\(*\\)\" superscript indicates that the transition variable has a joint distribution with another transition variable. In general, if a compartment has more than one outgoing transition variable, these transition variables must be modeled jointly. </p> <p>Consider the two transitions out of the infected symptomatic compartment, for example. Given that a patient is infected and symptomatic, exactly one outcome occurs: they recover (from home) or they go to the hospital. Since one and only one of these outcomes must occur, we must model these two transition variables jointly. Joint distribution derivation details are provided in the next section on transition types.</p> <p>Each transition variable depends on a \"base count\" and a \"rate\" (which both depend on the current state of the system). This decomposition is displayed in the table below.</p> Name Transition variable Base count Rate \\(R\\) to \\(S\\) \\(y_{R \\rightarrow S, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(R_{a, \\ell}(t)\\) \\(\\eta\\) \\(S\\) to \\(E\\) \\(y_{S \\rightarrow E, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(S_{a, \\ell}(t)\\) \\(\\sum_{a^\\prime \\in A, \\ell^\\prime \\in L} \\frac{\\beta(t) \\phi_{a, \\ell, a^\\prime, \\ell^\\prime}(t)  I^{\\text{weighted}}_{a^\\prime, \\ell^\\prime}(t)}{N_{a^\\prime, \\ell^\\prime} (1 + \\boldsymbol{\\Lambda^{I, I}_{a,\\ell}(t)})}\\) \\(E\\) to \\(I^P\\) \\(y^*_{E \\rightarrow I^P, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(E_{a, \\ell}(t)\\) \\(\\sigma (1 - \\tau)\\) \\(E\\) to \\(I^A\\) \\(y^*_{E \\rightarrow I^A, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(E_{a, \\ell}(t)\\) \\(\\sigma \\tau\\) \\(I^P\\) to \\(I^S\\) \\(y_{IP  \\rightarrow I^S, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(I^P_{a, \\ell}(t)\\) \\(\\rho\\) \\(I^S\\) to \\(R\\) \\(y^*_{I^S \\rightarrow R, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(I^S_{a, \\ell}(t)\\) \\((1-\\tilde{\\mu}_{a,\\ell})\\gamma\\) \\(I^S\\) to \\(H\\) \\(y^*_{I^S \\rightarrow H, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(I^S_{a, \\ell}(t)\\) \\(\\frac{\\zeta \\tilde{\\mu}_{a,\\ell} I^S_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}_{a,\\ell}(t)}}\\) \\(I^A\\) to \\(R\\) \\(y_{I^A \\rightarrow R, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(I^A_{a, \\ell}(t)\\) \\(\\gamma_{IA} I^A_{a,\\ell}(t)\\) \\(H\\) to \\(R\\) \\(y^*_{H \\rightarrow R, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(H_{a, \\ell}(t)\\) \\((1-\\tilde{\\nu}_{a,\\ell})\\gamma_H\\) \\(H\\) to \\(D\\) \\(y^*_{H \\rightarrow D, a, \\ell}(\\boldsymbol{\\Xi}_t)\\) \\(H_{a, \\ell}(t)\\) \\(\\frac{\\pi \\tilde{\\nu}_{a,\\ell} H_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}_{a,\\ell}(t)}}\\) <p>The base count and rate of a transition variable parameterize the distribution that defines its realization. </p> <p>See this page for mathematical formulations of marginal and joint stochastic transitions between compartments. </p>"},{"location":"math_flu_components/#general-model-discretized-stochastic-implementation","title":"General model: discretized stochastic implementation","text":"<p>We make the important note that the flu model's discretized stochastic implementation can be generalized to models with different structures. More broadly, we let \\(\\boldsymbol{\\mathcal C}(t)\\) be a model's set of epidemiological compartments, \\(\\boldsymbol{\\mathcal M}(t)\\) its set of aggregate epidemiological metrics, and \\(\\boldsymbol{S (t)}\\) its set of schedule-dependent (time-dependent) deterministic values. Then the above formulation still holds.</p> <p>In fact, in our code, we model \\(\\boldsymbol{\\mathcal C(t)}\\) using an <code>EpiCompartment</code> class, \\(\\boldsymbol{\\mathcal M}(t)\\) using an <code>EpiMetric</code> class, and \\(\\boldsymbol{\\mathcal S(t)}\\) using a <code>Schedule</code> class. We handle stochastic transitions using <code>TransitionVariable</code> and <code>TransitionVariableGroup</code> classes. These classes form some of the building blocks of the base model code. </p>"},{"location":"math_transitions/","title":"Stochastic Transitions","text":"<p>Written by LP, updated 11/21/2024 (work in progress) </p>"},{"location":"math_transitions/#marginal-transition-types","title":"Marginal transition types","text":"<p>Our codebase currently implements six types of transitions: three stochastic transitions and three deterministic counterparts.</p> <p>First we consider marginal (not joint) transition variables. For the following table, consider \\(y_{\\texttt{C}\\rightarrow\\texttt{C}^\\prime, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) from compartment \\(\\texttt{C}\\) to \\(\\texttt{C}^\\prime\\). Let \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t)\\) be its current value of its base count and \\(\\texttt{r} = \\texttt{r}_{a, \\ell}(t)\\) be its current value of its rate. Then depending on its transition type, its distribution (or deterministic value) is given below.</p> <p>Note that \\(\\alpha\\) is a function that converts a \"rate\" into a probability. It is given by: $$ \\alpha(\\texttt{r}, \\Delta t) = 1 - \\exp(-\\texttt{r} \\cdot \\Delta t) $$ and corresponds to the probability that a Poisson process with rate \\(\\texttt{r}\\) produces at least one event in an interval of length \\(\\Delta t\\). </p> <p>The following table provides the mathematical distribution or deterministic output for each transition type. </p> Output Binomial \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\alpha(\\texttt{r}, \\Delta t)\\right)\\) Binomial  Taylor Approx \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\texttt{r} \\cdot \\Delta t\\right)\\) Poisson \\(\\sim \\text{Poisson}\\left(\\lambda = \\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\right)\\) Binomial Deterministic \\(\\texttt{b} \\cdot \\alpha(\\texttt{r}, \\Delta t)\\) Binomial Taylor Approx Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\) Poisson Deterministic \\(\\texttt{b} \\cdot \\texttt{r} \\cdot \\Delta t\\)"},{"location":"math_transitions/#joint-transition-types","title":"Joint transition types","text":"<p>Here we describe joint transition variables. For the following table, consider a compartment \\(\\texttt{C}_0\\) with two outgoing compartments, \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). We describe \\(2\\) transition variables: \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) and \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). They respectively correspond to the number of people that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_1\\) and the number that transition from \\(\\texttt{C}_0\\) to \\(\\texttt{C}_2\\) at a given simulate state. Let their rates be \\(\\texttt{r}_1\\) and \\(\\texttt{r}_2\\) respectively.  </p> <p>We can also write the number that remain in \\(\\texttt{C}_0\\) explicitly as  \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) = \\texttt{C}_{0, a, \\ell}(t) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right) - y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\). Note that this quantity is purely for parametrizing multinomial distributions (which needs to have its probability parameters sum to \\(1\\)) and does not need to be literally modeled as a transition variable either mathematically or in code. </p> <p>Let \\(\\alpha\\) be defined as in the previous section on marginal transition types.</p> <p>The following table gives the parameters for multinomial transitions when \\(\\texttt{C}_0\\) has two outgoing compartments \\(\\texttt{C}_1\\) and \\(\\texttt{C}_2\\). The values \\([y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\), \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)]\\) are sampled jointly, using \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t) = \\texttt{C}_{0, a, \\ell}(t)\\) as the \"number of trials\" parameter \\(n\\) in a multinomial distribution.</p> Transition  Variable Group (Jointly Sampled) Multinomial Probability Parameter Multinomial with Taylor Approx Probability Parameter \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_1, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_1}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_1 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_2, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(\\frac{\\texttt{r}_2}{\\texttt{r}_1 + \\texttt{r}_2} \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(\\texttt{r}_2 \\cdot \\Delta t\\) \\(y_{\\texttt{C}_0\\rightarrow\\texttt{C}_0, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(1 - \\alpha(\\texttt{r}_1 + \\texttt{r}_2, \\Delta t)\\) \\(1 - (\\texttt{r}_1 + \\texttt{r}_2) \\Delta t\\) <p>IMPORTANT:</p> <ul> <li> <p>The transition variable group table formulas generalize to an arbitrary number of outgoing compartments -- however, this is not shown here.</p> </li> <li> <p>Note that Poisson is not included in the above table. Recall the splitting property of Poisson processes. If the total outflow (going to either compartment, \\(\\texttt{C}_1\\) or \\(\\texttt{C}_2\\)) is Poisson, we can split the process into two independent Poisson processes. So joint sampling is not actually needed. </p> </li> <li> <p>In contrast, the binomial distribution does not have such a splitting property. If the total outflow is binomial with parameters \\(n\\) and \\(p\\), then we cannot use a similar Poisson splitting technique to create two independent binomial random variables with the same number of trial parameters \\(n\\). Thus, joint sampling is needed. </p> </li> <li> <p>An advantage of binomial/multinomial transition variables (with joint sampling when there are multiple outflows from a compartment) is that we cannot have more people leaving the origin compartment than are actually in the compartment. We set the \"number of trials\" parameter in the multinomial distribution to be the current number of people in the compartment. This is NOT the case for Poisson transition variables, which are unbounded! Thus, we recommend using binomial/multinomial transition types.</p> </li> </ul>"},{"location":"old/","title":"Old","text":"<p>In this section, we provide an explanation of how the flu model (in <code>flu_components.py</code>) is created from the base model components (in <code>base_components.py</code>). In doing so, we also demonstrate how to create other customized models from the base model components. We also provide justification for design choices, in a way intended to educate users on some of the implementation and computation challenges in writing scalable and adaptable compartmental models. </p> <p>Writing code to create a customized compartmental model requires correct use of inheritance, composition, and abstract base classes. We strongly recommend reading this tutorial for a good primer on those subjects. We also recommend learning about the <code>dataclass</code> decorator in Python (see this blogpost, for example).</p>"},{"location":"old/#creating-a-model-from-base-components-details","title":"Creating a model from base components: details","text":"<p>Creating a compartment model requires the following steps.</p> <ol> <li> <p>Formulate the compartment model mathematically, and write down all <code>EpiCompartment</code>, <code>TransitionVariable</code>, <code>TransitionVariableGroup</code> (jointly sampled sets of transition variables), and <code>StateVariable</code> objects needed for the model. </p> </li> <li> <p>Create a new file that imports the <code>base_components</code> module. We import this module as <code>base</code>. </p> </li> <li> <p>Create two <code>JSON</code> files: one for fixed parameters and one for initial values of state variables. </p> <p>a. For the fixed parameters <code>JSON</code> file, required fields are <code>\"num_age_groups\"</code>, <code>\"num_risk_groups\"</code>, and <code>\"total_population_val\"</code>. All other fields must correspond to fixed parameters in the model -- these are used throughout model computation.</p> <ul> <li>See <code>flu_demo_input_files / fixed_params.json</code>.</li> </ul> <p>b. For the initial values of state variables <code>JSON</code> file, there must be a field for each <code>StateVariable</code> object used in the model. These values correspond to the initial values of these state variables. For example, this file contains initial populations of each <code>EpiCompartment</code>, expressed as a list of lists corresponding to age groups and risk groups. Similarly, this file contains starting values for each <code>EpiMetric</code>. We also need fields for all <code>DynamicVal</code> and <code>Schedule</code> objects in the model, although their values can be set to <code>null</code> since their initial state will be updated automatically (either according to a deterministic calendar or a simulate state trigger). We just need to include their names for bookkeeping purposes. </p> <ul> <li>See <code>flu_demo_input_files / state_variables_init_vals.json</code>.</li> </ul> </li> <li> <p>Create subclasses to hold data. </p> <p>a. Create a subclass of <code>base.FixedParams</code> to hold the model's fixed parameters. For each name in the fixed parameters <code>JSON</code> file, there should be a corresponding attribute (with the same name) in this subclass.</p> <ul> <li>See <code>FluFixedParams</code> in <code>flu_components.py</code>.</li> </ul> <p>b. Create a subclass of <code>base.SimState</code> to hold the model's simulation state. For each name in the initial values of state variables <code>JSON</code> file, there should be a corresponding attribute (with the same name) in this subclass. </p> <ul> <li>See <code>FluSimState</code> in <code>flu_components.py</code>.</li> </ul> </li> <li> <p>For each transition in the model, create a subclass of <code>base.TransitionVariable</code> and provide a concrete implementation of the abstract method <code>get_current_rate</code>. The function <code>get_current_rate</code> returns the value of the current rate, and is a function of a <code>FluSimState</code> instance and a <code>FluFixedParams</code> instance. These arguments allow us to access various values needed for the computation. </p> <ul> <li>See <code>SusceptibleToExposed</code> subclass in <code>flu_components.py</code>. The function <code>get_current_rate</code> implements the formula for computing the current rate that people transition from the susceptible to exposed compartment. For example, <code>get_current_rate</code> grabs <code>sim_state.IS</code>, <code>sim_state.IP</code>, and <code>sim_state.IA</code>, because the current values of the symptomatic, pre-symptomatic, and asymptomatic infectious compartments are needed for the rate computation.</li> </ul> </li> <li> <p>For each dynamic value in the model, create a subclass of <code>base.DynamicVal</code> and provide a concrete implementation of the abstract method <code>update_current_val</code>. The function <code>update_current_val</code> also takes a <code>FluSimState</code> instances and <code>FluFixedParams</code> instance as arguments, analogously to <code>TransitionVariable</code> subclasses. It updates the <code>current_val</code> attribute in-place.</p> <ul> <li>See <code>BetaReduct</code> in <code>flu_components.py</code>. Note here we have also customized the <code>_init_</code> method and added an attribute <code>permanent_lockdown</code>, to accommodate additional functionality. </li> </ul> </li> <li> <p>For each schedule in the model, create a subclass of <code>base.Schedule</code> and provide a concrete implementation of the abstract method <code>update_current_val</code>, which should be a function of the current date (a <code>datetime.date</code> instance). This function updates the <code>current_val</code> attribute in place.  </p> <ul> <li>See <code>AbsoluteHumidity</code> in <code>flu_components.py</code>. Note we update the current value using the helper function <code>absolute_humidity_func</code>.   </li> </ul> </li> <li> <p>Create a subclass of <code>base.ModelConstructor</code>. Customize the <code>_init_</code> function and provide concrete implementations for the six abstract methods (listed below). </p> <ul> <li>See <code>FluModelConstructor</code> in <code>flu_components.py</code>.</li> </ul> <p>a. Customize the <code>_init_</code> function.</p> <ul> <li>See <code>_init_</code> in <code>FluModelConstructor</code>. This method first calls <code>super()._init_()</code>, which runs the initialization method of the parent class. Importantly, the parent class initialization creates dictionaries that hold our objects (for example, it creates the attribute <code>compartment_lookup</code>). Then we assign the <code>config</code>, <code>fixed_params</code>, and <code>sim_state</code> attributes according to the contents of user-specified <code>JSON</code> files.</li> </ul> <p>b. Provide a concrete implementation of <code>setup_epi_compartments</code>. Specifically, for every compartment, create an entry in <code>compartment_lookup</code>, with the name as the key and the value as the corresponding <code>EpiCompartment</code> instance. Names should match the compartment names in the initial values of state variables <code>JSON</code>.</p> <p>c. Provide a concrete implementation of <code>setup_dynamic_vals</code>. Specifically, for every dynamic value, create an entry in <code>dynamic_val_lookup</code>, with the name as the key and the value as the corresponding <code>DynamicVal</code> instance. Names should match the dynamic value names in the initial values of state variables <code>JSON</code>.</p> <ul> <li>In <code>FluModelConstructor</code>, we create an entry in <code>dynamic_val_lookup</code> with the key of <code>\"beta_reduct\"</code> and the value of a properly initialized <code>BetaReduct</code> instance. Note that <code>BetaReduct</code> is a <code>DynamicVal</code>, but we cannot use <code>DynamicVal</code> directly, as it is an abstract class. We have to use the relevant concretely implemented subclass.</li> </ul> <p>d. Provide a concrete implementation of <code>setup_schedules</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).</p> <p>e. Provide a concrete implementation of <code>setup_transition_variables</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).</p> <p>f. Provide a concrete implementation of <code>setup_transition_variable_groups</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).      </p> <p>g. Provide a concrete implementation of <code>setup_epi_metrics</code> (instructions are analogous to those for <code>setup_dynamic_vals</code>).  </p> </li> </ol>"},{"location":"old/#creating-a-model-from-base-components-checklist","title":"Creating a model from base components: checklist","text":"<p>Here we provide a brief outline of steps for creating a compartment model, intended as a reminder checklist. Please see the previous section for explanatory details. </p> <ol> <li> <p>Formulate the compartment model.</p> </li> <li> <p>Create a new file that imports the <code>base_components</code> module. We import this module as <code>base</code>. </p> </li> <li> <p>Create two <code>JSON</code> files: one for fixed parameters and one for initial values of state variables. </p> <ul> <li>Initial values for schedules and dynamic values can be left as <code>null</code>, but they still must have a field in the <code>JSON</code> file. </li> </ul> </li> <li> <p>Create subclasses to hold data: a subclass of <code>base.FixedParams</code> and a subclass of <code>base.SimState</code>. </p> <ul> <li>Note that there should be a one-to-one mapping between the fixed parameters <code>JSON</code> file and the attributes of <code>base.FixedParams</code>, and similarly for the initial values of state variables <code>JSON</code> and the attributes of <code>base.SimState</code>. </li> </ul> </li> <li> <p>For each transition variable in the model, create a unique subclass of <code>base.TransitionVariable</code> corresponding to that transition and provide a concrete implementation of <code>get_current_rate</code>.</p> </li> <li> <p>For each dynamic value in the model, create a subclass of <code>base.DynamicVal</code> and provide a concrete implementation of <code>update_current_val</code>.</p> </li> <li> <p>For each schedule in the model, create a subclass of <code>base.Schedule</code> and provide a concrete implementation of <code>update_current_val</code>.</p> </li> <li> <p>Create a subclass of <code>base.ModelConstructor</code>. Customize the <code>_init_</code> function, making sure to assign the <code>config</code>, <code>fixed_params</code>, and <code>sim_state</code> attributes to instances of <code>base.Config</code>, <code>base.FixedParams</code>, and <code>base.SimState</code>. Provide concrete implementations of <code>setup_epi_compartments</code>, <code>setup_dynamic_vals</code>, <code>setup_schedules</code>, <code>setup_transition_variables</code>, <code>setup_transition_variable_groups</code>, and <code>setup_epi_metrics</code>. </p> </li> </ol> <p>Note: figures below were generated with older flu model version without presymptomatic and asymptomatic infected compartments -- figures generated with updated code will look slightly different. </p> <p>Here we provide a quickstart tutorial to help users immediately start playing with the flu model in <code>flu_components.py</code> with \"toy\" inputs given by <code>JSON</code> files in <code>flu_demo_input_files</code>. Recall that the structure (functional form) of the flu model is specified in <code>flu_components.py</code>, and the input files simply specify fixed parameter values and initial values for state variables.  See this page for the mathematical formulation of the flu model. For creating their own custom input files, users should refer to tables on this page that map code variable names to their respective math variables and specify variable dimensions. </p> <p>The code snippet below is from <code>flu_demo.py</code>. The script can be run directly from the terminal using </p> <pre><code>python flu_demo.py\n</code></pre> <p>Here\u2019s the basic procedure to populate the flu model using input files:</p> <ol> <li> <p>Create a <code>FluModelConstructor</code> instance that takes three file paths as input: the configuration file path, fixed parameter values file path, and initial values file path (all in <code>JSON</code> format).</p> </li> <li> <p>Use this constructor to create a <code>TransmissionModel</code> instance whose functional form is specified by <code>flu_components.py</code> and whose fixed parameter values and initial values are specified in the three aforementioend files.</p> </li> </ol> <p>After this, we can simulate the model and plot its behavior. Below, we simulate 300 days. </p> <pre><code>import numpy as np\nfrom pathlib import Path\n\nfrom flu_components import FluModelConstructor\nfrom plotting import create_basic_compartment_history_plot\n\n# Obtain path to folder with JSON input files\nbase_path = Path(__file__).parent / \"flu_demo_input_files\"\n\n# Get filepaths for configuration, fixed parameter values, and\n#   initial values of state variables\nconfig_filepath = base_path / \"config.json\"\nfixed_params_filepath = base_path / \"fixed_params.json\"\nstate_vars_init_vals_filepath = base_path / \"state_variables_init_vals.json\"\n\n# Create a constructor using these filepaths\nflu_demo_constructor = \\\n    FluModelConstructor(config_filepath,\n                        fixed_params_filepath,\n                        state_vars_init_vals_filepath)\n\n# Create TransmissionModel instance from the constructor,\n#   using a random number generator with starting seed 888888\n#   to generate random variables\nflu_demo_model = flu_demo_constructor.create_transmission_model(888888)\n\n# Simulate 300 days\nflu_demo_model.simulate_until_time_period(300)\n\n# Plot\ncreate_basic_compartment_history_plot(flu_demo_model,\n                                      \"flu_demo_model.png\")\n</code></pre> <p></p> <p>The following code snippets and outputs below replicate the experience of working in a Python interactive console.</p> <p>After simulating 300 days, the <code>current_simulation_day</code> counter indeed is 300, and the attribute <code>current_real_date</code> gives us the corresponding real-world date associated with the simulation day counter.</p> <pre><code>flu_demo_model.current_simulation_day\n# 300\n\nflu_demo_model.current_real_date\n# datetime.date(2023, 6, 4)\n</code></pre> <p>Note that subsequent <code>simulate_until_time_period</code> calls will start from where the simulation last ended, and its argument <code>last_simulation_day</code> must be greater than the model's <code>current_simulation_day</code>. For example, after running <code>flu_demo_model.simulate_until_time_period(300)</code>, a command like <code>flu_demo_model.simulate_until_time_period(100)</code> is invalid (we cannot simulate backwards in time), but <code>flu_demo_model.simulate_until_timeperiod(305)</code> starts from day 300 and continues.</p> <p><code>TransmissionModel</code> instances have a <code>StateVariableManager</code> that manages and holds StateVariables (EpiCompartments, EpiMetrics, DynamicVals, and Schedules). Using the command below, we can access the state of the simulation after we simulated the model for 300 days. </p> <pre><code>flu_demo_model.sim_state\n# FluSimState(S=array([[306539.],\n#       [261363.]]), E=array([[31501.],\n#       [36027.]]), I=array([[105991.],\n#       [114542.]]), H=array([[ 98354.],\n#       [104663.]]), R=array([[175885.],\n#       [186626.]]), D=array([[281730.],\n#       [296779.]]), population_immunity_hosp=array([[0.11555325],\n#       [0.12078151]]), population_immunity_inf=array([[0.11555325],\n#       [0.12078151]]), absolute_humidity=12.31748, \n#       flu_contact_matrix=array([[[[2.], [0.5]]], [[[1.95], [1.4]]]]))\n</code></pre> <p>We can also use our model's built-in dictionary to look up simulation objects (any StateVariable, as well as any TransitionVariable and TransitionVariableGroup) by name. Here, <code>S</code> is an <code>EpiCompartment</code> instance, and we can see its current value at the current day of the simulation. </p> <pre><code>flu_demo_model.lookup_by_name[\"S\"]\n# &lt;base_components.EpiCompartment object at 0x174a79750&gt;\n\nflu_demo_model.lookup_by_name[\"S\"].current_val\n# array([[306539.],\n#        [261363.]])\n</code></pre> <p>We can also access a StateVariable's history with the attribute <code>history_vals_list</code>. For example, <code>flu_demo_model.lookup_by_name[\"S\"].history_vals_list</code> gives a list of all the previous current values of the \"Susceptible\" compartment. The \\(i\\)th element in the list holds the compartment's value at the end of simulation day \\(i\\). </p> <p>Next, we look at the current value (most recent realization) of the TransitionVariable <code>new_dead.</code> We also look at its <code>current_rate</code> attribute, which is the rate that generated the most recent realization. </p> <pre><code>flu_demo_model.lookup_by_name[\"new_dead\"].current_val\n# array([[406.],\n#        [435.]])\n\nflu_demo_model.lookup_by_name[\"new_dead\"].current_rate\n# array([[0.00823744],\n#        [0.00820603]])\n</code></pre> <p>We can reset the simulation to restart the simulation or clear the simulation's state and history to run a new replication on the same model, with the same initial conditions. Important note: resetting the simulation does NOT reset the random number generator -- random numbers will continue where the generator last left off. <pre><code>flu_demo_model.reset_simulation()\n</code></pre></p> <p>Notice that the current simulation day has returned to 0 and the simulation state has returned to its initial state. Each StateVariable's history has also been cleared. <pre><code>flu_demo_model.current_simulation_day\n# 0\n\nflu_demo_model.sim_state\n# FluSimState(S=array([[980000.],\n#       [980000.]]), E=array([[10000.],\n#       [10000.]]), I=array([[10000.],\n#       [10000.]]), H=array([[0.],\n#       [0.]]), R=array([[0.],\n#       [0.]]), D=array([[0.],\n#       [0.]]), population_immunity_hosp=array([[0.5],\n#       [0.5]]), population_immunity_inf=array([[0.5],\n#       [0.5]]), absolute_humidity=None, flu_contact_matrix=None)\n\nflu_demo_model.lookup_by_name[\"S\"].history_vals_list\n# []\n</code></pre></p> <p>To reset the random number generator, we must use the <code>modify_random_seed</code> method -- and pass the initial random seed. This resets the numpy RNG object to a state given by this seed. We can also use the <code>modify_random_seed</code> method to handle random number generation more broadly, and ensure that each simulation replication uses independent random numbers. To handle random number generation responsibly, refer to these two links here and here.</p> <p>Suppose that we want to modify configuration values, values of fixed parameters, or initial values. We can modify these values on our model constructor, and then create a new model instance. For example, below we change the transition type to \"binomial_deterministic\" and the beta baseline value to be \\(0\\). By changing <code>beta_baseline</code> to \\(0\\), no transmission occurs, and the plot verifies this. </p> <pre><code>flu_demo_constructor.config.transition_type = \"binomial_deterministic\"\nflu_demo_constructor.fixed_params.beta_baseline = 0\n\nflu_demo_model_beta_baseline_zero = \\\n    flu_demo_constructor.create_transmission_model(999999)\n\ncreate_basic_compartment_history_plot(flu_demo_model_beta_baseline_zero,\n                                      \"flu_demo_model_beta_baseline_zero.png\")\n</code></pre> <p></p>"}]}