{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"City-level Transmission (CLT) Base Model","text":"<p>The CLT base model is a mathematical framework and modular codebase for scalable compartmental models of respiratory virus transmission in a city. This model is written by the Meyers Lab and epiENGAGE center.</p> <p>The mathematical framework is inspired by the immunoSEIRS model of the Meyers Lab (see Bi and Bandekar et al. 2023, Bi et al. 2022 and Bouchnita et al. 2021 for some related recent publications).</p> <p>Documentation is created by Linda Pei (\"LP\"). Base model code is created by LP in collaboration with Shuotao \"Sonny\" Diao, Remy Pasco, and Emily Javan, and with supervision from Dave Morton and Lauren Meyers. Special thanks to Cary Murray for generous guidance on software engineering design. </p>"},{"location":"#codebase-layout","title":"Codebase layout","text":"<pre><code>README.md               # Read me! :)\n\nbase_components.py      # Base classes used to create a compartmental model.\n\nflu_components.py       # A specific S-E-I-H-R-D model for influenza.\n\nflu_tests.py            # Suite of pytest tests for flu_components.py\n\nflu_demo.py             # Demo implementation of flu_components.py\n                          flu model for tutorial and testing purposes.\n\nflu_demo_input_files    # Collection of .json and .csv files used as \n                          input values for flu_demo.py. These values are\n                          \"toy\" predefined values for demo purposes only. \n                          Realistic applications will use estimation \n                          and calibration from real-world data.\n</code></pre>"},{"location":"math_flu_components/","title":"Flu Model: Mathematical Formulation","text":"<p>Written by LP, updated 11/11/2024 (work in progress) </p>"},{"location":"math_flu_components/#flu-model-deterministic-differential-equations","title":"Flu model: deterministic differential equations","text":"<ul> <li>\\(t \\in \\mathbb N\\): current simulation day</li> <li>\\(a\\): age group, \\(A\\): set of all age groups</li> <li>\\(\\ell\\): risk group, \\(L\\): set of all risk groups</li> <li>\\(i\\): type of immunity-inducing event, \\(\\mathcal{I} := \\left\\{\\text{H1}, \\text{H3}, \\text{V}\\right\\}\\): the set of all types of immunity-inducing events: infection by H1N1, infection by H3N2, and vaccination, respectively.</li> <li>\\(\\boldsymbol{O}\\): \\(\\lvert A \\rvert \\times \\lvert L \\rvert \\times \\lvert \\mathcal{I} \\rvert\\) matrix, where the \\((a, \\ell, i)\\)th element is the positive constant modeling the saturation of antibody production in individuals in age group \\(a\\) and risk group \\(\\ell\\) who had immunity-inducing event \\(i\\).</li> </ul> <p>Population-level immunity against infection (derived from H1N1 infections, H3N2 infections, and vaccinations respectively)</p> \\[ \\frac{dM^I_{a,\\ell,H1}(t)}{dt} = \\frac{g^I_{H1} p_{H1}(t) \\eta(t) R_{a,\\ell}(t)}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal I} O_{a,\\ell, i} M^I_{a,\\ell, i}(t)\\right)} - w^I_{H1} M^I_{a,\\ell,H1}(t) \\] \\[ \\frac{dM^I_{a,\\ell,H3}(t)}{dt} = \\frac{g^I_{H3} p_{H3}(t) \\eta(t) R_{a,\\ell}(t)}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal I} O_{a,\\ell, i} M^I_{a,\\ell, i}(t)\\right)} - w^I_{H3} M^I_{a,\\ell,H3}(t) \\] \\[ \\frac{dM^I_{a,\\ell,V}(t)}{dt} = g^I_V V(t - \\delta) - w^I_V M^I_{a,\\ell,V}(t) \\] <p>where</p> <ul> <li>\\(g^I_{H1}\\): factor by which population-level immunity against infection grows after each H1N1 case that recovers.</li> <li>\\(g^I_{H3}\\): factor by which population-level immunity against infection grows after each H3N2 case that recovers.</li> <li>\\(g^I_V\\): factor by which population-level immunity against infection grows after each vaccination.</li> <li>\\(\\boldsymbol{N}\\): \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) matrix corresponding to total population, where element \\(N_{a, \\ell}\\) is the total population of age group \\(a\\) and risk group \\(\\ell\\).</li> <li>\\(\\boldsymbol{p} = \\boldsymbol{p}(t) = [p_{H1}(t)\\), \\(p_{H3}(t)]\\): where elements correspond to prevalence of H1N1, H3N2 respectively.</li> <li>\\(w^I_{H1}\\): rate at which H1N1 infection-induced immunity against infection wanes.</li> <li>\\(w^I_{H3}\\): rate at which H3N2 infection-induced immunity against infection wanes.</li> <li>\\(w^I_V\\): rate at which vaccine-induced immunity against infection wanes.</li> <li>\\(V(t)\\): number of vaccine doses administered at time \\(t\\).</li> <li>\\(\\delta\\): number of days after dose for vaccine to become effective.</li> </ul> <p>Population-level immunity against hospitalization (derived from H1N1 infections, H3N2 infections, and vaccinations respectively)</p> \\[ \\frac{dM^H_{a,\\ell,H1}(t)}{dt} = \\frac{g^H_{H1} p_{H1}(t) \\eta(t) R_{a,\\ell}(t)}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal{I}} O_{a,\\ell, i} M^H_{a,\\ell, i}(t)\\right)} - w^H_{H1} M^H_{a,\\ell,H1}(t) \\] \\[ \\frac{dM^H_{a,\\ell,H3}(t)}{dt} = \\frac{g^H_{H3} p_{H3}(t) \\eta(t) R_{a,\\ell}(t)}{N_{a,\\ell} \\left(1 + \\sum_{i \\in \\mathcal{I}} O_{a,\\ell, i} M^H_{a,\\ell, i}(t)\\right)} - w^H_{H3} M^H_{a,\\ell,H3}(t) \\] \\[ \\frac{dM^H_{a,\\ell,V}(t)}{dt} = g^H_V V(t) - w^H_V M^H_{a,\\ell,V}(t) \\] <p>where</p> <ul> <li>\\(p_{H1}(t)\\), \\(p_{H3}(t)\\), \\(V(t)\\), \\(\\delta\\): see above.</li> <li>\\(g^H_{H1}\\): factor by which population-level immunity against hospitalization grows after each H1N1 case that recovers.</li> <li>\\(g^H_{H3}\\): factor by which population-level immunity against hospitalization grows after each H3N2 case that recovers.</li> <li>\\(g^H_V\\): factor by which population-level immunity against hospitalization grows after each vaccination.</li> <li>\\(w^H_{H1}\\): rate at which H1N1 infection-induced immunity against hospitalization wanes.</li> <li>\\(w^H_{H3}\\): rate at which H3N2 infection-induced immunity against hospitalization wanes.</li> <li>\\(w^H_V\\): rate at which vaccine-induced immunity against hospitalization wanes.</li> </ul> <p>SEIHRD equations</p> \\[ \\frac{dS_{a,\\ell}(t)}{dt} = \\underbrace{\\eta R_{a,\\ell}(t)}_{\\text{new susceptible}} -\\underbrace{S_{a,\\ell}(t) \\cdot \\sum_{a^\\prime \\in A, \\ell^\\prime \\in L} \\frac{\\beta(t) \\phi_{a, \\ell, a^\\prime, \\ell^\\prime}(t) I_{a^\\prime, \\ell^\\prime}(t)}{N_{a^\\prime, \\ell^\\prime} (1 + \\boldsymbol{\\Lambda^{I, I}(t)})}}_{\\text{new exposed}} \\] \\[ \\frac{dE_{a,\\ell}(t)}{dt} = \\underbrace{S_{a,\\ell}(t) \\cdot \\sum_{a^\\prime \\in A, \\ell^\\prime \\in L} \\frac{\\beta(t) \\phi_{a, \\ell, a^\\prime, \\ell^\\prime}(t) I_{a^\\prime, \\ell^\\prime}(t)}{N_{a^\\prime, \\ell^\\prime} (1 + \\boldsymbol{\\Lambda^{I, I}(t)})}}_{\\text{new exposed}} - \\underbrace{\\sigma E_{a,\\ell}(t)}_{\\text{new infected}} \\] \\[ \\frac{dI_{a,\\ell}(t)}{dt} = \\underbrace{\\sigma E_{a,\\ell}(t)}_{\\text{new infected}} - \\underbrace{(1-\\tilde{\\mu}_{a,\\ell})\\gamma I_{a,\\ell}(t)}_{\\text{new recovered from home}} - \\underbrace{\\frac{\\zeta \\tilde{\\mu}_{a,\\ell} I_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}(t)}}}_{\\text{new hospitalized}} \\] \\[ \\frac{dH_{a,\\ell}(t)}{dt} = \\underbrace{\\frac{\\zeta \\tilde{\\mu}_{a,\\ell} I_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}(t)}}}_{\\text{new hospitalized}} - \\underbrace{(1-\\tilde{\\nu}_{a,\\ell})\\gamma_H H_{a,\\ell}(t)}_{\\text{new recovered from hospital}} - \\underbrace{\\frac{\\pi \\tilde{\\nu}_{a,\\ell} H_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}(t)}}}_{\\text{new dead}} \\] \\[ \\frac{dR_{a,\\ell}(t)}{dt} = \\underbrace{(1-\\tilde{\\mu}_{a,\\ell}) \\gamma I_{a,\\ell}(t)}_{\\text{new recovered from home}} + \\underbrace{(1-\\tilde{\\nu}_{a,\\ell})\\gamma_H H_{a,\\ell}(t)}_{\\text{new recovered from hospital}} - \\underbrace{\\eta R_{a,\\ell}(t)}_{\\text{new susceptible}} \\] \\[ \\frac{dD_{a,\\ell}(t)}{dt} = \\underbrace{\\frac{\\pi \\tilde{\\nu}_{a,\\ell} H_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{D, H}}(t)}}_{\\text{new dead}} \\] <p>where we have the following terms that characterize the effect of population-level immunities:</p> \\[ \\boldsymbol{\\Lambda^{I, I}(t)} = \\left[\\boldsymbol{K_{a,\\ell}^I}(p(t))\\right]^T \\boldsymbol{M_{a,\\ell}^I}(t) \\] \\[ \\boldsymbol{\\Lambda^{H, H}(t)} = \\left[\\boldsymbol{K_{a,\\ell}^H}(p(t))\\right]^T \\boldsymbol{M_{a,\\ell}^H}(t) \\] \\[ \\boldsymbol{\\Lambda^{D, H}}(t) = \\left[\\boldsymbol{K_{a,\\ell}^D}(p(t))\\right]^T\\boldsymbol{M_{a,\\ell}^H}(t) \\] <p>and where</p> <ul> <li>\\(\\beta(t) = \\beta_0 (1 + q(t))\\): time-dependent transmission rate per day.</li> <li>\\(q(t)\\): seasonality parameter based on absolute humidity.</li> <li>\\(\\phi_{a, \\ell, a^\\prime, \\ell^\\prime}(t)\\): mixing rates between age-risk group \\(a, \\ell\\) and \\(a^\\prime, \\ell^\\prime\\). Specifically, the interpretation is: for an individual in age-risk group \\(a, \\ell\\), the number of contacts they have in age-risk group \\(a^\\prime, \\ell^\\prime\\) per day.</li> <li>\\(\\gamma, \\gamma_H\\): recovery rates for infected and hospital compartments respectively, so that \\(1/\\gamma\\) is the average number of days it takes for an infected person not in the hospital to recover, and \\(1/\\gamma_H\\) is analogous, but for an infected person in the hospital. </li> <li>\\(\\sigma\\): infection rate (exposed to infected transition rate), so that \\(1/\\sigma\\) is the average number of days after exposure before a person becomes infectious.</li> <li>\\(\\boldsymbol{\\tilde{\\mu}}\\), where \\(\\tilde{\\mu}_{a, \\ell} = \\frac{\\mu_{a, \\ell}\\gamma}{\\zeta - \\mu_{a, \\ell}(\\zeta-\\gamma)}\\): adjusted hospitalization rate (as in, proportion hospitalized based on age-risk group \\(a, \\ell\\) group) actually used in model -- this adjustment is necessary to ensure actual proportion hospitalized recapitulates \\([\\mu_{a, \\ell}]\\).</li> <li>\\(\\boldsymbol{\\mu}\\): \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) hospitalization rate (proportion hospitalized based on age-risk group \\(a, \\ell\\)).</li> <li>\\(\\zeta\\): hospitalization rate (infected to hospital transition rate), so that \\(1/\\zeta\\) is the average number of days a person is infected before going to the hospital.</li> <li>\\(\\boldsymbol{\\tilde{\\nu}}\\), where \\(\\tilde{\\nu}_{a, \\ell} = \\frac{\\nu_{a, \\ell}\\gamma_H}{\\pi - \\nu_{a, \\ell}(\\zeta-\\gamma_H)}\\): adjusted hospitalization rate (as in, proportion hospitalized based on age group) actually used in model -- this adjustment is necessary to ensure actual proportion hospitalized recapitulates \\([\\nu_{a, \\ell}]\\).</li> <li>\\(\\boldsymbol{\\nu}\\): \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) in-hospital mortality rate (proportion who die based on age-risk group \\(a, \\ell\\)).</li> <li>\\(\\pi\\): death rate from hospital, so that \\(1/\\pi\\) is the average number of days a person spends in the hospital before dying.</li> <li>\\(\\eta\\): rate at which recovered individuals become susceptible, so that \\(1/\\eta\\) is the average number of days a person is totally immune from reinfection until being susceptible again.</li> </ul> <p>The following are all \\(\\lvert A \\rvert \\times \\lvert L \\rvert \\times \\lvert \\mathcal I \\rvert\\) matrices:</p> <ul> <li>\\(\\boldsymbol{K}^I(\\boldsymbol{p}) = [\\boldsymbol{K}^I_{H1}(p_{H1}), \\boldsymbol{K}^I_{H3}(p_{H3}), \\boldsymbol{K}^I_{V}]\\): reduction in infection risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^{H}(\\boldsymbol{p}) = [\\boldsymbol{K}^H_{H1}(p_{H1}), \\boldsymbol{K}^H_{H3}(p_{H3}), \\boldsymbol{K}^H_{V}]\\): reduction in hospitalization risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{K}^D(\\boldsymbol{p}) = [\\boldsymbol{K}^D_{H1}(p_{H1}), \\boldsymbol{K^D}_{H3}(p_{H3}), \\boldsymbol{K}^D_{V}]\\): reduction in death risk from given immunity-inducing event.  </li> <li>\\(\\boldsymbol{M}^I = \\boldsymbol{M}^I(t) = [\\boldsymbol{M}^I_{H1}(t), \\boldsymbol{M}^I_{H3}(t), \\boldsymbol{M}^I_{V}(t)]\\): population-level immunity from infection (induced by H1 infection, H3 infection, vaccination respectively).  </li> <li>\\(\\boldsymbol{M}^H = \\boldsymbol{M}^H(t) = [\\boldsymbol{M}^H_{H1}(t), \\boldsymbol{M}^H_{H3}(t), \\boldsymbol{M}^H_{V}(t)]\\): population-level immunity from hospitalization (induced by H1 infection, H3 infection, vaccination respectively).</li> </ul> <p>Note that prevalence is time-dependent, but we use \\(\\boldsymbol{p} = \\boldsymbol{p}(t)\\) for notation simplicity. </p>"},{"location":"math_flu_components/#flu-model-discretized-stochastic-implementation","title":"Flu model: discretized stochastic implementation","text":"<p>To simulate this compartmental model, we discretize the deterministic differential equations and treat transitions between compartments as stochastic to model uncertainty. We extend the notation from the deterministic differential equations to capture the stochastic elements.</p> <p>Let \\(\\boldsymbol{\\mathcal X}(t) = \\left\\{\\boldsymbol{S}(t), \\boldsymbol{E}(t), \\boldsymbol{I}(t), \\boldsymbol{H}(t), \\boldsymbol{R}(t), \\boldsymbol{D}(t), \\boldsymbol{M}^I(t), \\boldsymbol{M}^H(t), q(t), \\boldsymbol{\\phi}(t), \\boldsymbol{p}(t), V(t)\\right\\}\\) be the \"simulate state\" at time \\(t\\). \\(\\boldsymbol{\\mathcal X}(t)\\) is a set of matrices. </p> <p>Let \\(\\boldsymbol{\\Theta} = \\left\\{\\boldsymbol{O}, \\boldsymbol{N}, \\boldsymbol{g}^I, \\boldsymbol{w}^I, \\boldsymbol{g}^H, \\boldsymbol{w^H}, \\beta_0, \\gamma, \\gamma_H, \\sigma, \\boldsymbol{\\mu}, \\zeta, \\boldsymbol{\\nu}, \\pi, \\eta \\right\\}\\) be the set of fixed parameters. We define notation \\(\\boldsymbol{g}^I = [g^I_{H1}, g^I_{H3}, g^I_V]\\),  \\(\\boldsymbol{w}^I = [w^I_{H1}, w^I_{H3}, w^I_V]\\), \\(\\boldsymbol{g}^H = [g^H_{H1}, g^H_{H3}, g^H_V]\\), and \\(\\boldsymbol{w}^H = [w^H_{H1}, w^H_{H3}, w^H_V]\\). </p> <p>Then given initial state \\(\\boldsymbol{\\mathcal X}_0 = \\boldsymbol{\\mathcal X}(0)\\), we can formulate our discretized stochastic implementation as</p> \\[ \\boldsymbol{\\mathcal X}(t + \\Delta t) = \\boldsymbol{\\mathcal X}(t) + f\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega; \\boldsymbol{\\Theta}\\right) \\quad \\text{for} \\quad t \\ge 0, \\] <p>where \\(f\\) is parametrized by \\(\\boldsymbol{\\Theta}\\), and depends on the step size of discretization \\(\\Delta t\\) and a sample path \\(\\omega\\). We assume that each sample path \\(\\omega\\) is realized from a random process that does not depend on \\(\\boldsymbol{\\mathcal X}(t)\\) or \\(\\Delta t\\) for each \\(t\\). When we are discussing a single model with a fixed set of parameters \\(\\boldsymbol{\\Theta}\\), we drop the \\(\\boldsymbol{\\Theta}\\) notation for simplicity.  </p> <p>Now we formulate how we implement discretized stochastic transitions between epidemiological compartments \\(\\boldsymbol{\\mathcal C}(t) = \\left\\{\\boldsymbol{S}(t), \\boldsymbol{E}(t), \\boldsymbol{I}(t), \\boldsymbol{H}(t), \\boldsymbol{R}(t), \\boldsymbol{D}(t)\\right\\}\\).  The population-level immunity variables \\(\\boldsymbol{M(t)} = \\left\\{\\boldsymbol{M}^I(t), \\boldsymbol{M}^H(t)\\right\\}\\) are updated using \\(\\boldsymbol{M}^I(t+\\Delta t) = \\boldsymbol{M}^I(t) + \\frac{d\\boldsymbol{M}^I(t)}{dt} \\Delta t\\) and \\(\\boldsymbol{M}^H(t+\\Delta t) = \\boldsymbol{M}^H(t) + \\frac{d\\boldsymbol{M}^H(t)}{dt} \\Delta t\\), where \\(\\frac{d\\boldsymbol{M}^I(t)}{dt}\\) and \\(\\frac{d\\boldsymbol{M}^H(t)}{dt}\\) are defined in the previous section. Note that we can think of them as aggregate epidemiological metrics that are are deterministic functions of the simulation state. We also assume that \\(q(t)\\), \\(\\boldsymbol{\\phi}(t)\\), \\(\\boldsymbol{p}(t)\\), and \\(V(t)\\)  are updated deterministically according to some \"schedule.\" </p> <p>We model stochastic transitions between compartments using \"transition variables.\" The <code>TransitionVariable</code> class in the code is another building block of the base model. Transition variables correspond to incoming and outgoing flows of epidemiological compartments (see the SEIHRD equations above). In total, we have transition variables for: new exposed, new susceptible, new infected, new recovered from home, new hospitalized, new recovered from hospital, and new dead. Each \\(\\boldsymbol{T}^i(t) \\in \\boldsymbol{\\mathcal T}(t)\\) is an \\(\\lvert A \\rvert \\times \\lvert L \\rvert\\) matrix with elements corresponding to age-risk group \\(a, \\ell\\).  </p> <p>Below we formulate the discretized stochastic transitions between compartments:</p> \\[ S_{a,\\ell}(t + \\Delta t) = S_{a, \\ell}(t) + \\underbrace{y_{R\\rightarrow S, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new susceptible}} - \\\\ \\underbrace{y_{S\\rightarrow E,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new exposed}} \\] \\[ E_{a,\\ell}(t + \\Delta t) = E_{a, \\ell}(t) + \\underbrace{y_{S\\rightarrow E,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new exposed}} - \\underbrace{y_{E\\rightarrow I,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new infected}} \\] \\[ \\begin{align*} I_{a,\\ell}(t + \\Delta t) = I_{a, \\ell}(t) &amp;+ \\underbrace{y_{E\\rightarrow I,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new infected}} \\\\ &amp;- \\underbrace{y^*_{I\\rightarrow R,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new recovered from home}} - \\underbrace{y^*_{I\\rightarrow H,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new hospitalized}} \\end{align*} \\] \\[ \\begin{align*} H_{a,\\ell}(t + \\Delta t) = H_{a, \\ell}(t) &amp;+ \\underbrace{y^*_{I\\rightarrow H,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new hospitalized}} \\\\ &amp;- \\underbrace{y^*_{H\\rightarrow R,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new recovered from hospital}} - \\underbrace{y^*_{H\\rightarrow D,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new dead}} \\end{align*} \\] \\[ \\begin{align*} R_{a,\\ell}(t + \\Delta t) = R_{a, \\ell}(t) &amp;+ \\underbrace{y^*_{I\\rightarrow R,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new recovered from home}} + \\underbrace{y^*_{H\\rightarrow R,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new recovered from hospital}} \\\\ &amp;- \\underbrace{y_{R\\rightarrow S,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new susceptible}} \\end{align*} \\] \\[ D_{a,\\ell}(t + \\Delta t) = D_{a, \\ell}(t) + \\underbrace{y_{H\\rightarrow D,  a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)}_{\\text{new dead}} \\] <p>IMPORTANT: the \"\\(*\\)\" superscript indicates that the transition variable has a joint distribution with another transition variable. For example, consider the two transitions out of the infected compartment: new recovered from home and new hospitalized. Given that a patient is infected, exactly one outcome occurs: they recover (from home) or they go to the hospital. Since one and only one of these outcomes must occur, we must model these two transition variables jointly. If a compartment has more than one outgoing transition variable, we model these transition variables as a <code>TransitionVariableGroup</code> in the code. Details are provided in the next section on transition types.</p> <p>Each transition variable depends on a \"base count\" and a \"rate\" (which both depend on the current state of the system). This decomposition is displayed in the table below.</p> Name Transition variable Base count Rate New susceptible \\(y_{R \\rightarrow S, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(R_{a, \\ell}(t)\\) \\(\\eta\\) New exposed \\(y_{S \\rightarrow E, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(S_{a, \\ell}(t)\\) \\(\\sum_{a^\\prime \\in A, \\ell^\\prime \\in L} \\frac{\\beta(t) \\phi_{a, \\ell, a^\\prime, \\ell^\\prime}(t) I_{a^\\prime, \\ell^\\prime}(t)}{N_{a^\\prime, \\ell^\\prime} (1 + \\boldsymbol{\\Lambda^{I, I}(t)})}\\) New infected \\(y_{E \\rightarrow I, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(E_{a, \\ell}(t)\\) \\(\\sigma\\) New recovered  from home \\(y^*_{I \\rightarrow R, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(I_{a, \\ell}(t)\\) \\((1-\\tilde{\\mu}_{a,\\ell})\\gamma\\) New hospitalized \\(y^*_{I \\rightarrow H, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(I_{a, \\ell}(t)\\) \\(\\frac{\\zeta \\tilde{\\mu}_{a,\\ell} I_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}(t)}}\\) New recovered from hospital \\(y^*_{H \\rightarrow R, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(H_{a, \\ell}(t)\\) \\((1-\\tilde{\\nu}_{a,\\ell})\\gamma_H\\) New dead \\(y^*_{H \\rightarrow D, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) \\(H_{a, \\ell}(t)\\) \\(\\frac{\\pi \\tilde{\\nu}_{a,\\ell} H_{a,\\ell}(t)}{1 + \\boldsymbol{\\Lambda^{H, H}(t)}}\\) <p>Transition variable realizations depend on their transition types, which we outline in a table in the next section. </p>"},{"location":"math_flu_components/#flu-model-transition-types","title":"Flu model: transition types","text":"<p>Our codebase currently implements six types of transitions: three stochastic transitions and three deterministic counterparts.</p> <p>First we consider marginal (not joint) transition variables. Consider \\(y_{\\texttt{C}\\rightarrow\\texttt{C}^\\prime, a, \\ell}\\left(\\boldsymbol{\\mathcal X}(t), \\Delta t, \\omega\\right)\\) from compartment \\(\\texttt{C}\\) to \\(\\texttt{C}^\\prime\\). Let \\(\\texttt{b} = \\texttt{b}_{a, \\ell}(t)\\) be its current value of its base count and \\(\\texttt{r} = \\texttt{r}_{a, \\ell}(t)\\) be its current value of its rate. Then depending on its transition type, its distribution (or deterministic value) is given below.</p> <p>Note that \\(\\alpha(\\cdot, \\cdot)\\) is a function that converts a \"rate\" into a probability. It is given by: $$ \\alpha(\\texttt{r}, \\Delta t) = 1 - \\exp(-\\texttt{r} /\\Delta t) $$ and corresponds to the probability that a Poisson process with rate \\(\\texttt{r}\\) produces at least one event in an interval of length \\(\\Delta t\\). </p> Output Binomial \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\alpha(\\texttt{r}, \\Delta t)\\right)\\) Binomial  Taylor Approx \\(\\sim \\text{Binom}\\left(n = \\texttt{b}, p = \\texttt{r} / \\Delta t\\right)\\) Poisson \\(\\sim \\text{Poisson}\\left(\\lambda = \\texttt{b} \\cdot \\texttt{r} / \\Delta t\\right)\\) Binomial Deterministic \\(\\texttt{b} \\cdot \\alpha(\\texttt{r}, \\Delta t)\\) Binomial Taylor Approx Deterministic \\(\\texttt{b} \\cdot \\texttt{r} / \\Delta t\\) Poisson Deterministic \\(\\texttt{b} \\cdot \\texttt{r} / \\Delta t\\) <p>In the next table, we describe joint transition variables. </p> <p>...</p> <p>[IN PROGRESS, CHECK BACK SOON]</p>"},{"location":"math_flu_components/#general-model-discretized-stochastic-implementation","title":"General model: discretized stochastic implementation","text":"<p>We make the important note that the flu model's discretized stochastic implementation can be generalized to models with different structures. More broadly, we let \\(\\boldsymbol{\\mathcal C}(t)\\) be a model's set of epidemiological compartments, \\(\\boldsymbol{\\mathcal M}(t)\\) its set of aggregate epidemiological metrics, and \\(\\boldsymbol{S (t)}\\) its set of schedule-dependent (time-dependent) deterministic values. Then the above formulation still holds.</p> <p>In fact, in our code, we model \\(\\boldsymbol{\\mathcal C(t)}\\) using an <code>EpiCompartment</code> class, \\(\\boldsymbol{\\mathcal M}(t)\\) using an <code>EpiMetric</code> class, and \\(\\boldsymbol{\\mathcal S(t)}\\) using a <code>Schedule</code> class. These classes form some of the building blocks of the base model code.</p>"},{"location":"reference/","title":"Code Documentation","text":""},{"location":"reference/#CLT_BaseModel.base_components.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>Stores simulation configuration values.</p> <p>Attributes:</p> Name Type Description <code>timesteps_per_day</code> <code>int</code> <p>number of discretized timesteps within a simulation day -- more timesteps_per_day mean smaller discretization time intervals, which may cause the model to run slower.</p> <code>transition_type</code> <code>str</code> <p>valid value must be from TransitionTypes, specifying the probability distribution of transitions between compartments.</p> <code>start_real_date</code> <code>date</code> <p>actual date that aligns with the beginning of the simulation.</p> <code>save_daily_history</code> <code>bool</code> <p>True if each StateVariable saves state to history after each simulation day -- set to False if want speedier performance.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@dataclass\nclass Config:\n    \"\"\"\n    Stores simulation configuration values.\n\n    Attributes:\n        timesteps_per_day (int):\n            number of discretized timesteps within a simulation\n            day -- more timesteps_per_day mean smaller discretization\n            time intervals, which may cause the model to run slower.\n        transition_type (str):\n            valid value must be from TransitionTypes,\n            specifying the probability distribution of transitions between\n            compartments.\n        start_real_date (datetime.date):\n            actual date that aligns with the beginning of the simulation.\n        save_daily_history (bool):\n            True if each StateVariable saves state to history after each simulation\n            day -- set to False if want speedier performance.\n    \"\"\"\n\n    timesteps_per_day: int = 7\n    transition_type: str = TransitionTypes.BINOMIAL\n    start_real_date: datetime.time = datetime.datetime.strptime(\"2024-10-31\",\n                                                                \"%Y-%m-%d\").date()\n    save_daily_history: bool = True\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.DynamicVal","title":"<code>DynamicVal</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that dynamically adjust their values based the current values of other StateVariable instances.</p> <p>This class should model social distancing (and more broadly, staged-alert policies). For example, if we consider a case where transmission rates decrease when number infected increase above a certain level, we can create a subclass of DynamicVal that models a coefficient that modifies transmission rates, depending on the epi compartments corresponding to infected people.</p> <p>Inherits attributes from StateVariable.</p> <p>Attributes:</p> Name Type Description <code>history_vals_list</code> <code>list[ndarrays]</code> <p>each element is the same size of current_val, holds history of transition variable realizations for age-risk groups -- element t corresponds to previous current_val value at end of simulation day t.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>class DynamicVal(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that dynamically adjust\n    their values based the current values of other StateVariable instances.\n\n    This class should model social distancing (and more broadly,\n    staged-alert policies). For example, if we consider a\n    case where transmission rates decrease when number infected\n    increase above a certain level, we can create a subclass of\n    DynamicVal that models a coefficient that modifies transmission\n    rates, depending on the epi compartments corresponding to\n    infected people.\n\n    Inherits attributes from StateVariable.\n\n    Attributes:\n        history_vals_list (list[np.ndarrays]):\n            each element is the same size of current_val, holds\n            history of transition variable realizations for age-risk\n            groups -- element t corresponds to previous current_val value\n            at end of simulation day t.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 name: str,\n                 init_val: Optional[Union[np.ndarray, float]] = None):\n        \"\"\"\n\n        Args:\n            name (str):\n                unique identifier for dynamic val\n            init_val (Optional[Union[np.ndarray, float]]):\n                starting value(s) at the beginning of the simulation\n        \"\"\"\n\n        super().__init__(name, init_val)\n        self.history_vals_list = []\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending current_val attribute\n            to history_vals_list in place\n\n        NOTE:\n            deep copying is CRUCIAL because current_val is a mutable\n            np.ndarray -- without deep copying, history_vals_list would\n            have the same value for all elements\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def clear_history(self) -&gt; None:\n        self.history_vals_list = []\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.DynamicVal.__init__","title":"<code>__init__(name, init_val=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>unique identifier for dynamic val</p> required <code>init_val</code> <code>Optional[Union[ndarray, float]]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def __init__(self,\n             name: str,\n             init_val: Optional[Union[np.ndarray, float]] = None):\n    \"\"\"\n\n    Args:\n        name (str):\n            unique identifier for dynamic val\n        init_val (Optional[Union[np.ndarray, float]]):\n            starting value(s) at the beginning of the simulation\n    \"\"\"\n\n    super().__init__(name, init_val)\n    self.history_vals_list = []\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.DynamicVal.save_history","title":"<code>save_history()</code>","text":"<p>Saves current value to history by appending current_val attribute     to history_vals_list in place</p> NOTE <p>deep copying is CRUCIAL because current_val is a mutable np.ndarray -- without deep copying, history_vals_list would have the same value for all elements</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending current_val attribute\n        to history_vals_list in place\n\n    NOTE:\n        deep copying is CRUCIAL because current_val is a mutable\n        np.ndarray -- without deep copying, history_vals_list would\n        have the same value for all elements\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.EpiCompartment","title":"<code>EpiCompartment</code>","text":"<p>               Bases: <code>StateVariable</code></p> <p>Class for epidemiological compartments (e.g. Susceptible,     Exposed, Infected, etc...).</p> <p>Inherits attributes from StateVariable.</p> <p>Attributes:</p> Name Type Description <code>current_val</code> <code>ndarray</code> <p>same size as init_val, holds current value of EpiCompartment for age-risk groups.</p> <code>current_inflow</code> <code>ndarray</code> <p>same size as current_val, used to sum up all transition variable realizations incoming to this compartment for age-risk groups.</p> <code>current_outflow</code> <code>ndarray</code> <p>same size of current_val, used to sum up all transition variable realizations outgoing from this compartment for age-risk groups.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of current_val, holds history of compartment states for age-risk groups -- element t corresponds to previous current_val value at end of simulation day t.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>class EpiCompartment(StateVariable):\n    \"\"\"\n    Class for epidemiological compartments (e.g. Susceptible,\n        Exposed, Infected, etc...).\n\n    Inherits attributes from StateVariable.\n\n    Attributes:\n        current_val (np.ndarray):\n            same size as init_val, holds current value of EpiCompartment\n            for age-risk groups.\n        current_inflow (np.ndarray):\n            same size as current_val, used to sum up all\n            transition variable realizations incoming to this compartment\n            for age-risk groups.\n        current_outflow (np.ndarray):\n            same size of current_val, used to sum up all\n            transition variable realizations outgoing from this compartment\n            for age-risk groups.\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of current_val, holds\n            history of compartment states for age-risk groups --\n            element t corresponds to previous current_val value at\n            end of simulation day t.\n    \"\"\"\n\n    def __init__(self,\n                 name,\n                 init_val):\n        super().__init__(name, init_val)\n\n        self.current_inflow = np.zeros(np.shape(init_val))\n        self.current_outflow = np.zeros(np.shape(init_val))\n\n        self.history_vals_list = []\n\n    def update_current_val(self) -&gt; None:\n        self.current_val += self.current_inflow - self.current_outflow\n\n    def reset_inflow(self) -&gt; None:\n        self.current_inflow = np.zeros(np.shape(self.current_inflow))\n\n    def reset_outflow(self) -&gt; None:\n        self.current_outflow = np.zeros(np.shape(self.current_outflow))\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending current_val attribute\n            to history_vals_list in place\n\n        NOTE:\n            deep copying is CRUCIAL because current_val is a mutable\n            np.ndarray -- without deep copying, history_vals_list would\n            have the same value for all elements\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def clear_history(self) -&gt; None:\n        self.history_vals_list = []\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.EpiCompartment.save_history","title":"<code>save_history()</code>","text":"<p>Saves current value to history by appending current_val attribute     to history_vals_list in place</p> NOTE <p>deep copying is CRUCIAL because current_val is a mutable np.ndarray -- without deep copying, history_vals_list would have the same value for all elements</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending current_val attribute\n        to history_vals_list in place\n\n    NOTE:\n        deep copying is CRUCIAL because current_val is a mutable\n        np.ndarray -- without deep copying, history_vals_list would\n        have the same value for all elements\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.EpiMetric","title":"<code>EpiMetric</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for epi metrics in epidemiological model.</p> <p>This is intended for variables that are aggregate deterministic functions of the simulation state (including epi compartment values, other parameters, and time.)</p> <p>For example, population-level immunity variables should be modeled as a EpiMetric subclass, with a concrete implementation of the abstract method get_change_in_current_val.</p> <p>Inherits attributes from StateVariable.</p> <p>Attributes:</p> Name Type Description <code>current_val</code> <code>ndarray</code> <p>same size as init_val, holds current value of State Variable for age-risk groups.</p> <code>change_in_current_val</code> <p>(np.ndarray): initialized to None, but during simulation holds change in current value of EpiMetric for age-risk groups (size A x L, where A is number of risk groups and L is number of age groups).</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of current_val, holds history of transition variable realizations for age-risk groups -- element t corresponds to previous current_val value at end of simulation day t.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>class EpiMetric(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for epi metrics in epidemiological model.\n\n    This is intended for variables that are aggregate deterministic functions of\n    the simulation state (including epi compartment values, other parameters,\n    and time.)\n\n    For example, population-level immunity variables should be\n    modeled as a EpiMetric subclass, with a concrete\n    implementation of the abstract method get_change_in_current_val.\n\n    Inherits attributes from StateVariable.\n\n    Attributes:\n        current_val (np.ndarray):\n            same size as init_val, holds current value of State Variable\n            for age-risk groups.\n        change_in_current_val : (np.ndarray):\n            initialized to None, but during simulation holds change in\n            current value of EpiMetric for age-risk groups\n            (size A x L, where A is number of risk groups and L is number\n            of age groups).\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of current_val, holds\n            history of transition variable realizations for age-risk\n            groups -- element t corresponds to previous current_val value\n            at end of simulation day t.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 name,\n                 init_val):\n        \"\"\"\n        Args:\n            name (str):\n                name of EpiMetric.\n            init_val (np.ndarray):\n                2D array that contains nonnegative floats,\n                corresponding to initial value of dynamic val,\n                where i,jth entry corresponds to age group i and\n                risk group j.\n        \"\"\"\n\n        super().__init__(name, init_val)\n\n        self.change_in_current_val = None\n        self.history_vals_list = []\n\n    @abstractmethod\n    def get_change_in_current_val(self,\n                                  sim_state: SimState,\n                                  fixed_params: FixedParams,\n                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns change in current value of dynamic val,\n        based on current state of the simulation and epidemiological parameters.\n        ***NOTE: OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n        Output should be a numpy array of size A x L, where A is\n        sim_state.num_age_groups and L is sim_state.num_risk_groups.\n\n        Args:\n            sim_state (SimState):\n                holds simulation state (current values of StateVariable\n                instances).\n            fixed_params (FixedParams):\n                holds values of epidemiological parameters.\n            num_timesteps (int):\n                number of timesteps -- used to determine time interval\n                length for discretization.\n\n        Returns:\n            np.ndarray:\n                size A x L, where A is sim_state.num_age_groups and L is\n                sim_state.num_risk_groups.\n        \"\"\"\n        pass\n\n    def update_current_val(self) -&gt; None:\n        self.current_val += self.change_in_current_val\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending current_val attribute\n            to history_vals_list in place\n\n        NOTE:\n            deep copying is CRUCIAL because current_val is a mutable\n            np.ndarray -- without deep copying, history_vals_list would\n            have the same value for all elements\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def clear_history(self) -&gt; None:\n        self.history_vals_list = []\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.EpiMetric.__init__","title":"<code>__init__(name, init_val)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of EpiMetric.</p> required <code>init_val</code> <code>ndarray</code> <p>2D array that contains nonnegative floats, corresponding to initial value of dynamic val, where i,jth entry corresponds to age group i and risk group j.</p> required Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def __init__(self,\n             name,\n             init_val):\n    \"\"\"\n    Args:\n        name (str):\n            name of EpiMetric.\n        init_val (np.ndarray):\n            2D array that contains nonnegative floats,\n            corresponding to initial value of dynamic val,\n            where i,jth entry corresponds to age group i and\n            risk group j.\n    \"\"\"\n\n    super().__init__(name, init_val)\n\n    self.change_in_current_val = None\n    self.history_vals_list = []\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.EpiMetric.get_change_in_current_val","title":"<code>get_change_in_current_val(sim_state, fixed_params, num_timesteps)</code>  <code>abstractmethod</code>","text":"<p>Computes and returns change in current value of dynamic val, based on current state of the simulation and epidemiological parameters. ***NOTE: OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS. Output should be a numpy array of size A x L, where A is sim_state.num_age_groups and L is sim_state.num_risk_groups.</p> <p>Parameters:</p> Name Type Description Default <code>sim_state</code> <code>SimState</code> <p>holds simulation state (current values of StateVariable instances).</p> required <code>fixed_params</code> <code>FixedParams</code> <p>holds values of epidemiological parameters.</p> required <code>num_timesteps</code> <code>int</code> <p>number of timesteps -- used to determine time interval length for discretization.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size A x L, where A is sim_state.num_age_groups and L is sim_state.num_risk_groups.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@abstractmethod\ndef get_change_in_current_val(self,\n                              sim_state: SimState,\n                              fixed_params: FixedParams,\n                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns change in current value of dynamic val,\n    based on current state of the simulation and epidemiological parameters.\n    ***NOTE: OUTPUT SHOULD ALREADY BE SCALED BY NUM_TIMESTEPS.\n    Output should be a numpy array of size A x L, where A is\n    sim_state.num_age_groups and L is sim_state.num_risk_groups.\n\n    Args:\n        sim_state (SimState):\n            holds simulation state (current values of StateVariable\n            instances).\n        fixed_params (FixedParams):\n            holds values of epidemiological parameters.\n        num_timesteps (int):\n            number of timesteps -- used to determine time interval\n            length for discretization.\n\n    Returns:\n        np.ndarray:\n            size A x L, where A is sim_state.num_age_groups and L is\n            sim_state.num_risk_groups.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.EpiMetric.save_history","title":"<code>save_history()</code>","text":"<p>Saves current value to history by appending current_val attribute     to history_vals_list in place</p> NOTE <p>deep copying is CRUCIAL because current_val is a mutable np.ndarray -- without deep copying, history_vals_list would have the same value for all elements</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending current_val attribute\n        to history_vals_list in place\n\n    NOTE:\n        deep copying is CRUCIAL because current_val is a mutable\n        np.ndarray -- without deep copying, history_vals_list would\n        have the same value for all elements\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.FixedParams","title":"<code>FixedParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Stores epidemiological parameters.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@dataclass\nclass FixedParams(ABC):\n    \"\"\"\n    Stores epidemiological parameters.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor","title":"<code>ModelConstructor</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for model constructors that create model with predetermined fixed structure -- initial values and epidemiological structure are populated by user-specified JSON files.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>Config</code> <p>holds configuration values.</p> <code>fixed_params</code> <code>FixedParams</code> <p>holds epidemiological parameter values), read from user-specified JSON.</p> <code>sim_state</code> <code>SimState</code> <p>holds current values of StateVariable instances): read from user-specified JSON.</p> <code>compartment_lookup</code> <code>dict</code> <p>maps \"name\" attribute to EpiCompartment.</p> <code>epi_metric_lookup</code> <code>dict</code> <p>maps \"name\" attribute to EpiMetric.</p> <code>dynamic_val_lookup</code> <code>dict</code> <p>maps \"name\" attribute to DynamicVal.</p> <code>schedule_lookup</code> <code>dict</code> <p>maps \"name\" attribute to Schedule.</p> <code>transition_variable_lookup</code> <code>dict</code> <p>maps \"name\" attribute to TransitionVariable.</p> <code>transition_variable_group_lookup</code> <code>dict</code> <p>maps \"name\" attribute to TransitionVariableGroup.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>class ModelConstructor(ABC):\n    \"\"\"\n    Abstract base class for model constructors that create\n    model with predetermined fixed structure --\n    initial values and epidemiological structure are\n    populated by user-specified JSON files.\n\n    Attributes:\n        config (Config):\n            holds configuration values.\n        fixed_params (FixedParams):\n            holds epidemiological parameter values), read\n            from user-specified JSON.\n        sim_state (SimState):\n            holds current values of StateVariable instances):\n            read from user-specified JSON.\n        compartment_lookup (dict):\n            maps \"name\" attribute to EpiCompartment.\n        epi_metric_lookup (dict):\n            maps \"name\" attribute to EpiMetric.\n        dynamic_val_lookup (dict):\n            maps \"name\" attribute to DynamicVal.\n        schedule_lookup (dict):\n            maps \"name\" attribute to Schedule.\n        transition_variable_lookup (dict):\n            maps \"name\" attribute to TransitionVariable.\n        transition_variable_group_lookup (dict):\n            maps \"name\" attribute to TransitionVariableGroup.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Note: concrete subclasses should specifically assign\n        config, fixed_params, and sim_state attributes to problem-specific\n        dataclasses.\n        \"\"\"\n\n        self.config = None\n        self.fixed_params = None\n        self.sim_state = None\n\n        self.compartment_lookup = {}\n        self.epi_metric_lookup = {}\n        self.dynamic_val_lookup = {}\n        self.schedule_lookup = {}\n\n        self.transition_variable_lookup = {}\n        self.transition_variable_group_lookup = {}\n\n    @staticmethod\n    def dataclass_instance_from_json(dataclass_ref: Type[Union[Config, SimState, FixedParams]],\n                                     json_filepath: str) -&gt; Union[Config, SimState, FixedParams]:\n        \"\"\"\n        Create instance of class dataclass_ref,\n        based on information in json_filepath.\n\n        Args:\n            dataclass_ref (Type[Union[Config, SimState, FixedParams]]):\n                (class, not instance) from which to create instance.\n            json_filepath (str):\n                path to json file (path includes actual filename\n                with suffix \".json\") -- all json fields must\n                match name and datatype of dataclass_ref instance\n                attributes.\n\n        Returns:\n            Union[Config, SimState, FixedParams]:\n                instance of dataclass_ref with attributes dynamically\n                assigned by json_filepath file contents.\n        \"\"\"\n\n        with open(json_filepath, 'r') as file:\n            data = json.load(file)\n\n        # convert lists to numpy arrays to support numpy operations\n        #   since json does not have direct support for numpy\n        for key, val in data.items():\n            if type(val) is list:\n                data[key] = np.asarray(val)\n\n        return dataclass_ref(**data)\n\n    @abstractmethod\n    def setup_epi_compartments(self) -&gt; None:\n        \"\"\"\n        Create compartments and add them to compartment_lookup\n        attribute for dictionary access.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def setup_epi_metrics(self) -&gt; None:\n        \"\"\"\n        Create epi metrics and add them to epi_metric_lookup\n        attribute for dictionary access.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def setup_dynamic_vals(self) -&gt; None:\n        \"\"\"\n        Create dynamic vals and add them to dynamic_val_lookup\n        attribute for dictionary access.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def setup_schedules(self) -&gt; None:\n        \"\"\"\n        Create all schedules and add them to\n        schedule_lookup attribute for dictionary access.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def setup_transition_variables(self) -&gt; None:\n        \"\"\"\n        Create transition variables and add them to transition_variable_lookup\n        attribute for dictionary access.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def setup_transition_variable_groups(self) -&gt; None:\n        \"\"\"\n        Create transition variable groups and add them to\n        transition_variable_group_lookup attribute for dictionary access.\n        \"\"\"\n        pass\n\n    def create_state_variable_manager(self,\n                                      compartments_list: list[EpiCompartment],\n                                      epi_metrics_list: list[EpiMetric],\n                                      dynamic_vals_list: list[DynamicVal],\n                                      schedules_list: list[Schedule]) -&gt; StateVariableManager:\n        \"\"\"\n        Create instance of StateVariableManager that holds\n        the model's StateVariable instances -- populates its sim_state\n        attribute with initial values of the StateVariable instances.\n\n        Args:\n            compartments_list (list):\n                list of all the model's EpiCompartment instances.\n            epi_metrics_list (list):\n                list of all the model's EpiMetric instances.\n            dynamic_vals_list (list):\n                list of all the model's DynamicVal instances.\n            schedules_list (list):\n                list of all the model's Schedule instances.\n\n        Returns:\n            StateVariableManager:\n                container that holds compartments, dynamic values, and\n                schedules for the model.\n        \"\"\"\n        state_variable_manager = StateVariableManager(compartments=compartments_list,\n                                                      epi_metrics=epi_metrics_list,\n                                                      dynamic_vals=dynamic_vals_list,\n                                                      schedules=schedules_list,\n                                                      sim_state=self.sim_state)\n\n        state_variable_manager.update_sim_state(compartments_list + epi_metrics_list +\n                                                dynamic_vals_list + schedules_list)\n\n        return state_variable_manager\n\n    def create_transmission_model(self, RNG_seed) -&gt; TransmissionModel:\n        \"\"\"\n        Args:\n            RNG_seed (int):\n                used to initialize the model's RNG for generating\n                random variables and random transitions.\n\n        Returns:\n            TransmissionModel:\n                initial values and epidemiological parameters\n                are loaded from user-specified JSON files during\n                ModelConstructor initialization.\n        \"\"\"\n\n        # Setup objects for model\n        self.setup_epi_compartments()\n        self.setup_transition_variables()\n        self.setup_transition_variable_groups()\n\n        # Some epi metrics depend on transition variables, so\n        #   set up epi metrics after transition variables\n        self.setup_epi_metrics()\n        self.setup_dynamic_vals()\n        self.setup_schedules()\n\n        # Get dictionary values as lists\n        compartments_list = list(self.compartment_lookup.values())\n        epi_metrics_list = list(self.epi_metric_lookup.values())\n        dynamic_vals_list = list(self.dynamic_val_lookup.values())\n        schedules_list = list(self.schedule_lookup.values())\n\n        flu_transition_variables_list = list(self.transition_variable_lookup.values())\n        flu_transition_variable_groups_list = list(self.transition_variable_group_lookup.values())\n\n        state_variable_manager = self.create_state_variable_manager(compartments_list,\n                                                                    epi_metrics_list,\n                                                                    dynamic_vals_list,\n                                                                    schedules_list)\n\n        return TransmissionModel(state_variable_manager,\n                                 flu_transition_variables_list,\n                                 flu_transition_variable_groups_list,\n                                 self.fixed_params,\n                                 self.config,\n                                 RNG_seed)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.__init__","title":"<code>__init__()</code>","text":"<p>Note: concrete subclasses should specifically assign config, fixed_params, and sim_state attributes to problem-specific dataclasses.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    Note: concrete subclasses should specifically assign\n    config, fixed_params, and sim_state attributes to problem-specific\n    dataclasses.\n    \"\"\"\n\n    self.config = None\n    self.fixed_params = None\n    self.sim_state = None\n\n    self.compartment_lookup = {}\n    self.epi_metric_lookup = {}\n    self.dynamic_val_lookup = {}\n    self.schedule_lookup = {}\n\n    self.transition_variable_lookup = {}\n    self.transition_variable_group_lookup = {}\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.create_state_variable_manager","title":"<code>create_state_variable_manager(compartments_list, epi_metrics_list, dynamic_vals_list, schedules_list)</code>","text":"<p>Create instance of StateVariableManager that holds the model's StateVariable instances -- populates its sim_state attribute with initial values of the StateVariable instances.</p> <p>Parameters:</p> Name Type Description Default <code>compartments_list</code> <code>list</code> <p>list of all the model's EpiCompartment instances.</p> required <code>epi_metrics_list</code> <code>list</code> <p>list of all the model's EpiMetric instances.</p> required <code>dynamic_vals_list</code> <code>list</code> <p>list of all the model's DynamicVal instances.</p> required <code>schedules_list</code> <code>list</code> <p>list of all the model's Schedule instances.</p> required <p>Returns:</p> Name Type Description <code>StateVariableManager</code> <code>StateVariableManager</code> <p>container that holds compartments, dynamic values, and schedules for the model.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def create_state_variable_manager(self,\n                                  compartments_list: list[EpiCompartment],\n                                  epi_metrics_list: list[EpiMetric],\n                                  dynamic_vals_list: list[DynamicVal],\n                                  schedules_list: list[Schedule]) -&gt; StateVariableManager:\n    \"\"\"\n    Create instance of StateVariableManager that holds\n    the model's StateVariable instances -- populates its sim_state\n    attribute with initial values of the StateVariable instances.\n\n    Args:\n        compartments_list (list):\n            list of all the model's EpiCompartment instances.\n        epi_metrics_list (list):\n            list of all the model's EpiMetric instances.\n        dynamic_vals_list (list):\n            list of all the model's DynamicVal instances.\n        schedules_list (list):\n            list of all the model's Schedule instances.\n\n    Returns:\n        StateVariableManager:\n            container that holds compartments, dynamic values, and\n            schedules for the model.\n    \"\"\"\n    state_variable_manager = StateVariableManager(compartments=compartments_list,\n                                                  epi_metrics=epi_metrics_list,\n                                                  dynamic_vals=dynamic_vals_list,\n                                                  schedules=schedules_list,\n                                                  sim_state=self.sim_state)\n\n    state_variable_manager.update_sim_state(compartments_list + epi_metrics_list +\n                                            dynamic_vals_list + schedules_list)\n\n    return state_variable_manager\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.create_transmission_model","title":"<code>create_transmission_model(RNG_seed)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>RNG_seed</code> <code>int</code> <p>used to initialize the model's RNG for generating random variables and random transitions.</p> required <p>Returns:</p> Name Type Description <code>TransmissionModel</code> <code>TransmissionModel</code> <p>initial values and epidemiological parameters are loaded from user-specified JSON files during ModelConstructor initialization.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def create_transmission_model(self, RNG_seed) -&gt; TransmissionModel:\n    \"\"\"\n    Args:\n        RNG_seed (int):\n            used to initialize the model's RNG for generating\n            random variables and random transitions.\n\n    Returns:\n        TransmissionModel:\n            initial values and epidemiological parameters\n            are loaded from user-specified JSON files during\n            ModelConstructor initialization.\n    \"\"\"\n\n    # Setup objects for model\n    self.setup_epi_compartments()\n    self.setup_transition_variables()\n    self.setup_transition_variable_groups()\n\n    # Some epi metrics depend on transition variables, so\n    #   set up epi metrics after transition variables\n    self.setup_epi_metrics()\n    self.setup_dynamic_vals()\n    self.setup_schedules()\n\n    # Get dictionary values as lists\n    compartments_list = list(self.compartment_lookup.values())\n    epi_metrics_list = list(self.epi_metric_lookup.values())\n    dynamic_vals_list = list(self.dynamic_val_lookup.values())\n    schedules_list = list(self.schedule_lookup.values())\n\n    flu_transition_variables_list = list(self.transition_variable_lookup.values())\n    flu_transition_variable_groups_list = list(self.transition_variable_group_lookup.values())\n\n    state_variable_manager = self.create_state_variable_manager(compartments_list,\n                                                                epi_metrics_list,\n                                                                dynamic_vals_list,\n                                                                schedules_list)\n\n    return TransmissionModel(state_variable_manager,\n                             flu_transition_variables_list,\n                             flu_transition_variable_groups_list,\n                             self.fixed_params,\n                             self.config,\n                             RNG_seed)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.dataclass_instance_from_json","title":"<code>dataclass_instance_from_json(dataclass_ref, json_filepath)</code>  <code>staticmethod</code>","text":"<p>Create instance of class dataclass_ref, based on information in json_filepath.</p> <p>Parameters:</p> Name Type Description Default <code>dataclass_ref</code> <code>Type[Union[Config, SimState, FixedParams]]</code> <p>(class, not instance) from which to create instance.</p> required <code>json_filepath</code> <code>str</code> <p>path to json file (path includes actual filename with suffix \".json\") -- all json fields must match name and datatype of dataclass_ref instance attributes.</p> required <p>Returns:</p> Type Description <code>Union[Config, SimState, FixedParams]</code> <p>Union[Config, SimState, FixedParams]: instance of dataclass_ref with attributes dynamically assigned by json_filepath file contents.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@staticmethod\ndef dataclass_instance_from_json(dataclass_ref: Type[Union[Config, SimState, FixedParams]],\n                                 json_filepath: str) -&gt; Union[Config, SimState, FixedParams]:\n    \"\"\"\n    Create instance of class dataclass_ref,\n    based on information in json_filepath.\n\n    Args:\n        dataclass_ref (Type[Union[Config, SimState, FixedParams]]):\n            (class, not instance) from which to create instance.\n        json_filepath (str):\n            path to json file (path includes actual filename\n            with suffix \".json\") -- all json fields must\n            match name and datatype of dataclass_ref instance\n            attributes.\n\n    Returns:\n        Union[Config, SimState, FixedParams]:\n            instance of dataclass_ref with attributes dynamically\n            assigned by json_filepath file contents.\n    \"\"\"\n\n    with open(json_filepath, 'r') as file:\n        data = json.load(file)\n\n    # convert lists to numpy arrays to support numpy operations\n    #   since json does not have direct support for numpy\n    for key, val in data.items():\n        if type(val) is list:\n            data[key] = np.asarray(val)\n\n    return dataclass_ref(**data)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.setup_dynamic_vals","title":"<code>setup_dynamic_vals()</code>  <code>abstractmethod</code>","text":"<p>Create dynamic vals and add them to dynamic_val_lookup attribute for dictionary access.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@abstractmethod\ndef setup_dynamic_vals(self) -&gt; None:\n    \"\"\"\n    Create dynamic vals and add them to dynamic_val_lookup\n    attribute for dictionary access.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.setup_epi_compartments","title":"<code>setup_epi_compartments()</code>  <code>abstractmethod</code>","text":"<p>Create compartments and add them to compartment_lookup attribute for dictionary access.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@abstractmethod\ndef setup_epi_compartments(self) -&gt; None:\n    \"\"\"\n    Create compartments and add them to compartment_lookup\n    attribute for dictionary access.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.setup_epi_metrics","title":"<code>setup_epi_metrics()</code>  <code>abstractmethod</code>","text":"<p>Create epi metrics and add them to epi_metric_lookup attribute for dictionary access.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@abstractmethod\ndef setup_epi_metrics(self) -&gt; None:\n    \"\"\"\n    Create epi metrics and add them to epi_metric_lookup\n    attribute for dictionary access.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.setup_schedules","title":"<code>setup_schedules()</code>  <code>abstractmethod</code>","text":"<p>Create all schedules and add them to schedule_lookup attribute for dictionary access.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@abstractmethod\ndef setup_schedules(self) -&gt; None:\n    \"\"\"\n    Create all schedules and add them to\n    schedule_lookup attribute for dictionary access.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.setup_transition_variable_groups","title":"<code>setup_transition_variable_groups()</code>  <code>abstractmethod</code>","text":"<p>Create transition variable groups and add them to transition_variable_group_lookup attribute for dictionary access.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@abstractmethod\ndef setup_transition_variable_groups(self) -&gt; None:\n    \"\"\"\n    Create transition variable groups and add them to\n    transition_variable_group_lookup attribute for dictionary access.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.ModelConstructor.setup_transition_variables","title":"<code>setup_transition_variables()</code>  <code>abstractmethod</code>","text":"<p>Create transition variables and add them to transition_variable_lookup attribute for dictionary access.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@abstractmethod\ndef setup_transition_variables(self) -&gt; None:\n    \"\"\"\n    Create transition variables and add them to transition_variable_lookup\n    attribute for dictionary access.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.Schedule","title":"<code>Schedule</code>  <code>dataclass</code>","text":"<p>               Bases: <code>StateVariable</code>, <code>ABC</code></p> <p>Abstract base class for variables that are functions of real-world dates -- for example, contact matrices (which depend on the day of the week and whether the current day is a holiday), historical vaccination data, and seasonality.</p> <p>Inherits attributes from StateVariable.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@dataclass\nclass Schedule(StateVariable, ABC):\n    \"\"\"\n    Abstract base class for variables that are functions of real-world\n    dates -- for example, contact matrices (which depend on the day of\n    the week and whether the current day is a holiday), historical\n    vaccination data, and seasonality.\n\n    Inherits attributes from StateVariable.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 name: str,\n                 init_val: Optional[Union[np.ndarray, float]] = None,\n                 timeseries_df: Optional[dict] = None):\n        \"\"\"\n        Args:\n            name (str):\n                unique identifier for schedule\n            init_val (Optional[Union[np.ndarray, float]]):\n                starting value(s) at the beginning of the simulation\n            timeseries_df (Optional[pd.DataFrame] = None):\n                has a \"date\" column with strings in format \"YYYY-MM-DD\"\n                of consecutive calendar days, and other columns\n                corresponding to values on those days\n        \"\"\"\n\n        super().__init__(name, init_val)\n        self.timeseries_df = timeseries_df\n\n    @abstractmethod\n    def update_current_val(self, current_date: datetime.date) -&gt; None:\n        \"\"\"\n        Subclasses must provide a concrete implementation of\n        updating self.current_val in-place.\n\n        Args:\n            current_date (date):\n                real-world date corresponding to\n                model's current simulation day.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.Schedule.__init__","title":"<code>__init__(name, init_val=None, timeseries_df=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>unique identifier for schedule</p> required <code>init_val</code> <code>Optional[Union[ndarray, float]]</code> <p>starting value(s) at the beginning of the simulation</p> <code>None</code> <code>timeseries_df</code> <code>Optional[pd.DataFrame] = None</code> <p>has a \"date\" column with strings in format \"YYYY-MM-DD\" of consecutive calendar days, and other columns corresponding to values on those days</p> <code>None</code> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def __init__(self,\n             name: str,\n             init_val: Optional[Union[np.ndarray, float]] = None,\n             timeseries_df: Optional[dict] = None):\n    \"\"\"\n    Args:\n        name (str):\n            unique identifier for schedule\n        init_val (Optional[Union[np.ndarray, float]]):\n            starting value(s) at the beginning of the simulation\n        timeseries_df (Optional[pd.DataFrame] = None):\n            has a \"date\" column with strings in format \"YYYY-MM-DD\"\n            of consecutive calendar days, and other columns\n            corresponding to values on those days\n    \"\"\"\n\n    super().__init__(name, init_val)\n    self.timeseries_df = timeseries_df\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.Schedule.update_current_val","title":"<code>update_current_val(current_date)</code>  <code>abstractmethod</code>","text":"<p>Subclasses must provide a concrete implementation of updating self.current_val in-place.</p> <p>Parameters:</p> Name Type Description Default <code>current_date</code> <code>date</code> <p>real-world date corresponding to model's current simulation day.</p> required Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@abstractmethod\ndef update_current_val(self, current_date: datetime.date) -&gt; None:\n    \"\"\"\n    Subclasses must provide a concrete implementation of\n    updating self.current_val in-place.\n\n    Args:\n        current_date (date):\n            real-world date corresponding to\n            model's current simulation day.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.SimState","title":"<code>SimState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Holds current values of simulation state.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@dataclass\nclass SimState(ABC):\n    \"\"\"\n    Holds current values of simulation state.\n    \"\"\"\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.StateVariable","title":"<code>StateVariable</code>","text":"<p>Parent class of EpiCompartment, EpiMetric, DynamicVal, and Schedule classes. All subclasses have the common attributes \"name\", \"init_val\", and \"current_val.\"</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>class StateVariable:\n    \"\"\"\n    Parent class of EpiCompartment, EpiMetric, DynamicVal, and Schedule\n    classes. All subclasses have the common attributes \"name\", \"init_val\",\n    and \"current_val.\"\n    \"\"\"\n\n    def __init__(self, name, init_val):\n        self.name = name\n        self.init_val = init_val\n        self.current_val = copy.deepcopy(init_val)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.StateVariableManager","title":"<code>StateVariableManager</code>  <code>dataclass</code>","text":"<p>Container for holding StateVariable instances -- this includes EpiCompartment, EpiMetric, DynamicVal, and Schedule instances. Note that TransitionVariable and TransitionVariableGroup instances are NOT included here.</p> <p>Attributes:</p> Name Type Description <code>compartments</code> <code>list</code> <p>list of all the model's EpiCompartment instances.</p> <code>epi_metrics</code> <code>list</code> <p>list of all the model's EpiMetric instances.</p> <code>dynamic_vals</code> <code>list</code> <p>list of all the model's DynamicVal instances.</p> <code>schedules</code> <code>list</code> <p>list of all the model's Schedule instances.</p> <code>sim_state</code> <code>SimState</code> <p>data container for the model's current values of its StateVariable instances -- the name of each field nust match the \"name\" attribute of a corresponding StateVariable.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@dataclass\nclass StateVariableManager:\n    \"\"\"\n    Container for holding StateVariable instances --\n    this includes EpiCompartment, EpiMetric, DynamicVal, and\n    Schedule instances. Note that TransitionVariable\n    and TransitionVariableGroup instances are NOT included here.\n\n    Attributes:\n        compartments (list):\n            list of all the model's EpiCompartment instances.\n        epi_metrics (list):\n            list of all the model's EpiMetric instances.\n        dynamic_vals (list):\n            list of all the model's DynamicVal instances.\n        schedules (list):\n            list of all the model's Schedule instances.\n        sim_state (SimState):\n            data container for the model's current values of its\n            StateVariable instances -- the name of each field\n            nust match the \"name\" attribute of a corresponding\n            StateVariable.\n    \"\"\"\n\n    compartments: Optional[list] = None\n    epi_metrics: Optional[list] = None\n    dynamic_vals: Optional[list] = None\n    schedules: Optional[list] = None\n    sim_state: Optional[SimState] = None\n\n    def update_sim_state(self, unit_list: list[StateVariable]) -&gt; None:\n        for unit in unit_list:\n            setattr(self.sim_state, unit.name, unit.current_val)\n\n    def reset_sim_state(self):\n        # AGAIN, MUST BE CAREFUL ABOUT MUTABLE NUMPY ARRAYS --\n        # MUST USE DEEP COPY\n        for svar in self.compartments + self.epi_metrics + self.dynamic_vals + self.schedules:\n            setattr(svar, svar.name, copy.deepcopy(svar.init_val))\n\n    def clear_history(self):\n        # Schedules do not have history since they are deterministic\n        for svar in self.compartments + self.epi_metrics + self.dynamic_vals:\n            svar.clear_history()\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariable","title":"<code>TransitionVariable</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for transition variables in epidemiological model.</p> <p>For example, in an S-I-R model, the new number infected every iteration (the number going from S to I) in an iteration is modeled as a TransitionVariable subclass, with a concrete implementation of the abstract method get_current_rate.</p> <p>When an instance is initialized, its get_realization attribute is dynamically assigned, just like in the case of TransitionVariableGroup instantiation.</p> <p>Attributes:</p> Name Type Description <code>_transition_type</code> <code>str</code> <p>only values defined in TransitionTypes Enum are valid, specifying probability distribution of transitions between compartments.</p> <code>get_current_rate</code> <code>function</code> <p>provides specific implementation for computing current rate as a function of current simulation state and epidemiological parameters.</p> <code>current_rate</code> <code>ndarray</code> <p>holds output from get_current_rate method -- used to generate random variable realizations for transitions between compartments.</p> <code>current_val</code> <code>ndarray</code> <p>holds realization of random variable parameterized by current_rate.</p> <code>history_vals_list</code> <code>list[ndarray]</code> <p>each element is the same size of current_val, holds history of transition variable realizations for age-risk groups -- element t corresponds to previous current_val value at end of simulation day t.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>class TransitionVariable(ABC):\n    \"\"\"\n    Abstract base class for transition variables in\n    epidemiological model.\n\n    For example, in an S-I-R model, the new number infected\n    every iteration (the number going from S to I) in an iteration\n    is modeled as a TransitionVariable subclass, with a concrete\n    implementation of the abstract method get_current_rate.\n\n    When an instance is initialized, its get_realization attribute\n    is dynamically assigned, just like in the case of\n    TransitionVariableGroup instantiation.\n\n    Attributes:\n        _transition_type (str):\n            only values defined in TransitionTypes Enum are valid, specifying\n            probability distribution of transitions between compartments.\n        get_current_rate (function):\n            provides specific implementation for computing current rate\n            as a function of current simulation state and epidemiological parameters.\n        current_rate (np.ndarray):\n            holds output from get_current_rate method -- used to generate\n            random variable realizations for transitions between compartments.\n        current_val (np.ndarray):\n            holds realization of random variable parameterized by current_rate.\n        history_vals_list (list[np.ndarray]):\n            each element is the same size of current_val, holds\n            history of transition variable realizations for age-risk\n            groups -- element t corresponds to previous current_val value\n            at end of simulation day t.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 name,\n                 origin,\n                 destination,\n                 transition_type,\n                 is_jointly_distributed=False):\n        \"\"\"\n        Parameters:\n            name (str):\n                user-specified name for compartment.\n            origin (EpiCompartment):\n                the compartment from which Transition Variable exits.\n            destination (EpiCompartment):\n                compartment that the TransitionVariable enters.\n            transition_type (str):\n                only values defined in TransitionTypes Enum are valid, specifying\n                probability distribution of transitions between compartments.\n            is_jointly_distributed (bool):\n                indicates if transition quantity must be jointly computed\n                (i.e. if there are multiple outflows from the origin compartment).\n        \"\"\"\n\n        self.name = name\n\n        self.origin = origin\n        self.destination = destination\n\n        # Also see __init__ method in TransitionVariableGroup class.\n        #   The structure is similar.\n        self._transition_type = transition_type\n        self._is_jointly_distributed = is_jointly_distributed\n\n        if is_jointly_distributed:\n            self.get_realization = None\n        else:\n            self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_rate = 0\n        self.current_val = 0\n\n        self.history_vals_list = []\n\n    @abstractmethod\n    def get_current_rate(self, sim_state, fixed_params) -&gt; np.ndarray:\n        \"\"\"\n        Computes and returns current rate of transition variable,\n        based on current state of the simulation and epidemiological parameters.\n        Output should be a numpy array of size A x L, where A is\n        sim_state.num_age_groups and L is sim_state.num_risk_groups.\n\n        Args:\n            sim_state (SimState):\n                holds simulation state (current values of StateVariable instances).\n            fixed_params (FixedParams):\n                holds values of epidemiological parameters.\n\n        Returns:\n            np.ndarray:\n                holds age-risk transition rate,\n                must be same shape as origin.init_val,\n                i.e. be size A x L, where A is sim_state.num_age_groups\n                and L is sim_state.num_risk_groups.\n        \"\"\"\n        pass\n\n    def update_origin_outflow(self) -&gt; None:\n        self.origin.current_outflow += self.current_val\n\n    def update_destination_inflow(self) -&gt; None:\n        self.destination.current_inflow += self.current_val\n\n    def save_history(self) -&gt; None:\n        \"\"\"\n        Saves current value to history by appending current_val attribute\n            to history_vals_list in place\n\n        NOTE:\n            deep copying is CRUCIAL because current_val is a mutable\n            np.ndarray -- without deep copying, history_vals_list would\n            have the same value for all elements\n        \"\"\"\n        self.history_vals_list.append(copy.deepcopy(self.current_val))\n\n    def clear_history(self) -&gt; None:\n        self.history_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; TransitionTypes:\n        return self._transition_type\n\n    @property\n    def is_jointly_distributed(self) -&gt; bool:\n        return self._is_jointly_distributed\n\n    def get_binomial_realization(self,\n                                 RNG: np.random.Generator,\n                                 num_timesteps: int) -&gt; np.ndarray:\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=approx_binomial_probability_from_rate(self.current_rate, 1 / num_timesteps))\n\n    def get_binomial_taylor_approx_realization(self,\n                                               RNG: np.random.Generator,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        return RNG.binomial(n=np.asarray(self.base_count, dtype=int),\n                            p=self.current_rate * (1 / num_timesteps))\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        return RNG.poisson(self.base_count * self.current_rate * (1 / num_timesteps))\n\n    def get_binomial_deterministic_realization(self,\n                                               num_timesteps: int) -&gt; np.ndarray:\n        return np.asarray(self.base_count *\n                          approx_binomial_probability_from_rate(self.current_rate, 1 / num_timesteps),\n                          dtype=int)\n\n    def get_binomial_taylor_approx_deterministic_realization(self,\n                                                             num_timesteps: int) -&gt; np.ndarray:\n        return np.asarray(self.base_count * self.current_rate * (1 / num_timesteps), dtype=int)\n\n    def get_poisson_deterministic_realization(self,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        return np.asarray(self.base_count * self.current_rate * (1 / num_timesteps), dtype=int)\n\n    @property\n    def base_count(self) -&gt; np.ndarray:\n        return self.origin.current_val\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariable.__init__","title":"<code>__init__(name, origin, destination, transition_type, is_jointly_distributed=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>user-specified name for compartment.</p> required <code>origin</code> <code>EpiCompartment</code> <p>the compartment from which Transition Variable exits.</p> required <code>destination</code> <code>EpiCompartment</code> <p>compartment that the TransitionVariable enters.</p> required <code>transition_type</code> <code>str</code> <p>only values defined in TransitionTypes Enum are valid, specifying probability distribution of transitions between compartments.</p> required <code>is_jointly_distributed</code> <code>bool</code> <p>indicates if transition quantity must be jointly computed (i.e. if there are multiple outflows from the origin compartment).</p> <code>False</code> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def __init__(self,\n             name,\n             origin,\n             destination,\n             transition_type,\n             is_jointly_distributed=False):\n    \"\"\"\n    Parameters:\n        name (str):\n            user-specified name for compartment.\n        origin (EpiCompartment):\n            the compartment from which Transition Variable exits.\n        destination (EpiCompartment):\n            compartment that the TransitionVariable enters.\n        transition_type (str):\n            only values defined in TransitionTypes Enum are valid, specifying\n            probability distribution of transitions between compartments.\n        is_jointly_distributed (bool):\n            indicates if transition quantity must be jointly computed\n            (i.e. if there are multiple outflows from the origin compartment).\n    \"\"\"\n\n    self.name = name\n\n    self.origin = origin\n    self.destination = destination\n\n    # Also see __init__ method in TransitionVariableGroup class.\n    #   The structure is similar.\n    self._transition_type = transition_type\n    self._is_jointly_distributed = is_jointly_distributed\n\n    if is_jointly_distributed:\n        self.get_realization = None\n    else:\n        self.get_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_rate = 0\n    self.current_val = 0\n\n    self.history_vals_list = []\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariable.get_current_rate","title":"<code>get_current_rate(sim_state, fixed_params)</code>  <code>abstractmethod</code>","text":"<p>Computes and returns current rate of transition variable, based on current state of the simulation and epidemiological parameters. Output should be a numpy array of size A x L, where A is sim_state.num_age_groups and L is sim_state.num_risk_groups.</p> <p>Parameters:</p> Name Type Description Default <code>sim_state</code> <code>SimState</code> <p>holds simulation state (current values of StateVariable instances).</p> required <code>fixed_params</code> <code>FixedParams</code> <p>holds values of epidemiological parameters.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: holds age-risk transition rate, must be same shape as origin.init_val, i.e. be size A x L, where A is sim_state.num_age_groups and L is sim_state.num_risk_groups.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>@abstractmethod\ndef get_current_rate(self, sim_state, fixed_params) -&gt; np.ndarray:\n    \"\"\"\n    Computes and returns current rate of transition variable,\n    based on current state of the simulation and epidemiological parameters.\n    Output should be a numpy array of size A x L, where A is\n    sim_state.num_age_groups and L is sim_state.num_risk_groups.\n\n    Args:\n        sim_state (SimState):\n            holds simulation state (current values of StateVariable instances).\n        fixed_params (FixedParams):\n            holds values of epidemiological parameters.\n\n    Returns:\n        np.ndarray:\n            holds age-risk transition rate,\n            must be same shape as origin.init_val,\n            i.e. be size A x L, where A is sim_state.num_age_groups\n            and L is sim_state.num_risk_groups.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariable.save_history","title":"<code>save_history()</code>","text":"<p>Saves current value to history by appending current_val attribute     to history_vals_list in place</p> NOTE <p>deep copying is CRUCIAL because current_val is a mutable np.ndarray -- without deep copying, history_vals_list would have the same value for all elements</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def save_history(self) -&gt; None:\n    \"\"\"\n    Saves current value to history by appending current_val attribute\n        to history_vals_list in place\n\n    NOTE:\n        deep copying is CRUCIAL because current_val is a mutable\n        np.ndarray -- without deep copying, history_vals_list would\n        have the same value for all elements\n    \"\"\"\n    self.history_vals_list.append(copy.deepcopy(self.current_val))\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup","title":"<code>TransitionVariableGroup</code>","text":"<p>Container for TransitionVariable objects to handle joint sampling, when there are multiple outflows from a single compartment.</p> <p>For example, if all outflows of compartment H are: R and D, i.e. from the Hospital compartment, people either go to Recovered or Dead, a TransitionVariableGroup that holds both R and D handles the correct correlation structure between R and D.</p> <p>When an instance is initialized, its get_joint_realization attribute is dynamically assigned to a method according to its transition_type attribute. This enables all instances to use the same method during simulation.</p> <p>Attributes:</p> Name Type Description <code>origin</code> <code>EpiCompartment</code> <p>specifies origin of TransitionVariableGroup -- corresponding populations leave this compartment.</p> <code>_transition_type</code> <code>str</code> <p>only values defined in JointTransitionTypes Enum are valid, specifies joint probability distribution of all outflows from origin.</p> <code>transition_variables</code> <code>list[TransitionVariable]</code> <p>specifying TransitionVariable instances that outflow from origin -- order does not matter.</p> <code>get_joint_realization</code> <code>function</code> <p>assigned at initialization, generates realizations according to probability distribution given by _transition_type attribute, returns either (M x A x L) or ((M+1) x A x L) np.ndarray, where M is the length of transition_variables (i.e., number of outflows from origin), A is number of age groups, L is number of risk groups.</p> <code>current_vals_list</code> <code>list</code> <p>used to store results from get_joint_realization -- has either M or M+1 arrays of size A x L.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>class TransitionVariableGroup:\n    \"\"\"\n    Container for TransitionVariable objects to handle joint sampling,\n    when there are multiple outflows from a single compartment.\n\n    For example, if all outflows of compartment H are: R and D,\n    i.e. from the Hospital compartment, people either go to Recovered\n    or Dead, a TransitionVariableGroup that holds both R and D handles\n    the correct correlation structure between R and D.\n\n    When an instance is initialized, its get_joint_realization attribute\n    is dynamically assigned to a method according to its transition_type\n    attribute. This enables all instances to use the same method during\n    simulation.\n\n    Attributes:\n        origin (EpiCompartment):\n            specifies origin of TransitionVariableGroup --\n            corresponding populations leave this compartment.\n        _transition_type (str):\n            only values defined in JointTransitionTypes Enum are valid,\n            specifies joint probability distribution of all outflows\n            from origin.\n        transition_variables (list[TransitionVariable]):\n            specifying TransitionVariable instances that outflow from origin --\n            order does not matter.\n        get_joint_realization (function):\n            assigned at initialization, generates realizations according\n            to probability distribution given by _transition_type attribute,\n            returns either (M x A x L) or ((M+1) x A x L) np.ndarray,\n            where M is the length of transition_variables (i.e., number of\n            outflows from origin), A is number of age groups, L is number of\n            risk groups.\n        current_vals_list (list):\n            used to store results from get_joint_realization --\n            has either M or M+1 arrays of size A x L.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 name,\n                 origin,\n                 transition_type,\n                 transition_variables):\n        \"\"\"\n        Args:\n            name (str):\n                user-specified name for compartment.\n            transition_type (str):\n                only values defined in TransitionTypes Enum are valid, specifying\n                probability distribution of transitions between compartments.\n\n        See class docstring for other parameters.\n        \"\"\"\n\n        self.name = name\n\n        self.origin = origin\n        self.transition_variables = transition_variables\n\n        # If marginal transition type is any kind of binomial transition,\n        #   then its joint transition type is a multinomial counterpart\n        # For example, if the marginal transition type is TransitionTypes.BINOMIAL_DETERMINISTIC,\n        #   then the joint transition type is JointTransitionTypes.MULTINOMIAL_DETERMINISTIC\n        transition_type = transition_type.replace(\"binomial\", \"multinomial\")\n        self._transition_type = transition_type\n\n        # Dynamically assign a method to get_joint_realization attribute\n        #   based on the value of transition_type\n        # getattr fetches a method by name\n        self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n        self.current_vals_list = []\n\n    @property\n    def transition_type(self) -&gt; JointTransitionTypes:\n        return self._transition_type\n\n    def get_total_rate(self) -&gt; np.ndarray:\n        \"\"\"\n        Return the age-risk-specific total transition rate,\n        which is the sum of the current rate of each transition variable\n        in this transition variable group.\n\n        Used to properly scale multinomial probabilities vector so\n        that elements sum to 1.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, has size equal to number\n                of age groups x number of risk groups,\n                sum of current rates of transition variables in\n                transition variable group.\n        \"\"\"\n\n        # axis 0: corresponds to outgoing transition variable\n        # axis 1: corresponds to age groups\n        # axis 2: corresponds to risk groups\n        # --&gt; summing over axis 0 gives the total rate for each age-risk group\n        return np.sum(self.get_current_rates_array(), axis=0)\n\n    def get_probabilities_array(self,\n                                num_timesteps: int) -&gt; list:\n        \"\"\"\n        Returns an array of probabilities used for joint binomial\n        (multinomial) transitions (get_multinomial_realization method).\n\n        Returns:\n            np.ndarray:\n                contains positive floats &lt;= 1, size equal to\n                ((length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        total_rate = self.get_total_rate()\n\n        total_outgoing_probability = approx_binomial_probability_from_rate(total_rate,\n                                                                           1 / num_timesteps)\n\n        # Create probabilities_list, where element i corresponds to the\n        #   transition variable i's current rate divided by the total rate,\n        #   multiplied by the total outgoing probability\n        # This generates the probabilities array that parameterizes the\n        #   multinomial distribution\n        probabilities_list = []\n\n        for transition_variable in self.transition_variables:\n            probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                      total_outgoing_probability)\n\n        # Append the probability that a person stays in the compartment\n        probabilities_list.append(1 - total_outgoing_probability)\n\n        return np.asarray(probabilities_list)\n\n    def get_current_rates_array(self) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of current rates of transition variables in\n        self.transition_variables -- ith element in array\n        corresponds to current rate of ith transition variable.\n\n        Returns:\n            np.ndarray:\n                array of positive floats, size equal to (length of outgoing\n                transition variables list x number of age groups x number of risk groups).\n        \"\"\"\n\n        current_rates_list = []\n        for tvar in self.transition_variables:\n            current_rates_list.append(tvar.current_rate)\n\n        return np.asarray(current_rates_list)\n\n    def get_joint_realization(self) -&gt; np.ndarray:\n        \"\"\"\n        This function is dynamically assigned based on the Transition\n        Variable Group's transition type -- this function is set to\n        one of the following methods: get_multinomial_realization,\n        get_multinomial_taylor_approx_realization, get_poisson_realization,\n        get_multinomial_deterministic_realization,\n        get_multinomial_taylor_approx_deterministic_realization,\n        get_poisson_deterministic_realization.\n        \"\"\"\n\n        pass\n\n    def get_multinomial_realization(self,\n                                    RNG: np.random.Generator,\n                                    num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                ((length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups) --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    probabilities_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_multinomial_taylor_approx_realization(self,\n                                                  RNG: np.random.Generator,\n                                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from multinomial distribution\n        using Taylor Series approximation for probability parameter.\n\n        Returns:\n            np.ndarray:\n                size equal to (length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        current_rates_array = self.get_current_rates_array()\n\n        total_rate = self.get_total_rate()\n\n        # Multiply current rates array by length of time interval (1 / num_timesteps)\n        # Also append additional value corresponding to probability of\n        #   remaining in current epi compartment (not transitioning at all)\n        # Note: \"vstack\" function here works better than append function because append\n        #   automatically flattens the resulting array, resulting in dimension issues\n        current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                                np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n        #   the number who stay/remain in the compartment\n        realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                    np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                    current_scaled_rates_array[:, age_group, risk_group])\n\n        return realizations_array\n\n    def get_poisson_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Returns an array of transition realizations (number transitioning\n        to outgoing compartments) sampled from Poisson distribution.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to length of\n                (outgoing transition variables list x number of age groups x number of risk groups).\n        \"\"\"\n\n        num_outflows = len(self.transition_variables)\n\n        num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n        realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n        transition_variables = self.transition_variables\n\n        for age_group in range(num_age_groups):\n            for risk_group in range(num_risk_groups):\n                for outflow_ix in range(num_outflows):\n                    realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                        self.origin.current_val[age_group, risk_group] *\n                        transition_variables[outflow_ix].current_rate[\n                            age_group, risk_group] * 1 / num_timesteps)\n\n        return realizations_array\n\n    def get_multinomial_deterministic_realization(self,\n                                                  num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to get_multinomial_realization --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                (length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        probabilities_array = self.get_probabilities_array(num_timesteps)\n        return self.origin.current_val * probabilities_array\n\n    def get_multinomial_taylor_approx_deterministic_realization(self,\n                                                                num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to get_multinomial_taylor_approx_realization --\n        uses mean (n x p, i.e. total counts x probability array) as realization\n        rather than randomly sampling.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                (length of outgoing transition variables list + 1)\n                x number of age groups x number of risk groups --\n                note the \"+1\" corresponds to the multinomial outcome of staying\n                in the same epi compartment (not transitioning to any outgoing\n                epi compartment).\n        \"\"\"\n\n        current_rates_array = self.get_current_rates_array()\n        return self.origin.current_val * current_rates_array / num_timesteps\n\n    def get_poisson_deterministic_realization(self,\n                                              num_timesteps: int) -&gt; np.ndarray:\n        \"\"\"\n        Deterministic counterpart to get_poisson_realization --\n        uses mean (rate array) as realization rather than randomly sampling.\n\n        Returns:\n            np.ndarray:\n                contains positive floats, size equal to\n                (length of outgoing transition variables list\n                x number of age groups x number of risk groups).\n        \"\"\"\n\n        return self.get_current_rates_array() / num_timesteps\n\n    def reset(self) -&gt; None:\n        self.current_vals_list = []\n\n    def update_transition_variable_realizations(self) -&gt; None:\n        \"\"\"\n        Updates current_val attribute on all\n        TransitionVariable instances contained in this\n        transition variable group.\n        \"\"\"\n\n        # Since the ith element in probabilities_array corresponds to the ith transition variable\n        #   in transition_variables, the ith element in multinomial_realizations_list\n        #   also corresponds to the ith transition variable in transition_variables\n        # Update the current realization of the transition variables contained in this group\n        for ix in range(len(self.transition_variables)):\n            self.transition_variables[ix].current_val = \\\n                self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.__init__","title":"<code>__init__(name, origin, transition_type, transition_variables)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>user-specified name for compartment.</p> required <code>transition_type</code> <code>str</code> <p>only values defined in TransitionTypes Enum are valid, specifying probability distribution of transitions between compartments.</p> required <p>See class docstring for other parameters.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def __init__(self,\n             name,\n             origin,\n             transition_type,\n             transition_variables):\n    \"\"\"\n    Args:\n        name (str):\n            user-specified name for compartment.\n        transition_type (str):\n            only values defined in TransitionTypes Enum are valid, specifying\n            probability distribution of transitions between compartments.\n\n    See class docstring for other parameters.\n    \"\"\"\n\n    self.name = name\n\n    self.origin = origin\n    self.transition_variables = transition_variables\n\n    # If marginal transition type is any kind of binomial transition,\n    #   then its joint transition type is a multinomial counterpart\n    # For example, if the marginal transition type is TransitionTypes.BINOMIAL_DETERMINISTIC,\n    #   then the joint transition type is JointTransitionTypes.MULTINOMIAL_DETERMINISTIC\n    transition_type = transition_type.replace(\"binomial\", \"multinomial\")\n    self._transition_type = transition_type\n\n    # Dynamically assign a method to get_joint_realization attribute\n    #   based on the value of transition_type\n    # getattr fetches a method by name\n    self.get_joint_realization = getattr(self, \"get_\" + transition_type + \"_realization\")\n\n    self.current_vals_list = []\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_current_rates_array","title":"<code>get_current_rates_array()</code>","text":"<p>Returns an array of current rates of transition variables in self.transition_variables -- ith element in array corresponds to current rate of ith transition variable.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: array of positive floats, size equal to (length of outgoing transition variables list x number of age groups x number of risk groups).</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_current_rates_array(self) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of current rates of transition variables in\n    self.transition_variables -- ith element in array\n    corresponds to current rate of ith transition variable.\n\n    Returns:\n        np.ndarray:\n            array of positive floats, size equal to (length of outgoing\n            transition variables list x number of age groups x number of risk groups).\n    \"\"\"\n\n    current_rates_list = []\n    for tvar in self.transition_variables:\n        current_rates_list.append(tvar.current_rate)\n\n    return np.asarray(current_rates_list)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_joint_realization","title":"<code>get_joint_realization()</code>","text":"<p>This function is dynamically assigned based on the Transition Variable Group's transition type -- this function is set to one of the following methods: get_multinomial_realization, get_multinomial_taylor_approx_realization, get_poisson_realization, get_multinomial_deterministic_realization, get_multinomial_taylor_approx_deterministic_realization, get_poisson_deterministic_realization.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_joint_realization(self) -&gt; np.ndarray:\n    \"\"\"\n    This function is dynamically assigned based on the Transition\n    Variable Group's transition type -- this function is set to\n    one of the following methods: get_multinomial_realization,\n    get_multinomial_taylor_approx_realization, get_poisson_realization,\n    get_multinomial_deterministic_realization,\n    get_multinomial_taylor_approx_deterministic_realization,\n    get_poisson_deterministic_realization.\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_multinomial_deterministic_realization","title":"<code>get_multinomial_deterministic_realization(num_timesteps)</code>","text":"<p>Deterministic counterpart to get_multinomial_realization -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to (length of outgoing transition variables list + 1) x number of age groups x number of risk groups -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_multinomial_deterministic_realization(self,\n                                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to get_multinomial_realization --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            (length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n    return self.origin.current_val * probabilities_array\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_multinomial_realization","title":"<code>get_multinomial_realization(RNG, num_timesteps)</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to ((length of outgoing transition variables list + 1) x number of age groups x number of risk groups) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_multinomial_realization(self,\n                                RNG: np.random.Generator,\n                                num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            ((length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    probabilities_array = self.get_probabilities_array(num_timesteps)\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                probabilities_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_multinomial_taylor_approx_deterministic_realization","title":"<code>get_multinomial_taylor_approx_deterministic_realization(num_timesteps)</code>","text":"<p>Deterministic counterpart to get_multinomial_taylor_approx_realization -- uses mean (n x p, i.e. total counts x probability array) as realization rather than randomly sampling.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to (length of outgoing transition variables list + 1) x number of age groups x number of risk groups -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_multinomial_taylor_approx_deterministic_realization(self,\n                                                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to get_multinomial_taylor_approx_realization --\n    uses mean (n x p, i.e. total counts x probability array) as realization\n    rather than randomly sampling.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            (length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    current_rates_array = self.get_current_rates_array()\n    return self.origin.current_val * current_rates_array / num_timesteps\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_multinomial_taylor_approx_realization","title":"<code>get_multinomial_taylor_approx_realization(RNG, num_timesteps)</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from multinomial distribution using Taylor Series approximation for probability parameter.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: size equal to (length of outgoing transition variables list + 1) x number of age groups x number of risk groups -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_multinomial_taylor_approx_realization(self,\n                                              RNG: np.random.Generator,\n                                              num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from multinomial distribution\n    using Taylor Series approximation for probability parameter.\n\n    Returns:\n        np.ndarray:\n            size equal to (length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    current_rates_array = self.get_current_rates_array()\n\n    total_rate = self.get_total_rate()\n\n    # Multiply current rates array by length of time interval (1 / num_timesteps)\n    # Also append additional value corresponding to probability of\n    #   remaining in current epi compartment (not transitioning at all)\n    # Note: \"vstack\" function here works better than append function because append\n    #   automatically flattens the resulting array, resulting in dimension issues\n    current_scaled_rates_array = np.vstack((current_rates_array / num_timesteps,\n                                            np.expand_dims(1 - total_rate / num_timesteps, axis=0)))\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    # We use num_outflows + 1 because for the multinomial distribution we explicitly model\n    #   the number who stay/remain in the compartment\n    realizations_array = np.zeros((num_outflows + 1, num_age_groups, num_risk_groups))\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            realizations_array[:, age_group, risk_group] = RNG.multinomial(\n                np.asarray(self.origin.current_val[age_group, risk_group], dtype=int),\n                current_scaled_rates_array[:, age_group, risk_group])\n\n    return realizations_array\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_poisson_deterministic_realization","title":"<code>get_poisson_deterministic_realization(num_timesteps)</code>","text":"<p>Deterministic counterpart to get_poisson_realization -- uses mean (rate array) as realization rather than randomly sampling.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to (length of outgoing transition variables list x number of age groups x number of risk groups).</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_poisson_deterministic_realization(self,\n                                          num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Deterministic counterpart to get_poisson_realization --\n    uses mean (rate array) as realization rather than randomly sampling.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to\n            (length of outgoing transition variables list\n            x number of age groups x number of risk groups).\n    \"\"\"\n\n    return self.get_current_rates_array() / num_timesteps\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_poisson_realization","title":"<code>get_poisson_realization(RNG, num_timesteps)</code>","text":"<p>Returns an array of transition realizations (number transitioning to outgoing compartments) sampled from Poisson distribution.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, size equal to length of (outgoing transition variables list x number of age groups x number of risk groups).</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_poisson_realization(self,\n                            RNG: np.random.Generator,\n                            num_timesteps: int) -&gt; np.ndarray:\n    \"\"\"\n    Returns an array of transition realizations (number transitioning\n    to outgoing compartments) sampled from Poisson distribution.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, size equal to length of\n            (outgoing transition variables list x number of age groups x number of risk groups).\n    \"\"\"\n\n    num_outflows = len(self.transition_variables)\n\n    num_age_groups, num_risk_groups = np.shape(self.origin.current_val)\n\n    realizations_array = np.zeros((num_outflows, num_age_groups, num_risk_groups))\n\n    transition_variables = self.transition_variables\n\n    for age_group in range(num_age_groups):\n        for risk_group in range(num_risk_groups):\n            for outflow_ix in range(num_outflows):\n                realizations_array[outflow_ix, age_group, risk_group] = RNG.poisson(\n                    self.origin.current_val[age_group, risk_group] *\n                    transition_variables[outflow_ix].current_rate[\n                        age_group, risk_group] * 1 / num_timesteps)\n\n    return realizations_array\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_probabilities_array","title":"<code>get_probabilities_array(num_timesteps)</code>","text":"<p>Returns an array of probabilities used for joint binomial (multinomial) transitions (get_multinomial_realization method).</p> <p>Returns:</p> Type Description <code>list</code> <p>np.ndarray: contains positive floats &lt;= 1, size equal to ((length of outgoing transition variables list + 1) x number of age groups x number of risk groups) -- note the \"+1\" corresponds to the multinomial outcome of staying in the same epi compartment (not transitioning to any outgoing epi compartment).</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_probabilities_array(self,\n                            num_timesteps: int) -&gt; list:\n    \"\"\"\n    Returns an array of probabilities used for joint binomial\n    (multinomial) transitions (get_multinomial_realization method).\n\n    Returns:\n        np.ndarray:\n            contains positive floats &lt;= 1, size equal to\n            ((length of outgoing transition variables list + 1)\n            x number of age groups x number of risk groups) --\n            note the \"+1\" corresponds to the multinomial outcome of staying\n            in the same epi compartment (not transitioning to any outgoing\n            epi compartment).\n    \"\"\"\n\n    total_rate = self.get_total_rate()\n\n    total_outgoing_probability = approx_binomial_probability_from_rate(total_rate,\n                                                                       1 / num_timesteps)\n\n    # Create probabilities_list, where element i corresponds to the\n    #   transition variable i's current rate divided by the total rate,\n    #   multiplied by the total outgoing probability\n    # This generates the probabilities array that parameterizes the\n    #   multinomial distribution\n    probabilities_list = []\n\n    for transition_variable in self.transition_variables:\n        probabilities_list.append((transition_variable.current_rate / total_rate) *\n                                  total_outgoing_probability)\n\n    # Append the probability that a person stays in the compartment\n    probabilities_list.append(1 - total_outgoing_probability)\n\n    return np.asarray(probabilities_list)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.get_total_rate","title":"<code>get_total_rate()</code>","text":"<p>Return the age-risk-specific total transition rate, which is the sum of the current rate of each transition variable in this transition variable group.</p> <p>Used to properly scale multinomial probabilities vector so that elements sum to 1.</p> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: contains positive floats, has size equal to number of age groups x number of risk groups, sum of current rates of transition variables in transition variable group.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def get_total_rate(self) -&gt; np.ndarray:\n    \"\"\"\n    Return the age-risk-specific total transition rate,\n    which is the sum of the current rate of each transition variable\n    in this transition variable group.\n\n    Used to properly scale multinomial probabilities vector so\n    that elements sum to 1.\n\n    Returns:\n        np.ndarray:\n            contains positive floats, has size equal to number\n            of age groups x number of risk groups,\n            sum of current rates of transition variables in\n            transition variable group.\n    \"\"\"\n\n    # axis 0: corresponds to outgoing transition variable\n    # axis 1: corresponds to age groups\n    # axis 2: corresponds to risk groups\n    # --&gt; summing over axis 0 gives the total rate for each age-risk group\n    return np.sum(self.get_current_rates_array(), axis=0)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransitionVariableGroup.update_transition_variable_realizations","title":"<code>update_transition_variable_realizations()</code>","text":"<p>Updates current_val attribute on all TransitionVariable instances contained in this transition variable group.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def update_transition_variable_realizations(self) -&gt; None:\n    \"\"\"\n    Updates current_val attribute on all\n    TransitionVariable instances contained in this\n    transition variable group.\n    \"\"\"\n\n    # Since the ith element in probabilities_array corresponds to the ith transition variable\n    #   in transition_variables, the ith element in multinomial_realizations_list\n    #   also corresponds to the ith transition variable in transition_variables\n    # Update the current realization of the transition variables contained in this group\n    for ix in range(len(self.transition_variables)):\n        self.transition_variables[ix].current_val = \\\n            self.current_vals_list[ix, :, :]\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransmissionModel","title":"<code>TransmissionModel</code>","text":"<p>Contains and manages all necessary components for simulating a compartmental model, including compartments epi metrics, dynamic vals, a data container for the current simulation state, transition variables and transition variable groups, epidemiological parameters, simulation experiment configuration parameters, and a random number generator.</p> <p>All city-level models, regardless of disease type and compartment/transition structure, are instances of this class.</p> <p>When creating an instance, the order of elements does not matter within compartments, epi_metrics, dynamic_vals, transition_variables, and transition_variable_groups. The \"flow\" and \"physics\" information are stored on the objects.</p> <p>Attributes:</p> Name Type Description <code>state_variable_manager</code> <code>StateVariableManager</code> <p>holds all the model's StateVariable instances.</p> <code>transition_variables</code> <code>list</code> <p>list of all the model's TransitionVariable instances.</p> <code>transition_variable_groups</code> <code>list</code> <p>list of all the model's TransitionVariableGroup instances.</p> <code>fixed_params</code> <code>FixedParams</code> <p>data container for the model's epidemiological parameters, such as the \"Greek letters\" characterizing sojourn times in compartments.</p> <code>config</code> <code>Config</code> <p>data container for the model's simulation configuration values.</p> <code>RNG</code> <code>np.random.Generator object</code> <p>used to generate random variables and control reproducibility.</p> <code>current_simulation_day</code> <code>int</code> <p>tracks current simulation day -- incremented by +1 when config.timesteps_per_day discretized timesteps have completed.</p> <code>lookup_by_name</code> <code>dict</code> <p>keys are names of StateVariable, TransitionVariable, and TransitionVariableGroup instances associated with the model -- values are the actual object.</p> <p>See init docstring for other attributes.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>class TransmissionModel:\n    \"\"\"\n    Contains and manages all necessary components for\n    simulating a compartmental model, including compartments\n    epi metrics, dynamic vals, a data container for the current simulation\n    state, transition variables and transition variable groups,\n    epidemiological parameters, simulation experiment configuration\n    parameters, and a random number generator.\n\n    All city-level models, regardless of disease type and\n    compartment/transition structure, are instances of this class.\n\n    When creating an instance, the order of elements does not matter\n    within compartments, epi_metrics, dynamic_vals,\n    transition_variables, and transition_variable_groups.\n    The \"flow\" and \"physics\" information are stored on the objects.\n\n    Attributes:\n        state_variable_manager (StateVariableManager):\n            holds all the model's StateVariable instances.\n        transition_variables (list):\n            list of all the model's TransitionVariable instances.\n        transition_variable_groups (list):\n            list of all the model's TransitionVariableGroup instances.\n        fixed_params (FixedParams):\n            data container for the model's epidemiological parameters,\n            such as the \"Greek letters\" characterizing sojourn times\n            in compartments.\n        config (Config):\n            data container for the model's simulation configuration values.\n        RNG (np.random.Generator object):\n            used to generate random variables and control reproducibility.\n        current_simulation_day (int):\n            tracks current simulation day -- incremented by +1\n            when config.timesteps_per_day discretized timesteps\n            have completed.\n        lookup_by_name (dict):\n            keys are names of StateVariable, TransitionVariable,\n            and TransitionVariableGroup instances associated\n            with the model -- values are the actual object.\n\n    See __init__ docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 state_variable_manager,\n                 transition_variables,\n                 transition_variable_groups,\n                 fixed_params,\n                 config,\n                 RNG_seed):\n        \"\"\"\n        TODO: maybe group arguments together into dataclass to simplify?\n\n        Args:\n            RNG_seed (positive int):\n                used to initialize the model's RNG for generating\n                random variables and random transitions.\n\n        See class docstring for other parameters.\n        \"\"\"\n\n        self.state_variable_manager = state_variable_manager\n        self.compartments = state_variable_manager.compartments\n        self.epi_metrics = state_variable_manager.epi_metrics\n        self.dynamic_vals = state_variable_manager.dynamic_vals\n        self.schedules = state_variable_manager.schedules\n\n        self.transition_variables = transition_variables\n        self.transition_variable_groups = transition_variable_groups\n\n        self.fixed_params = fixed_params\n        self.config = config\n\n        # Create bit generator seeded with given RNG_seed\n        self._bit_generator = np.random.MT19937(seed=RNG_seed)\n        self.RNG = np.random.Generator(self._bit_generator)\n\n        self.current_simulation_day = 0\n\n        if isinstance(config.start_real_date, datetime.date):\n            self.start_real_date = config.start_real_date\n        else:\n            try:\n                self.start_real_date = \\\n                    datetime.datetime.strptime(config.start_real_date, \"%Y-%m-%d\").date()\n            except ValueError:\n                print(\"Error: The date format should be YYYY-MM-DD.\")\n        self.current_real_date = self.start_real_date\n\n        self.lookup_by_name = self.create_lookup_by_name()\n\n    def modify_random_seed(self, new_seed_number) -&gt; None:\n        \"\"\"\n        Modifies model's RNG attribute in-place to new generator\n        seeded at new_seed_number.\n\n        Args:\n            new_seed_number (int):\n                used to re-seed model's random number generator.\n        \"\"\"\n\n        self._bit_generator = np.random.MT19937(seed=new_seed_number)\n        self.RNG = np.random.Generator(self._bit_generator)\n\n    def create_lookup_by_name(self) -&gt; dict:\n        \"\"\"\n        Create lookup_by_name attribute --\n        keys are names of StateVariable, TransitionVariable,\n        and TransitionVariableGroup instances associated\n        with the model -- values are the actual object.\n        \"\"\"\n\n        lookup_by_name = {}\n\n        for unit in self.compartments + self.epi_metrics + \\\n                    self.dynamic_vals + self.schedules + \\\n                    self.transition_variables + self.transition_variable_groups:\n            lookup_by_name[unit.name] = unit\n\n        return lookup_by_name\n\n    def simulate_until_time_period(self, last_simulation_day) -&gt; None:\n        \"\"\"\n        Advance simulation model time until last_simulation_day.\n\n        Advance time by iterating through simulation days,\n        which are simulated by iterating through discretized\n        timesteps.\n\n        Save daily simulation data as history on each EpiCompartment\n        instance.\n\n        Args:\n            last_simulation_day (positive int):\n                stop simulation at last_simulation_day (i.e. exclusive,\n                simulate up to but not including last_simulation_day).\n        \"\"\"\n\n        if self.current_simulation_day &gt; last_simulation_day:\n            raise TransmissionModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                         f\"exceeds last simulation day ({last_simulation_day}).\")\n\n        save_daily_history = self.config.save_daily_history\n\n        # last_simulation_day is exclusive endpoint\n        while self.current_simulation_day &lt; last_simulation_day:\n\n            self._prepare_daily_state()\n\n            self._simulate_timesteps()\n\n            if save_daily_history:\n                self._save_daily_history()\n\n            self._increment_simulation_day()\n\n    def _simulate_timesteps(self) -&gt; None:\n        \"\"\"\n        Subroutine for simulate_until_time_period.\n\n        Iterates through discretized timesteps to simulate next\n        simulation day. Granularity of discretization is given by\n        attribute config.timesteps_per_day.\n\n        Properly scales transition variable realizations and changes\n        in dynamic vals by specified timesteps per day.\n        \"\"\"\n\n        for timestep in range(self.config.timesteps_per_day):\n            self._update_epi_metrics()\n\n            self._update_transition_rates()\n\n            self._sample_transitions()\n\n            self._update_compartments()\n\n            self.state_variable_manager.update_sim_state(self.epi_metrics +\n                                                         self.compartments)\n\n    def _prepare_daily_state(self) -&gt; None:\n        \"\"\"\n        At beginning of each day, update current value of\n        schedules and dynamic values -- note that schedules\n        and dynamic values are only updated once a day, not\n        for every discretized timestep.\n        \"\"\"\n\n        sim_state = self.state_variable_manager.sim_state\n        fixed_params = self.fixed_params\n        current_real_date = self.current_real_date\n\n        schedules = self.schedules\n        dynamic_vals = self.dynamic_vals\n\n        # Update schedules for current day\n        for schedule in schedules:\n            schedule.update_current_val(current_real_date)\n\n        # Update dynamic values for current day\n        for dval in dynamic_vals:\n            dval.update_current_val(sim_state, fixed_params)\n\n        # Sync simulation state\n        self.state_variable_manager.update_sim_state(schedules + dynamic_vals)\n\n    def _update_epi_metrics(self):\n\n        sim_state = self.state_variable_manager.sim_state\n        fixed_params = self.fixed_params\n        timesteps_per_day = self.config.timesteps_per_day\n\n        for metric in self.epi_metrics:\n            metric.change_in_current_val = \\\n                metric.get_change_in_current_val(sim_state,\n                                                 fixed_params,\n                                                 timesteps_per_day)\n            metric.update_current_val()\n\n    def _update_transition_rates(self):\n\n        sim_state = self.state_variable_manager.sim_state\n        fixed_params = self.fixed_params\n\n        for tvar in self.transition_variables:\n            tvar.current_rate = tvar.get_current_rate(sim_state, fixed_params)\n\n    def _sample_transitions(self):\n\n        RNG = self.RNG\n        timesteps_per_day = self.config.timesteps_per_day\n\n        # Obtain transition variable realizations for jointly distributed transition variables\n        #   (i.e. when there are multiple transition variable outflows from an epi compartment)\n        for tvargroup in self.transition_variable_groups:\n            tvargroup.current_vals_list = tvargroup.get_joint_realization(RNG,\n                                                                          timesteps_per_day)\n            tvargroup.update_transition_variable_realizations()\n\n        # Obtain transition variable realizations for marginally distributed transition variables\n        #   (i.e. when there is only one transition variable outflow from an epi compartment)\n        # If transition variable is jointly distributed, then its realization has already\n        #   been computed by its transition variable group container previously,\n        #   so skip the marginal computation\n        for tvar in self.transition_variables:\n            if not tvar.is_jointly_distributed:\n                tvar.current_val = tvar.get_realization(RNG, timesteps_per_day)\n\n    def _update_compartments(self):\n\n        for tvar in self.transition_variables:\n            tvar.update_origin_outflow()\n            tvar.update_destination_inflow()\n\n        for compartment in self.compartments:\n            compartment.update_current_val()\n\n            compartment.reset_inflow()\n            compartment.reset_outflow()\n\n    def _increment_simulation_day(self) -&gt; None:\n        \"\"\"\n        Move to next day in simulation\n        \"\"\"\n\n        self.current_simulation_day += 1\n        self.current_real_date += datetime.timedelta(days=1)\n\n    def _save_daily_history(self):\n        \"\"\"\n        Update history at end of each day, not at end of every\n           discretization timestep, to be efficient.\n        Update history of state variables other than Schedule\n           instances -- schedules do not have history\n           TransitionVariableGroup instances also do not\n           have history, so do not include.\n        \"\"\"\n        for svar in self.compartments + self.epi_metrics + self.dynamic_vals:\n            svar.save_history()\n\n    def reset_simulation(self) -&gt; None:\n        \"\"\"\n        Reset simulation in-place. Subsequent method calls of\n        simulate_until_time_period start from day 0, with original\n        day 0 state.\n\n        Returns current_simulation_day to 0.\n        Restores sim_state values to initial values.\n        Clears history on model's compartments, transition variables,\n        and dynamic vals.\n\n        WARNING:\n            DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n            ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n            WHERE IT LEFT OFF.\n\n        Use method modify_random_seed to reset model's RNG to its\n        initial starting seed.\n        \"\"\"\n\n        self.current_simulation_day = 0\n\n        self.current_real_date = self.start_real_date\n\n        self.state_variable_manager.reset_sim_state()\n\n        self.state_variable_manager.clear_history()\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransmissionModel.__init__","title":"<code>__init__(state_variable_manager, transition_variables, transition_variable_groups, fixed_params, config, RNG_seed)</code>","text":"<p>TODO: maybe group arguments together into dataclass to simplify?</p> <p>Parameters:</p> Name Type Description Default <code>RNG_seed</code> <code>positive int</code> <p>used to initialize the model's RNG for generating random variables and random transitions.</p> required <p>See class docstring for other parameters.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def __init__(self,\n             state_variable_manager,\n             transition_variables,\n             transition_variable_groups,\n             fixed_params,\n             config,\n             RNG_seed):\n    \"\"\"\n    TODO: maybe group arguments together into dataclass to simplify?\n\n    Args:\n        RNG_seed (positive int):\n            used to initialize the model's RNG for generating\n            random variables and random transitions.\n\n    See class docstring for other parameters.\n    \"\"\"\n\n    self.state_variable_manager = state_variable_manager\n    self.compartments = state_variable_manager.compartments\n    self.epi_metrics = state_variable_manager.epi_metrics\n    self.dynamic_vals = state_variable_manager.dynamic_vals\n    self.schedules = state_variable_manager.schedules\n\n    self.transition_variables = transition_variables\n    self.transition_variable_groups = transition_variable_groups\n\n    self.fixed_params = fixed_params\n    self.config = config\n\n    # Create bit generator seeded with given RNG_seed\n    self._bit_generator = np.random.MT19937(seed=RNG_seed)\n    self.RNG = np.random.Generator(self._bit_generator)\n\n    self.current_simulation_day = 0\n\n    if isinstance(config.start_real_date, datetime.date):\n        self.start_real_date = config.start_real_date\n    else:\n        try:\n            self.start_real_date = \\\n                datetime.datetime.strptime(config.start_real_date, \"%Y-%m-%d\").date()\n        except ValueError:\n            print(\"Error: The date format should be YYYY-MM-DD.\")\n    self.current_real_date = self.start_real_date\n\n    self.lookup_by_name = self.create_lookup_by_name()\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransmissionModel.create_lookup_by_name","title":"<code>create_lookup_by_name()</code>","text":"<p>Create lookup_by_name attribute -- keys are names of StateVariable, TransitionVariable, and TransitionVariableGroup instances associated with the model -- values are the actual object.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def create_lookup_by_name(self) -&gt; dict:\n    \"\"\"\n    Create lookup_by_name attribute --\n    keys are names of StateVariable, TransitionVariable,\n    and TransitionVariableGroup instances associated\n    with the model -- values are the actual object.\n    \"\"\"\n\n    lookup_by_name = {}\n\n    for unit in self.compartments + self.epi_metrics + \\\n                self.dynamic_vals + self.schedules + \\\n                self.transition_variables + self.transition_variable_groups:\n        lookup_by_name[unit.name] = unit\n\n    return lookup_by_name\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransmissionModel.modify_random_seed","title":"<code>modify_random_seed(new_seed_number)</code>","text":"<p>Modifies model's RNG attribute in-place to new generator seeded at new_seed_number.</p> <p>Parameters:</p> Name Type Description Default <code>new_seed_number</code> <code>int</code> <p>used to re-seed model's random number generator.</p> required Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def modify_random_seed(self, new_seed_number) -&gt; None:\n    \"\"\"\n    Modifies model's RNG attribute in-place to new generator\n    seeded at new_seed_number.\n\n    Args:\n        new_seed_number (int):\n            used to re-seed model's random number generator.\n    \"\"\"\n\n    self._bit_generator = np.random.MT19937(seed=new_seed_number)\n    self.RNG = np.random.Generator(self._bit_generator)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransmissionModel.reset_simulation","title":"<code>reset_simulation()</code>","text":"<p>Reset simulation in-place. Subsequent method calls of simulate_until_time_period start from day 0, with original day 0 state.</p> <p>Returns current_simulation_day to 0. Restores sim_state values to initial values. Clears history on model's compartments, transition variables, and dynamic vals.</p> WARNING <p>DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE WHERE IT LEFT OFF.</p> <p>Use method modify_random_seed to reset model's RNG to its initial starting seed.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def reset_simulation(self) -&gt; None:\n    \"\"\"\n    Reset simulation in-place. Subsequent method calls of\n    simulate_until_time_period start from day 0, with original\n    day 0 state.\n\n    Returns current_simulation_day to 0.\n    Restores sim_state values to initial values.\n    Clears history on model's compartments, transition variables,\n    and dynamic vals.\n\n    WARNING:\n        DOES NOT RESET THE MODEL'S RANDOM NUMBER GENERATOR TO\n        ITS INITIAL STARTING SEED. RANDOM NUMBER GENERATOR WILL CONTINUE\n        WHERE IT LEFT OFF.\n\n    Use method modify_random_seed to reset model's RNG to its\n    initial starting seed.\n    \"\"\"\n\n    self.current_simulation_day = 0\n\n    self.current_real_date = self.start_real_date\n\n    self.state_variable_manager.reset_sim_state()\n\n    self.state_variable_manager.clear_history()\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransmissionModel.simulate_until_time_period","title":"<code>simulate_until_time_period(last_simulation_day)</code>","text":"<p>Advance simulation model time until last_simulation_day.</p> <p>Advance time by iterating through simulation days, which are simulated by iterating through discretized timesteps.</p> <p>Save daily simulation data as history on each EpiCompartment instance.</p> <p>Parameters:</p> Name Type Description Default <code>last_simulation_day</code> <code>positive int</code> <p>stop simulation at last_simulation_day (i.e. exclusive, simulate up to but not including last_simulation_day).</p> required Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def simulate_until_time_period(self, last_simulation_day) -&gt; None:\n    \"\"\"\n    Advance simulation model time until last_simulation_day.\n\n    Advance time by iterating through simulation days,\n    which are simulated by iterating through discretized\n    timesteps.\n\n    Save daily simulation data as history on each EpiCompartment\n    instance.\n\n    Args:\n        last_simulation_day (positive int):\n            stop simulation at last_simulation_day (i.e. exclusive,\n            simulate up to but not including last_simulation_day).\n    \"\"\"\n\n    if self.current_simulation_day &gt; last_simulation_day:\n        raise TransmissionModelError(f\"Current day counter ({self.current_simulation_day}) \"\n                                     f\"exceeds last simulation day ({last_simulation_day}).\")\n\n    save_daily_history = self.config.save_daily_history\n\n    # last_simulation_day is exclusive endpoint\n    while self.current_simulation_day &lt; last_simulation_day:\n\n        self._prepare_daily_state()\n\n        self._simulate_timesteps()\n\n        if save_daily_history:\n            self._save_daily_history()\n\n        self._increment_simulation_day()\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.TransmissionModelError","title":"<code>TransmissionModelError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exceptions for simulation model errors.</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>class TransmissionModelError(Exception):\n    \"\"\"Custom exceptions for simulation model errors.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/#CLT_BaseModel.base_components.approx_binomial_probability_from_rate","title":"<code>approx_binomial_probability_from_rate(rate, interval_length)</code>","text":"<p>Converts a rate (events per time) to the probability of any event occurring in the next time interval of length interval_length, assuming the number of events occurring in time interval follows a Poisson distribution with given rate parameter.</p> <p>The probability of 0 events in time_interval_length is e^(-rate * time_interval_length), so the probability of any event in time_interval_length is 1 - e^(-rate * time_interval_length).</p> <p>Rate must be A x L np.ndarray, where A is the number of age groups and L is the number of risk groups. Rate is transformed to A x L np.ndarray corresponding to probabilities.</p> <p>Parameters:</p> Name Type Description Default <code>rate</code> <code>ndarray</code> <p>dimension A x L (number of age groups x number of risk groups), rate parameters in a Poisson distribution.</p> required <code>interval_length</code> <code>positive int</code> <p>length of time interval in simulation days.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: array of positive scalars, dimension A x L</p> Source code in <code>CLT_BaseModel/base_components.py</code> <pre><code>def approx_binomial_probability_from_rate(rate: np.ndarray,\n                                          interval_length: int) -&gt; np.ndarray:\n    \"\"\"\n    Converts a rate (events per time) to the probability of any event\n    occurring in the next time interval of length interval_length,\n    assuming the number of events occurring in time interval\n    follows a Poisson distribution with given rate parameter.\n\n    The probability of 0 events in time_interval_length is\n    e^(-rate * time_interval_length), so the probability of any event\n    in time_interval_length is 1 - e^(-rate * time_interval_length).\n\n    Rate must be A x L np.ndarray, where A is the number of age groups\n    and L is the number of risk groups. Rate is transformed to\n    A x L np.ndarray corresponding to probabilities.\n\n    Parameters:\n        rate (np.ndarray):\n            dimension A x L (number of age groups x number of risk groups),\n            rate parameters in a Poisson distribution.\n        interval_length (positive int):\n            length of time interval in simulation days.\n\n    Returns:\n        np.ndarray: array of positive scalars, dimension A x L\n    \"\"\"\n\n    return 1 - np.exp(-rate * interval_length)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluContactMatrix","title":"<code>FluContactMatrix</code>","text":"<p>               Bases: <code>Schedule</code></p> <p>Attributes:</p> Name Type Description <code>timeseries_df</code> <code>DataFrame</code> <p>has a \"date\" column with strings in format \"YYYY-MM-DD\" of consecutive calendar days, and other columns named \"is_school_day\" (bool) and \"is_work_day\" (bool) corresponding to type of day.</p> <code>total_contact_matrix</code> <code>ndarray</code> <p>(A x L) x (A x L) np.ndarray, where A is the number of age groups and L is the number of risk groups.</p> <p>See parent class docstring for other attributes.</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>class FluContactMatrix(base.Schedule):\n    \"\"\"\n\n    Attributes:\n        timeseries_df (pd.DataFrame):\n            has a \"date\" column with strings in format \"YYYY-MM-DD\"\n            of consecutive calendar days, and other columns\n            named \"is_school_day\" (bool) and \"is_work_day\" (bool)\n            corresponding to type of day.\n        total_contact_matrix (np.ndarray):\n            (A x L) x (A x L) np.ndarray, where A is the number\n            of age groups and L is the number of risk groups.\n\n    See parent class docstring for other attributes.\n    \"\"\"\n\n    def __init__(self,\n                 name: str,\n                 init_val: Optional[Union[np.ndarray, float]]=None):\n        super().__init__(name, init_val)\n\n        df = pd.read_csv(base_path / \"school_work_calendar.csv\", index_col=0)\n        df[\"date\"] = pd.to_datetime(df[\"date\"]).dt.date\n\n        self.time_series_df = df\n\n        self.total_contact_matrix = np.array([[3.5, 1.5], [3, 3.5]]).reshape((2,1,2,1))\n        self.school_contact_matrix = np.array([[2, 1], [1, 1]]).reshape((2,1,2,1))\n        self.work_contact_matrix = np.array([[0, 0], [1, 2]]).reshape((2,1,2,1))\n\n    def update_current_val(self, current_date: datetime.date) -&gt; None:\n        \"\"\"\n        Subclasses must provide a concrete implementation of\n        updating self.current_val in-place\n\n        Args:\n            current_date (datetime.date):\n                real-world date corresponding to\n                model's current simulation day\n        \"\"\"\n\n        df = self.time_series_df\n\n        try:\n            current_row = df[df[\"date\"] == current_date].iloc[0]\n        except IndexError:\n            print(f\"Error: {current_date} is not in the Calendar's time_series_df.\")\n\n        self.current_val = self.total_contact_matrix - \\\n                           (1 - current_row[\"is_school_day\"]) * self.school_contact_matrix - \\\n                           (1 - current_row[\"is_work_day\"]) * self.work_contact_matrix\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluContactMatrix.update_current_val","title":"<code>update_current_val(current_date)</code>","text":"<p>Subclasses must provide a concrete implementation of updating self.current_val in-place</p> <p>Parameters:</p> Name Type Description Default <code>current_date</code> <code>date</code> <p>real-world date corresponding to model's current simulation day</p> required Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>def update_current_val(self, current_date: datetime.date) -&gt; None:\n    \"\"\"\n    Subclasses must provide a concrete implementation of\n    updating self.current_val in-place\n\n    Args:\n        current_date (datetime.date):\n            real-world date corresponding to\n            model's current simulation day\n    \"\"\"\n\n    df = self.time_series_df\n\n    try:\n        current_row = df[df[\"date\"] == current_date].iloc[0]\n    except IndexError:\n        print(f\"Error: {current_date} is not in the Calendar's time_series_df.\")\n\n    self.current_val = self.total_contact_matrix - \\\n                       (1 - current_row[\"is_school_day\"]) * self.school_contact_matrix - \\\n                       (1 - current_row[\"is_work_day\"]) * self.work_contact_matrix\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluFixedParams","title":"<code>FluFixedParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>FixedParams</code></p> <p>Data container for pre-specified and fixed epidemiological parameters in FluModel flu model. Along with FluSimState, is passed to get_current_rate and get_change_in_current_val.</p> <p>Assume that FluFixedParams fields are constant or piecewise constant throughout the simulation. For variables that are more complicated and time-dependent, use a EpiMetric instead.</p> <p>Each field of datatype np.ndarray must be A x L, where A is the number of age groups and L is the number of risk groups. Note: this means all arrays should be 2D. See FluSimState docstring for important formatting note on 2D arrays.</p> when adding multiple strains, need to add subscripts <p>to math of attributes and add strain-specific description</p> Note <p>For attribute description, \"pseudo-LaTeX\" is used -- backslashes are omitted due to their incompatibility with Python docstrings.</p> <p>Attributes:</p> Name Type Description <code>num_age_groups</code> <code>positive int</code> <p>number of age groups -- math variable: \\(|A|\\), where \\(A\\) is the set of age groups.</p> <code>num_risk_groups</code> <code>positive int</code> <p>number of risk groups -- math variable: \\(|L|\\), where \\(L\\) is the set of risk groups.</p> <code>beta_baseline</code> <code>positive float</code> <p>transmission rate -- math variable: \\(beta_0\\).</p> <code>total_population_val</code> <code>np.ndarray of positive ints</code> <p>total number in population, summed across all age-risk groups -- math variable: \\(N\\).</p> <code>humidity_impact</code> <code>positive float</code> <p>coefficient that determines how much absolute humidity affects beta_baseline -- math variable: \\(xi\\).</p> <code>immunity_hosp_increase_factor</code> <code>positive float</code> <p>factor by which population-level immunity against hospitalization grows after each case that recovers -- math variable: \\(g^H\\).</p> <code>immunity_inf_increase_factor</code> <code>positive float</code> <p>factor by which population-level immunity against infection grows after each case     that recovers -- math variable: \\(g^I\\).</p> <code>immunity_saturation_constant</code> <code>positive float</code> <p>constant modeling saturation of antibody production of individuals -- math variable: \\(o\\).</p> <code>waning_factor_hosp</code> <code>positive float</code> <p>rate at which infection-induced immunity against hospitalization wanes -- math variable: \\(w^H\\).</p> <code>waning_factor_inf</code> <code>positive float</code> <p>rate at which infection-induced immunity against infection wanes -- math variable: \\(w^I\\).</p> <code>hosp_risk_reduction</code> <code>positive float in [0,1]</code> <p>reduction in hospitalization risk from infection-induced immunity -- math variable: \\(K^H\\).</p> <code>inf_risk_reduction</code> <code>positive float in [0,1]</code> <p>reduction in infection risk from infection-induced immunity -- math variable: \\(K^I\\).</p> <code>death_risk_reduction</code> <code>positive float in [0,1]</code> <p>reduction in death risk from infection-induced immunity -- math variable: \\(K^D\\).</p> <code>R_to_S_rate</code> <code>positive float</code> <p>rate at which people in R move to S -- math variable: \\(eta\\).</p> <code>E_to_I_rate</code> <code>positive float</code> <p>rate at which people in E move to I -- math variable: \\(omega\\).</p> <code>I_to_R_rate</code> <code>positive float</code> <p>rate at which people in I move to R -- math variable: \\(gamma\\).</p> <code>I_to_H_rate</code> <code>positive float</code> <p>rate at which people in I move to H -- math variable: \\(zeta\\).</p> <code>H_to_R_rate</code> <code>positive float</code> <p>rate at which people in H move to R -- math variable: \\(gamma_H\\).</p> <code>H_to_D_rate</code> <code>positive float</code> <p>rate at which people in H move to D -- math variable: \\(pi\\).</p> <code>I_to_H_adjusted_proportion</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion -- infected who are hospitalized based on age-risk groups -- math variable: \\([tilde{mu}_{a, ell}]\\).</p> <code>H_to_D_adjusted_proportion</code> <code>np.ndarray of positive floats in [0,1]</code> <p>rate-adjusted proportion hospitalized who die based on age-risk groups -- math variable: \\([tilde{nu}_{a, ell}]\\).</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>@dataclass\nclass FluFixedParams(base.FixedParams):\n    \"\"\"\n    Data container for pre-specified and fixed epidemiological\n    parameters in FluModel flu model. Along with FluSimState,\n    is passed to get_current_rate and get_change_in_current_val.\n\n    Assume that FluFixedParams fields are constant or piecewise\n    constant throughout the simulation. For variables that\n    are more complicated and time-dependent, use a EpiMetric\n    instead.\n\n    Each field of datatype np.ndarray must be A x L,\n    where A is the number of age groups and L is the number of\n    risk groups. Note: this means all arrays should be 2D.\n    See FluSimState docstring for important formatting note\n    on 2D arrays.\n\n    TODO: when adding multiple strains, need to add subscripts\n        to math of attributes and add strain-specific description\n\n    Note:\n        For attribute description, \"pseudo-LaTeX\" is used --\n        backslashes are omitted due to their incompatibility\n        with Python docstrings.\n\n    Attributes:\n        num_age_groups (positive int):\n            number of age groups -- math variable:\n            $|A|$, where $A$ is the set of age groups.\n        num_risk_groups (positive int):\n            number of risk groups -- math variable:\n            $|L|$, where $L$ is the set of risk groups.\n        beta_baseline (positive float): transmission rate\n            -- math variable: $beta_0$.\n        total_population_val (np.ndarray of positive ints):\n            total number in population, summed across all\n            age-risk groups -- math variable: $N$.\n        humidity_impact (positive float):\n            coefficient that determines how much absolute\n            humidity affects beta_baseline -- math variable: $xi$.\n        immunity_hosp_increase_factor (positive float):\n            factor by which population-level immunity\n            against hospitalization grows after each\n            case that recovers -- math variable: $g^H$.\n        immunity_inf_increase_factor (positive float):\n            factor by which population-level immunity\n            against infection grows after each case\n                that recovers -- math variable: $g^I$.\n        immunity_saturation_constant (positive float):\n            constant modeling saturation of antibody\n            production of individuals -- math variable: $o$.\n        waning_factor_hosp (positive float):\n            rate at which infection-induced immunity\n            against hospitalization wanes -- math variable: $w^H$.\n        waning_factor_inf (positive float):\n            rate at which infection-induced immunity\n            against infection wanes -- math variable: $w^I$.\n        hosp_risk_reduction (positive float in [0,1]):\n            reduction in hospitalization risk from\n            infection-induced immunity -- math variable: $K^H$.\n        inf_risk_reduction (positive float in [0,1]):\n            reduction in infection risk\n            from infection-induced immunity -- math variable: $K^I$.\n        death_risk_reduction (positive float in [0,1]):\n            reduction in death risk from infection-induced immunity\n            -- math variable: $K^D$.\n        R_to_S_rate (positive float):\n            rate at which people in R move to S -- math variable: $eta$.\n        E_to_I_rate (positive float):\n            rate at which people in E move to I -- math variable: $omega$.\n        I_to_R_rate (positive float):\n            rate at which people in I move to R -- math variable: $gamma$.\n        I_to_H_rate (positive float):\n            rate at which people in I move to H -- math variable: $zeta$.\n        H_to_R_rate (positive float):\n            rate at which people in H move to R -- math variable: $gamma_H$.\n        H_to_D_rate (positive float):\n            rate at which people in H move to D -- math variable: $pi$.\n        I_to_H_adjusted_proportion (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion -- infected who are hospitalized\n            based on age-risk groups -- math variable: $[tilde{mu}_{a, ell}]$.\n        H_to_D_adjusted_proportion (np.ndarray of positive floats in [0,1]):\n            rate-adjusted proportion hospitalized who die based on\n            age-risk groups -- math variable: $[tilde{nu}_{a, ell}]$.\n    \"\"\"\n\n    num_age_groups: Optional[int] = None\n    num_risk_groups: Optional[int] = None\n    beta_baseline: Optional[float] = None\n    total_population_val: Optional[np.ndarray] = None\n    humidity_impact: Optional[float] = None\n    immunity_hosp_increase_factor: Optional[float] = None\n    immunity_inf_increase_factor: Optional[float] = None\n    immunity_saturation_constant: Optional[float] = None\n    waning_factor_hosp: Optional[float] = None\n    waning_factor_inf: Optional[float] = None\n    hosp_risk_reduction: Optional[float] = None\n    inf_risk_reduction: Optional[float] = None\n    death_risk_reduction: Optional[float] = None\n    R_to_S_rate: Optional[float] = None\n    E_to_I_rate: Optional[float] = None\n    I_to_R_rate: Optional[float] = None\n    I_to_H_rate: Optional[float] = None\n    H_to_R_rate: Optional[float] = None\n    H_to_D_rate: Optional[float] = None\n    I_to_H_adjusted_proportion: Optional[np.ndarray] = None\n    H_to_D_adjusted_proportion: Optional[np.ndarray] = None\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluModelConstructor","title":"<code>FluModelConstructor</code>","text":"<p>               Bases: <code>ModelConstructor</code></p> <p>Class for creating ImmunoSEIRS flu model with predetermined fixed structure -- initial values and epidemiological structure are populated by user-specified JSON files.</p> <p>Key method create_transmission_model returns a TransmissionModel instance with S-E-I-H-R-D compartments and population_immunity_inf and population_immunity_hosp epi metrics. The structure is as follows:     S = new_susceptible - new_exposed     E = new_exposed - new_infected     I = new_infected - new_recovered_home - new_hospitalized     H = new_hospitalized - new_recovered_hosp - new_dead     R = new_recovered_home + new_recovered_hosp - new_susceptible     D = new_dead</p> The following are TransitionVariable instances <p>new_susceptible is a NewSusceptible instance new_exposed is a NewExposed instance new_infected is a NewInfected instance new_hospitalized is a NewHospitalized instance new_recovered_home is a NewRecoveredHome instance new_recovered_hosp is a NewRecoveredHosp instance new_dead is a NewDead instance</p> There are two TransitionVariableGroups <p>I_out (since new_recovered_home and new_hospitalized are joint random variables) H_out (since new_recovered_hosp and new_dead are joint random variables)</p> The following are EpiMetric instances <p>population_immunity_inf is a PopulationImmunityInf instance population_immunity_hosp is a PopulationImmunityHosp instance</p> <p>Transition rates and update formulas are specified in     corresponding classes.</p> <p>Attributes:</p> Name Type Description <code>config</code> <code>Config</code> <p>holds configuration values.</p> <code>fixed_params</code> <code>FluFixedParams</code> <p>holds epidemiological parameter values, read-in from user-specified JSON.</p> <code>sim_state</code> <code>FluSimState</code> <p>holds current simulation state information, such as current values of epidemiological compartments and epi metrics, read in from user-specified JSON.</p> <code>transition_variable_lookup</code> <code>dict</code> <p>maps string to corresponding TransitionVariable.</p> <code>transition_variable_group_lookup</code> <code>dict</code> <p>maps string to corresponding TransitionVariableGroup.</p> <code>compartment_lookup</code> <code>dict</code> <p>maps string to corresponding EpiCompartment, using the value of the EpiCompartment's \"name\" attribute.</p> <code>epi_metric_lookup</code> <code>dict</code> <p>maps string to corresponding EpiMetric, using the value of the EpiMetric's \"name\" attribute.</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>class FluModelConstructor(base.ModelConstructor):\n    \"\"\"\n    Class for creating ImmunoSEIRS flu model with predetermined fixed\n    structure -- initial values and epidemiological structure are\n    populated by user-specified JSON files.\n\n    Key method create_transmission_model returns a TransmissionModel\n    instance with S-E-I-H-R-D compartments and population_immunity_inf\n    and population_immunity_hosp epi metrics. The structure\n    is as follows:\n        S = new_susceptible - new_exposed\n        E = new_exposed - new_infected\n        I = new_infected - new_recovered_home - new_hospitalized\n        H = new_hospitalized - new_recovered_hosp - new_dead\n        R = new_recovered_home + new_recovered_hosp - new_susceptible\n        D = new_dead\n\n    The following are TransitionVariable instances:\n        new_susceptible is a NewSusceptible instance\n        new_exposed is a NewExposed instance\n        new_infected is a NewInfected instance\n        new_hospitalized is a NewHospitalized instance\n        new_recovered_home is a NewRecoveredHome instance\n        new_recovered_hosp is a NewRecoveredHosp instance\n        new_dead is a NewDead instance\n\n    There are two TransitionVariableGroups:\n        I_out (since new_recovered_home and new_hospitalized are joint random variables)\n        H_out (since new_recovered_hosp and new_dead are joint random variables)\n\n    The following are EpiMetric instances:\n        population_immunity_inf is a PopulationImmunityInf instance\n        population_immunity_hosp is a PopulationImmunityHosp instance\n\n    Transition rates and update formulas are specified in\n        corresponding classes.\n\n    Attributes:\n        config (Config):\n            holds configuration values.\n        fixed_params (FluFixedParams):\n            holds epidemiological parameter values, read-in\n            from user-specified JSON.\n        sim_state (FluSimState):\n            holds current simulation state information,\n            such as current values of epidemiological compartments\n            and epi metrics, read in from user-specified JSON.\n        transition_variable_lookup (dict):\n            maps string to corresponding TransitionVariable.\n        transition_variable_group_lookup (dict):\n            maps string to corresponding TransitionVariableGroup.\n        compartment_lookup (dict):\n            maps string to corresponding EpiCompartment,\n            using the value of the EpiCompartment's \"name\" attribute.\n        epi_metric_lookup (dict):\n            maps string to corresponding EpiMetric,\n            using the value of the EpiMetric's \"name\" attribute.\n    \"\"\"\n\n    def __init__(self,\n                 config_filepath: Optional[str] = None,\n                 fixed_params_filepath: Optional[str] = None,\n                 state_vars_init_vals_filepath: Optional[str] = None):\n        \"\"\"\n        Create Config, FluFixedParams, and FluSimState instances\n        using values from respective JSON files, and save these instances\n        on the FluModelConstructor to construct a model.\n\n        If any filepath is not specified, then user must manually assign\n        the respective attribute (config, fixed_params, or sim_state)\n        before using constructor to create a model.\n\n        Attributes:\n            config_filepath (Optional[str]):\n                path to config JSON file (path includes actual filename\n                with suffix \".json\") -- all JSON fields must match\n                name and datatype of Config instance attributes.\n            fixed_params_filepath (Optional[str]):\n                path to epidemiological parameters JSON file\n                (path includes actual filename with suffix \".json\")\n                -- all JSON fields must match name and datatype of\n                FixedParams instance attributes.\n            state_vars_init_vals_filepath (Optional[str]):\n                path to epidemiological compartments JSON file\n                (path includes actual filename with suffix \".json\")\n                -- all JSON fields must match name and datatype of\n                StateVariable instance attributes -- these initial\n                values are used to populate sim_state attribute.\n        \"\"\"\n\n        # Use same init method as abstract class --\n        # creates \"lookup\" attributes (dictionaries for easy access)\n        # and creates attributes config, fixed_params, and sim_state\n        super().__init__()\n\n        # Assign config, fixed_params, and sim_state to model-specific\n        # types of dataclasses that have epidemiological parameter information\n        # and sim state information\n        if config_filepath:\n            self.config = self.dataclass_instance_from_json(base.Config,\n                                                            config_filepath)\n\n        if fixed_params_filepath:\n            self.fixed_params = self.dataclass_instance_from_json(FluFixedParams,\n                                                                  fixed_params_filepath)\n\n        if state_vars_init_vals_filepath:\n            self.sim_state = \\\n                self.dataclass_instance_from_json(FluSimState,\n                                                  state_vars_init_vals_filepath)\n\n    def setup_epi_compartments(self) -&gt; None:\n        \"\"\"\n        Create compartments S-E-I-H-R-D (6 compartments total)\n        and add them to compartment_lookup for dictionary access\n        \"\"\"\n\n        for name in (\"S\", \"E\", \"I\", \"H\", \"R\", \"D\"):\n            self.compartment_lookup[name] = base.EpiCompartment(name, getattr(self.sim_state, name))\n\n    def setup_dynamic_vals(self) -&gt; None:\n        self.dynamic_val_lookup[\"beta_reduct\"] = BetaReduct(\"beta_reduct\")\n\n    def setup_schedules(self) -&gt; None:\n        self.schedule_lookup[\"absolute_humidity\"] = AbsoluteHumidity(\"absolute_humidity\")\n        self.schedule_lookup[\"flu_contact_matrix\"] = FluContactMatrix(\"flu_contact_matrix\")\n\n    def setup_transition_variables(self) -&gt; None:\n        \"\"\"\n        Create all transition variables described in docstring (7 transition\n        variables total) and add them to transition_variable_lookup attribute\n        for dictionary access\n        \"\"\"\n\n        compartments = self.compartment_lookup\n        transition_type = self.config.transition_type\n\n        # Reordering the tuples to put the transition function first\n        transition_mapping = {\n            \"new_susceptible\": (NewSusceptible, \"new_susceptible\", compartments[\"R\"], compartments[\"S\"]),\n            \"new_exposed\": (NewExposed, \"new_exposed\", compartments[\"S\"], compartments[\"E\"]),\n            \"new_infected\": (NewInfected, \"new_infected\", compartments[\"E\"], compartments[\"I\"]),\n            \"new_recovered_home\": (\n                NewRecoveredHome, \"new_recovered_home\", compartments[\"I\"], compartments[\"R\"], True),\n            \"new_hosp\": (NewHosp, \"new_hosp\", compartments[\"I\"], compartments[\"H\"], True),\n            \"new_recovered_hosp\": (\n                NewRecoveredHosp, \"new_recovered_hosp\", compartments[\"H\"], compartments[\"R\"], True),\n            \"new_dead\": (NewDead, \"new_dead\", compartments[\"H\"], compartments[\"D\"], True)\n        }\n\n        # Create transition variables dynamically\n        # params[0] is the TransitionVariable subclass (e.g. NewSusceptible)\n        # params[1:4] refers to the name, origin compartment, destination compartment list\n        # params[4:] contains the Boolean indicating if the transition variable is jointly\n        #   distributed (True if jointly distributed)\n        self.transition_variable_lookup = {\n            name: params[0](*params[1:4], transition_type, *params[4:])\n            for name, params in transition_mapping.items()\n        }\n\n    def setup_transition_variable_groups(self) -&gt; None:\n        \"\"\"\n        Create all transition variable groups described in docstring (2 transition\n        variable groups total) and add them to transition_variable_group_lookup attribute\n        for dictionary access\n        \"\"\"\n\n        # Shortcuts for attribute access\n        compartment_lookup = self.compartment_lookup\n        tvar_lookup = self.transition_variable_lookup\n        transition_type = self.config.transition_type\n\n        self.transition_variable_group_lookup = {\n            \"I_out\": base.TransitionVariableGroup(\"I_out\",\n                                                  compartment_lookup[\"I\"],\n                                                  transition_type,\n                                                  (tvar_lookup[\"new_recovered_home\"],\n                                                   tvar_lookup[\"new_hosp\"])),\n            \"H_out\": base.TransitionVariableGroup(\"H_out\",\n                                                  compartment_lookup[\"H\"],\n                                                  transition_type,\n                                                  (tvar_lookup[\"new_recovered_hosp\"],\n                                                   tvar_lookup[\"new_dead\"]))\n        }\n\n    def setup_epi_metrics(self) -&gt; None:\n        \"\"\"\n        Create all epi metric described in docstring (2 state\n        variables total) and add them to epi_metric_lookup attribute\n        for dictionary access\n        \"\"\"\n\n        self.epi_metric_lookup[\"population_immunity_inf\"] = \\\n            PopulationImmunityInf(\"population_immunity_inf\",\n                                  getattr(self.sim_state, \"population_immunity_inf\"),\n                                  self.transition_variable_lookup[\"new_susceptible\"])\n\n        self.epi_metric_lookup[\"population_immunity_hosp\"] = \\\n            PopulationImmunityHosp(\"population_immunity_hosp\",\n                                   getattr(self.sim_state, \"population_immunity_hosp\"),\n                                   self.transition_variable_lookup[\"new_susceptible\"])\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluModelConstructor.__init__","title":"<code>__init__(config_filepath=None, fixed_params_filepath=None, state_vars_init_vals_filepath=None)</code>","text":"<p>Create Config, FluFixedParams, and FluSimState instances using values from respective JSON files, and save these instances on the FluModelConstructor to construct a model.</p> <p>If any filepath is not specified, then user must manually assign the respective attribute (config, fixed_params, or sim_state) before using constructor to create a model.</p> <p>Attributes:</p> Name Type Description <code>config_filepath</code> <code>Optional[str]</code> <p>path to config JSON file (path includes actual filename with suffix \".json\") -- all JSON fields must match name and datatype of Config instance attributes.</p> <code>fixed_params_filepath</code> <code>Optional[str]</code> <p>path to epidemiological parameters JSON file (path includes actual filename with suffix \".json\") -- all JSON fields must match name and datatype of FixedParams instance attributes.</p> <code>state_vars_init_vals_filepath</code> <code>Optional[str]</code> <p>path to epidemiological compartments JSON file (path includes actual filename with suffix \".json\") -- all JSON fields must match name and datatype of StateVariable instance attributes -- these initial values are used to populate sim_state attribute.</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>def __init__(self,\n             config_filepath: Optional[str] = None,\n             fixed_params_filepath: Optional[str] = None,\n             state_vars_init_vals_filepath: Optional[str] = None):\n    \"\"\"\n    Create Config, FluFixedParams, and FluSimState instances\n    using values from respective JSON files, and save these instances\n    on the FluModelConstructor to construct a model.\n\n    If any filepath is not specified, then user must manually assign\n    the respective attribute (config, fixed_params, or sim_state)\n    before using constructor to create a model.\n\n    Attributes:\n        config_filepath (Optional[str]):\n            path to config JSON file (path includes actual filename\n            with suffix \".json\") -- all JSON fields must match\n            name and datatype of Config instance attributes.\n        fixed_params_filepath (Optional[str]):\n            path to epidemiological parameters JSON file\n            (path includes actual filename with suffix \".json\")\n            -- all JSON fields must match name and datatype of\n            FixedParams instance attributes.\n        state_vars_init_vals_filepath (Optional[str]):\n            path to epidemiological compartments JSON file\n            (path includes actual filename with suffix \".json\")\n            -- all JSON fields must match name and datatype of\n            StateVariable instance attributes -- these initial\n            values are used to populate sim_state attribute.\n    \"\"\"\n\n    # Use same init method as abstract class --\n    # creates \"lookup\" attributes (dictionaries for easy access)\n    # and creates attributes config, fixed_params, and sim_state\n    super().__init__()\n\n    # Assign config, fixed_params, and sim_state to model-specific\n    # types of dataclasses that have epidemiological parameter information\n    # and sim state information\n    if config_filepath:\n        self.config = self.dataclass_instance_from_json(base.Config,\n                                                        config_filepath)\n\n    if fixed_params_filepath:\n        self.fixed_params = self.dataclass_instance_from_json(FluFixedParams,\n                                                              fixed_params_filepath)\n\n    if state_vars_init_vals_filepath:\n        self.sim_state = \\\n            self.dataclass_instance_from_json(FluSimState,\n                                              state_vars_init_vals_filepath)\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluModelConstructor.setup_epi_compartments","title":"<code>setup_epi_compartments()</code>","text":"<p>Create compartments S-E-I-H-R-D (6 compartments total) and add them to compartment_lookup for dictionary access</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>def setup_epi_compartments(self) -&gt; None:\n    \"\"\"\n    Create compartments S-E-I-H-R-D (6 compartments total)\n    and add them to compartment_lookup for dictionary access\n    \"\"\"\n\n    for name in (\"S\", \"E\", \"I\", \"H\", \"R\", \"D\"):\n        self.compartment_lookup[name] = base.EpiCompartment(name, getattr(self.sim_state, name))\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluModelConstructor.setup_epi_metrics","title":"<code>setup_epi_metrics()</code>","text":"<p>Create all epi metric described in docstring (2 state variables total) and add them to epi_metric_lookup attribute for dictionary access</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>def setup_epi_metrics(self) -&gt; None:\n    \"\"\"\n    Create all epi metric described in docstring (2 state\n    variables total) and add them to epi_metric_lookup attribute\n    for dictionary access\n    \"\"\"\n\n    self.epi_metric_lookup[\"population_immunity_inf\"] = \\\n        PopulationImmunityInf(\"population_immunity_inf\",\n                              getattr(self.sim_state, \"population_immunity_inf\"),\n                              self.transition_variable_lookup[\"new_susceptible\"])\n\n    self.epi_metric_lookup[\"population_immunity_hosp\"] = \\\n        PopulationImmunityHosp(\"population_immunity_hosp\",\n                               getattr(self.sim_state, \"population_immunity_hosp\"),\n                               self.transition_variable_lookup[\"new_susceptible\"])\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluModelConstructor.setup_transition_variable_groups","title":"<code>setup_transition_variable_groups()</code>","text":"<p>Create all transition variable groups described in docstring (2 transition variable groups total) and add them to transition_variable_group_lookup attribute for dictionary access</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>def setup_transition_variable_groups(self) -&gt; None:\n    \"\"\"\n    Create all transition variable groups described in docstring (2 transition\n    variable groups total) and add them to transition_variable_group_lookup attribute\n    for dictionary access\n    \"\"\"\n\n    # Shortcuts for attribute access\n    compartment_lookup = self.compartment_lookup\n    tvar_lookup = self.transition_variable_lookup\n    transition_type = self.config.transition_type\n\n    self.transition_variable_group_lookup = {\n        \"I_out\": base.TransitionVariableGroup(\"I_out\",\n                                              compartment_lookup[\"I\"],\n                                              transition_type,\n                                              (tvar_lookup[\"new_recovered_home\"],\n                                               tvar_lookup[\"new_hosp\"])),\n        \"H_out\": base.TransitionVariableGroup(\"H_out\",\n                                              compartment_lookup[\"H\"],\n                                              transition_type,\n                                              (tvar_lookup[\"new_recovered_hosp\"],\n                                               tvar_lookup[\"new_dead\"]))\n    }\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluModelConstructor.setup_transition_variables","title":"<code>setup_transition_variables()</code>","text":"<p>Create all transition variables described in docstring (7 transition variables total) and add them to transition_variable_lookup attribute for dictionary access</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>def setup_transition_variables(self) -&gt; None:\n    \"\"\"\n    Create all transition variables described in docstring (7 transition\n    variables total) and add them to transition_variable_lookup attribute\n    for dictionary access\n    \"\"\"\n\n    compartments = self.compartment_lookup\n    transition_type = self.config.transition_type\n\n    # Reordering the tuples to put the transition function first\n    transition_mapping = {\n        \"new_susceptible\": (NewSusceptible, \"new_susceptible\", compartments[\"R\"], compartments[\"S\"]),\n        \"new_exposed\": (NewExposed, \"new_exposed\", compartments[\"S\"], compartments[\"E\"]),\n        \"new_infected\": (NewInfected, \"new_infected\", compartments[\"E\"], compartments[\"I\"]),\n        \"new_recovered_home\": (\n            NewRecoveredHome, \"new_recovered_home\", compartments[\"I\"], compartments[\"R\"], True),\n        \"new_hosp\": (NewHosp, \"new_hosp\", compartments[\"I\"], compartments[\"H\"], True),\n        \"new_recovered_hosp\": (\n            NewRecoveredHosp, \"new_recovered_hosp\", compartments[\"H\"], compartments[\"R\"], True),\n        \"new_dead\": (NewDead, \"new_dead\", compartments[\"H\"], compartments[\"D\"], True)\n    }\n\n    # Create transition variables dynamically\n    # params[0] is the TransitionVariable subclass (e.g. NewSusceptible)\n    # params[1:4] refers to the name, origin compartment, destination compartment list\n    # params[4:] contains the Boolean indicating if the transition variable is jointly\n    #   distributed (True if jointly distributed)\n    self.transition_variable_lookup = {\n        name: params[0](*params[1:4], transition_type, *params[4:])\n        for name, params in transition_mapping.items()\n    }\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.FluSimState","title":"<code>FluSimState</code>  <code>dataclass</code>","text":"<p>               Bases: <code>SimState</code></p> <p>Data container for pre-specified and fixed set of EpiCompartment initial values and EpiMetric initial values in FluModel flu model.</p> <p>Each field below should be A x L np.ndarray, where A is the number of age groups and L is the number of risk groups. Note: this means all arrays should be 2D. Even if there is 1 age group and 1 risk group (no group stratification), each array should be 1x1, which is two-dimensional. For example, np.array([[100]]) is correct -- np.array([100]) is wrong.</p> <p>Attributes:</p> Name Type Description <code>S</code> <code>np.ndarray of positive floats</code> <p>susceptible compartment for age-risk groups -- (holds current_val of EpiCompartment \"S\") -- math variable: \\(S\\).</p> <code>E</code> <code>np.ndarray of positive floats</code> <p>exposed compartment for age-risk groups -- (holds current_val of EpiCompartment \"E\") -- math variable: \\(E\\).</p> <code>I</code> <code>np.ndarray of positive floats</code> <p>infected compartment for age-risk groups (holds current_val of EpiCompartment \"I\") -- math variable: \\(I\\).</p> <code>H</code> <code>np.ndarray of positive floats</code> <p>hospital compartment for age-risk groups (holds current_val of EpiCompartment \"H\") -- math variable: \\(H\\).</p> <code>R</code> <code>np.ndarray of positive floats</code> <p>recovered compartment for age-risk groups (holds current_val of EpiCompartment \"R\") -- math variable: \\(R\\).</p> <code>D</code> <code>np.ndarray of positive floats</code> <p>dead compartment for age-risk groups (holds current_val of EpiCompartment \"D\") -- math variable: \\(D\\).</p> <code>population_immunity_hosp</code> <code>np.ndarray of positive floats</code> <p>infection-induced population-level immunity against hospitalization, for age-risk groups (holds current_val of EpiMetric \"population_immunity_hosp\") -- math variable: \\(M^H\\).</p> <code>population_immunity_inf</code> <code>np.ndarray of positive floats</code> <p>infection-induced population-level immunity against infection, for age-risk groups (holds current_val of EpiMetric \"population_immunity_inf\") -- math variable: \\(M^I\\).</p> <code>absolute_humidity</code> <code>positive float</code> <p>grams of water vapor per cubic meter g/m^3, used as seasonality parameter that influences transmission rate beta_baseline -- math variable: \\(q\\).</p> <code>flu_contact_matrix</code> <code>np.ndarray of positive floats</code> <p>A x L x A x L array, where A is the number of age groups and L is the number of risk groups -- element (a, l, a', l') corresponds to the number of contacts that a person in age-risk group a,l has with people in age-risk group a', l' -- math variable: \"phi$.</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>@dataclass\nclass FluSimState(base.SimState):\n    \"\"\"\n    Data container for pre-specified and fixed set of\n    EpiCompartment initial values and EpiMetric initial values\n    in FluModel flu model.\n\n    Each field below should be A x L np.ndarray, where\n    A is the number of age groups and L is the number of risk groups.\n    Note: this means all arrays should be 2D. Even if there is\n    1 age group and 1 risk group (no group stratification),\n    each array should be 1x1, which is two-dimensional.\n    For example, np.array([[100]]) is correct --\n    np.array([100]) is wrong.\n\n    Attributes:\n        S (np.ndarray of positive floats):\n            susceptible compartment for age-risk groups --\n            (holds current_val of EpiCompartment \"S\")\n            -- math variable: $S$.\n        E (np.ndarray of positive floats):\n            exposed compartment for age-risk groups --\n            (holds current_val of EpiCompartment \"E\")\n            -- math variable: $E$.\n        I (np.ndarray of positive floats):\n            infected compartment for age-risk groups\n            (holds current_val of EpiCompartment \"I\")\n            -- math variable: $I$.\n        H (np.ndarray of positive floats):\n            hospital compartment for age-risk groups\n            (holds current_val of EpiCompartment \"H\")\n            -- math variable: $H$.\n        R (np.ndarray of positive floats):\n            recovered compartment for age-risk groups\n            (holds current_val of EpiCompartment \"R\")\n            -- math variable: $R$.\n        D (np.ndarray of positive floats):\n            dead compartment for age-risk groups\n            (holds current_val of EpiCompartment \"D\")\n            -- math variable: $D$.\n        population_immunity_hosp (np.ndarray of positive floats):\n            infection-induced population-level immunity against\n            hospitalization, for age-risk groups (holds current_val\n            of EpiMetric \"population_immunity_hosp\") -- math variable: $M^H$.\n        population_immunity_inf (np.ndarray of positive floats):\n            infection-induced population-level immunity against\n            infection, for age-risk groups (holds current_val\n            of EpiMetric \"population_immunity_inf\") -- math variable: $M^I$.\n        absolute_humidity (positive float):\n            grams of water vapor per cubic meter g/m^3,\n            used as seasonality parameter that influences\n            transmission rate beta_baseline -- math variable: $q$.\n        flu_contact_matrix (np.ndarray of positive floats):\n            A x L x A x L array, where A is the number of age\n            groups and L is the number of risk groups --\n            element (a, l, a', l') corresponds to the number of\n            contacts that a person in age-risk group a,l\n            has with people in age-risk group a', l' --\n            math variable: \"phi$.\n    \"\"\"\n\n    S: Optional[np.ndarray] = None\n    E: Optional[np.ndarray] = None\n    I: Optional[np.ndarray] = None\n    H: Optional[np.ndarray] = None\n    R: Optional[np.ndarray] = None\n    D: Optional[np.ndarray] = None\n    population_immunity_hosp: Optional[np.ndarray] = None\n    population_immunity_inf: Optional[np.ndarray] = None\n    absolute_humidity: Optional[float] = None\n    flu_contact_matrix: Optional[np.ndarray] = None\n</code></pre>"},{"location":"reference/#CLT_BaseModel.flu_components.absolute_humidity_func","title":"<code>absolute_humidity_func(current_date)</code>","text":"<p>Note: this is a dummy function loosely based off of the absolute humidity data from Kaiming and Shraddha's new burden averted draft.</p> <p>TODO: replace this function with real humidity function</p> <p>The following calculation is used to achieve the correct     upside-down parabola with the right min and max     values and location     max_value = 12.5     0.00027 = (max_value - k) / ((0 - h) ** 2)</p> <p>Parameters:</p> Name Type Description Default <code>current_date</code> <code>date</code> <p>datetime.date object corresponding to real-world date</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>nonnegative float between 3.8 and 12.5 corresponding to absolute humidity that day of the year</p> Source code in <code>CLT_BaseModel/flu_components.py</code> <pre><code>def absolute_humidity_func(current_date: datetime.date):\n    \"\"\"\n    Note: this is a dummy function loosely based off of\n    the absolute humidity data from Kaiming and Shraddha's\n    new burden averted draft.\n\n    TODO: replace this function with real humidity function\n\n    The following calculation is used to achieve the correct\n        upside-down parabola with the right min and max\n        values and location\n        max_value = 12.5\n        0.00027 = (max_value - k) / ((0 - h) ** 2)\n\n    Args:\n        current_date (datetime.date):\n            datetime.date object corresponding to\n            real-world date\n\n    Returns:\n        float:\n            nonnegative float between 3.8 and 12.5\n            corresponding to absolute humidity\n            that day of the year\n    \"\"\"\n\n    # Convert datetime.date to integer between 1 and 365\n    #   corresponding to day of the year\n    day_of_year = current_date.timetuple().tm_yday\n\n    # Vertex of the parabola\n    h = 180\n    k = 3.8\n\n    # Shift by 180 (6 months roughly), because minimum humidity occurs in\n    #   January, but Kaiming and Shraddha's graph starts in July\n    return k + 0.00027 * (day_of_year - 180 - h) ** 2\n</code></pre>"}]}